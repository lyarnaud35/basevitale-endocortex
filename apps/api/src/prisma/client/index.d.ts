
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Patient
 * Patient identifié par INS (Identité Nationale de Santé)
 * Un patient = Un Token unique (INS)
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model SemanticNode
 * Nœud sémantique dans le Knowledge Graph
 * Représente une entité médicale (symptôme, diagnostic, médicament, etc.)
 */
export type SemanticNode = $Result.DefaultSelection<Prisma.$SemanticNodePayload>
/**
 * Model SemanticRelation
 * Relation entre nœuds sémantiques
 * Représente un lien causal, temporel, ou sémantique dans le Knowledge Graph
 */
export type SemanticRelation = $Result.DefaultSelection<Prisma.$SemanticRelationPayload>
/**
 * Model ConsultationDraft
 * ConsultationDraft - Phase 2: Ossification des Contrats
 * Draft de consultation avec données structurées stockées en JSONB
 * Architecture v150: JSONB pour flexibilité, colonnes strictes pour métadonnées
 */
export type ConsultationDraft = $Result.DefaultSelection<Prisma.$ConsultationDraftPayload>
/**
 * Model Consultation
 * Consultation médicale
 * Draft stocké en JSONB, validé puis transformé en nœuds sémantiques
 */
export type Consultation = $Result.DefaultSelection<Prisma.$ConsultationPayload>
/**
 * Model BillingEvent
 * Événement de facturation
 * Généré automatiquement depuis le Knowledge Graph (Module E+)
 */
export type BillingEvent = $Result.DefaultSelection<Prisma.$BillingEventPayload>
/**
 * Model Allergy
 * Allergie déclarée par le patient
 */
export type Allergy = $Result.DefaultSelection<Prisma.$AllergyPayload>
/**
 * Model MedicalDocument
 * Document médical dans le DPI
 * Centralise toutes les informations du patient
 */
export type MedicalDocument = $Result.DefaultSelection<Prisma.$MedicalDocumentPayload>
/**
 * Model DocumentAttachment
 * Pièce jointe (fichier) d'un document médical
 */
export type DocumentAttachment = $Result.DefaultSelection<Prisma.$DocumentAttachmentPayload>
/**
 * Model Prescription
 * Prescription médicamenteuse (intégrée dans DPI)
 * Vérifiée par le Module C+ (Gardien Causal)
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model MedicalReport
 * Compte rendu médical
 */
export type MedicalReport = $Result.DefaultSelection<Prisma.$MedicalReportPayload>
/**
 * Model LaboratoryResult
 * Résultat d'examen de laboratoire (LIS)
 */
export type LaboratoryResult = $Result.DefaultSelection<Prisma.$LaboratoryResultPayload>
/**
 * Model MedicalImage
 * Image médicale (PACS)
 */
export type MedicalImage = $Result.DefaultSelection<Prisma.$MedicalImagePayload>
/**
 * Model FeedbackEvent
 * Correction capturée pour amélioration du modèle (Module L)
 */
export type FeedbackEvent = $Result.DefaultSelection<Prisma.$FeedbackEventPayload>
/**
 * Model Appointment
 * Rendez-vous médical
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model AppointmentReminder
 * Rappel de rendez-vous
 */
export type AppointmentReminder = $Result.DefaultSelection<Prisma.$AppointmentReminderPayload>
/**
 * Model InternalMessage
 * Message interne sécurisé
 */
export type InternalMessage = $Result.DefaultSelection<Prisma.$InternalMessagePayload>
/**
 * Model MessageThread
 * Thread de conversation (groupe)
 */
export type MessageThread = $Result.DefaultSelection<Prisma.$MessageThreadPayload>
/**
 * Model MessageAttachment
 * Pièce jointe d'un message
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model StaffMember
 * Membre du personnel
 */
export type StaffMember = $Result.DefaultSelection<Prisma.$StaffMemberPayload>
/**
 * Model Shift
 * Poste de travail / Shift
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Leave
 * Congé / Absence
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model Schedule
 * Planning hebdomadaire/mensuel
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model StockItem
 * Article en stock (pharmacie, matériel médical)
 */
export type StockItem = $Result.DefaultSelection<Prisma.$StockItemPayload>
/**
 * Model StockMovement
 * Mouvement de stock (entrée, sortie, ajustement)
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model StockAlert
 * Alerte de stock (rupture, seuil bas)
 */
export type StockAlert = $Result.DefaultSelection<Prisma.$StockAlertPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Patients
 * const patients = await prisma.patient.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Patients
   * const patients = await prisma.patient.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.semanticNode`: Exposes CRUD operations for the **SemanticNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemanticNodes
    * const semanticNodes = await prisma.semanticNode.findMany()
    * ```
    */
  get semanticNode(): Prisma.SemanticNodeDelegate<ExtArgs>;

  /**
   * `prisma.semanticRelation`: Exposes CRUD operations for the **SemanticRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemanticRelations
    * const semanticRelations = await prisma.semanticRelation.findMany()
    * ```
    */
  get semanticRelation(): Prisma.SemanticRelationDelegate<ExtArgs>;

  /**
   * `prisma.consultationDraft`: Exposes CRUD operations for the **ConsultationDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationDrafts
    * const consultationDrafts = await prisma.consultationDraft.findMany()
    * ```
    */
  get consultationDraft(): Prisma.ConsultationDraftDelegate<ExtArgs>;

  /**
   * `prisma.consultation`: Exposes CRUD operations for the **Consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultation.findMany()
    * ```
    */
  get consultation(): Prisma.ConsultationDelegate<ExtArgs>;

  /**
   * `prisma.billingEvent`: Exposes CRUD operations for the **BillingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingEvents
    * const billingEvents = await prisma.billingEvent.findMany()
    * ```
    */
  get billingEvent(): Prisma.BillingEventDelegate<ExtArgs>;

  /**
   * `prisma.allergy`: Exposes CRUD operations for the **Allergy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allergies
    * const allergies = await prisma.allergy.findMany()
    * ```
    */
  get allergy(): Prisma.AllergyDelegate<ExtArgs>;

  /**
   * `prisma.medicalDocument`: Exposes CRUD operations for the **MedicalDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalDocuments
    * const medicalDocuments = await prisma.medicalDocument.findMany()
    * ```
    */
  get medicalDocument(): Prisma.MedicalDocumentDelegate<ExtArgs>;

  /**
   * `prisma.documentAttachment`: Exposes CRUD operations for the **DocumentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAttachments
    * const documentAttachments = await prisma.documentAttachment.findMany()
    * ```
    */
  get documentAttachment(): Prisma.DocumentAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs>;

  /**
   * `prisma.medicalReport`: Exposes CRUD operations for the **MedicalReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalReports
    * const medicalReports = await prisma.medicalReport.findMany()
    * ```
    */
  get medicalReport(): Prisma.MedicalReportDelegate<ExtArgs>;

  /**
   * `prisma.laboratoryResult`: Exposes CRUD operations for the **LaboratoryResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaboratoryResults
    * const laboratoryResults = await prisma.laboratoryResult.findMany()
    * ```
    */
  get laboratoryResult(): Prisma.LaboratoryResultDelegate<ExtArgs>;

  /**
   * `prisma.medicalImage`: Exposes CRUD operations for the **MedicalImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalImages
    * const medicalImages = await prisma.medicalImage.findMany()
    * ```
    */
  get medicalImage(): Prisma.MedicalImageDelegate<ExtArgs>;

  /**
   * `prisma.feedbackEvent`: Exposes CRUD operations for the **FeedbackEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackEvents
    * const feedbackEvents = await prisma.feedbackEvent.findMany()
    * ```
    */
  get feedbackEvent(): Prisma.FeedbackEventDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.appointmentReminder`: Exposes CRUD operations for the **AppointmentReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppointmentReminders
    * const appointmentReminders = await prisma.appointmentReminder.findMany()
    * ```
    */
  get appointmentReminder(): Prisma.AppointmentReminderDelegate<ExtArgs>;

  /**
   * `prisma.internalMessage`: Exposes CRUD operations for the **InternalMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternalMessages
    * const internalMessages = await prisma.internalMessage.findMany()
    * ```
    */
  get internalMessage(): Prisma.InternalMessageDelegate<ExtArgs>;

  /**
   * `prisma.messageThread`: Exposes CRUD operations for the **MessageThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageThreads
    * const messageThreads = await prisma.messageThread.findMany()
    * ```
    */
  get messageThread(): Prisma.MessageThreadDelegate<ExtArgs>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.staffMember`: Exposes CRUD operations for the **StaffMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffMembers
    * const staffMembers = await prisma.staffMember.findMany()
    * ```
    */
  get staffMember(): Prisma.StaffMemberDelegate<ExtArgs>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs>;

  /**
   * `prisma.stockItem`: Exposes CRUD operations for the **StockItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockItems
    * const stockItems = await prisma.stockItem.findMany()
    * ```
    */
  get stockItem(): Prisma.StockItemDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.stockAlert`: Exposes CRUD operations for the **StockAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockAlerts
    * const stockAlerts = await prisma.stockAlert.findMany()
    * ```
    */
  get stockAlert(): Prisma.StockAlertDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.0
   * Query Engine version: 79fb5193cf0a8fdbef536e4b4a159cad677ab1b9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Patient: 'Patient',
    SemanticNode: 'SemanticNode',
    SemanticRelation: 'SemanticRelation',
    ConsultationDraft: 'ConsultationDraft',
    Consultation: 'Consultation',
    BillingEvent: 'BillingEvent',
    Allergy: 'Allergy',
    MedicalDocument: 'MedicalDocument',
    DocumentAttachment: 'DocumentAttachment',
    Prescription: 'Prescription',
    MedicalReport: 'MedicalReport',
    LaboratoryResult: 'LaboratoryResult',
    MedicalImage: 'MedicalImage',
    FeedbackEvent: 'FeedbackEvent',
    Appointment: 'Appointment',
    AppointmentReminder: 'AppointmentReminder',
    InternalMessage: 'InternalMessage',
    MessageThread: 'MessageThread',
    MessageAttachment: 'MessageAttachment',
    StaffMember: 'StaffMember',
    Shift: 'Shift',
    Leave: 'Leave',
    Schedule: 'Schedule',
    StockItem: 'StockItem',
    StockMovement: 'StockMovement',
    StockAlert: 'StockAlert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'patient' | 'semanticNode' | 'semanticRelation' | 'consultationDraft' | 'consultation' | 'billingEvent' | 'allergy' | 'medicalDocument' | 'documentAttachment' | 'prescription' | 'medicalReport' | 'laboratoryResult' | 'medicalImage' | 'feedbackEvent' | 'appointment' | 'appointmentReminder' | 'internalMessage' | 'messageThread' | 'messageAttachment' | 'staffMember' | 'shift' | 'leave' | 'schedule' | 'stockItem' | 'stockMovement' | 'stockAlert'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      SemanticNode: {
        payload: Prisma.$SemanticNodePayload<ExtArgs>
        fields: Prisma.SemanticNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemanticNodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemanticNodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          findFirst: {
            args: Prisma.SemanticNodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemanticNodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          findMany: {
            args: Prisma.SemanticNodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>[]
          }
          create: {
            args: Prisma.SemanticNodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          createMany: {
            args: Prisma.SemanticNodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SemanticNodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          update: {
            args: Prisma.SemanticNodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          deleteMany: {
            args: Prisma.SemanticNodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SemanticNodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SemanticNodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticNodePayload>
          }
          aggregate: {
            args: Prisma.SemanticNodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSemanticNode>
          }
          groupBy: {
            args: Prisma.SemanticNodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SemanticNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemanticNodeCountArgs<ExtArgs>,
            result: $Utils.Optional<SemanticNodeCountAggregateOutputType> | number
          }
        }
      }
      SemanticRelation: {
        payload: Prisma.$SemanticRelationPayload<ExtArgs>
        fields: Prisma.SemanticRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemanticRelationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemanticRelationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          findFirst: {
            args: Prisma.SemanticRelationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemanticRelationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          findMany: {
            args: Prisma.SemanticRelationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>[]
          }
          create: {
            args: Prisma.SemanticRelationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          createMany: {
            args: Prisma.SemanticRelationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SemanticRelationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          update: {
            args: Prisma.SemanticRelationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          deleteMany: {
            args: Prisma.SemanticRelationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SemanticRelationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SemanticRelationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemanticRelationPayload>
          }
          aggregate: {
            args: Prisma.SemanticRelationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSemanticRelation>
          }
          groupBy: {
            args: Prisma.SemanticRelationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SemanticRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemanticRelationCountArgs<ExtArgs>,
            result: $Utils.Optional<SemanticRelationCountAggregateOutputType> | number
          }
        }
      }
      ConsultationDraft: {
        payload: Prisma.$ConsultationDraftPayload<ExtArgs>
        fields: Prisma.ConsultationDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationDraftFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationDraftFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          findFirst: {
            args: Prisma.ConsultationDraftFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationDraftFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          findMany: {
            args: Prisma.ConsultationDraftFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>[]
          }
          create: {
            args: Prisma.ConsultationDraftCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          createMany: {
            args: Prisma.ConsultationDraftCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConsultationDraftDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          update: {
            args: Prisma.ConsultationDraftUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDraftDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationDraftUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationDraftUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationDraftPayload>
          }
          aggregate: {
            args: Prisma.ConsultationDraftAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConsultationDraft>
          }
          groupBy: {
            args: Prisma.ConsultationDraftGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConsultationDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationDraftCountArgs<ExtArgs>,
            result: $Utils.Optional<ConsultationDraftCountAggregateOutputType> | number
          }
        }
      }
      Consultation: {
        payload: Prisma.$ConsultationPayload<ExtArgs>
        fields: Prisma.ConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findFirst: {
            args: Prisma.ConsultationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findMany: {
            args: Prisma.ConsultationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          create: {
            args: Prisma.ConsultationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          createMany: {
            args: Prisma.ConsultationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConsultationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          update: {
            args: Prisma.ConsultationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          aggregate: {
            args: Prisma.ConsultationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConsultation>
          }
          groupBy: {
            args: Prisma.ConsultationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConsultationCountAggregateOutputType> | number
          }
        }
      }
      BillingEvent: {
        payload: Prisma.$BillingEventPayload<ExtArgs>
        fields: Prisma.BillingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          findFirst: {
            args: Prisma.BillingEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          findMany: {
            args: Prisma.BillingEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>[]
          }
          create: {
            args: Prisma.BillingEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          createMany: {
            args: Prisma.BillingEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BillingEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          update: {
            args: Prisma.BillingEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          deleteMany: {
            args: Prisma.BillingEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillingEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillingEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>
          }
          aggregate: {
            args: Prisma.BillingEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillingEvent>
          }
          groupBy: {
            args: Prisma.BillingEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingEventCountArgs<ExtArgs>,
            result: $Utils.Optional<BillingEventCountAggregateOutputType> | number
          }
        }
      }
      Allergy: {
        payload: Prisma.$AllergyPayload<ExtArgs>
        fields: Prisma.AllergyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findFirst: {
            args: Prisma.AllergyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          findMany: {
            args: Prisma.AllergyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>[]
          }
          create: {
            args: Prisma.AllergyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          createMany: {
            args: Prisma.AllergyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AllergyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          update: {
            args: Prisma.AllergyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          deleteMany: {
            args: Prisma.AllergyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AllergyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AllergyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AllergyPayload>
          }
          aggregate: {
            args: Prisma.AllergyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAllergy>
          }
          groupBy: {
            args: Prisma.AllergyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AllergyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergyCountArgs<ExtArgs>,
            result: $Utils.Optional<AllergyCountAggregateOutputType> | number
          }
        }
      }
      MedicalDocument: {
        payload: Prisma.$MedicalDocumentPayload<ExtArgs>
        fields: Prisma.MedicalDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          findFirst: {
            args: Prisma.MedicalDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          findMany: {
            args: Prisma.MedicalDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>[]
          }
          create: {
            args: Prisma.MedicalDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          createMany: {
            args: Prisma.MedicalDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MedicalDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          update: {
            args: Prisma.MedicalDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          deleteMany: {
            args: Prisma.MedicalDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MedicalDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          aggregate: {
            args: Prisma.MedicalDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMedicalDocument>
          }
          groupBy: {
            args: Prisma.MedicalDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MedicalDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<MedicalDocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentAttachment: {
        payload: Prisma.$DocumentAttachmentPayload<ExtArgs>
        fields: Prisma.DocumentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.DocumentAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findMany: {
            args: Prisma.DocumentAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          create: {
            args: Prisma.DocumentAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          createMany: {
            args: Prisma.DocumentAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          update: {
            args: Prisma.DocumentAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocumentAttachment>
          }
          groupBy: {
            args: Prisma.DocumentAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      MedicalReport: {
        payload: Prisma.$MedicalReportPayload<ExtArgs>
        fields: Prisma.MedicalReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          findFirst: {
            args: Prisma.MedicalReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          findMany: {
            args: Prisma.MedicalReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>[]
          }
          create: {
            args: Prisma.MedicalReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          createMany: {
            args: Prisma.MedicalReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MedicalReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          update: {
            args: Prisma.MedicalReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          deleteMany: {
            args: Prisma.MedicalReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MedicalReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalReportPayload>
          }
          aggregate: {
            args: Prisma.MedicalReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMedicalReport>
          }
          groupBy: {
            args: Prisma.MedicalReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MedicalReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalReportCountArgs<ExtArgs>,
            result: $Utils.Optional<MedicalReportCountAggregateOutputType> | number
          }
        }
      }
      LaboratoryResult: {
        payload: Prisma.$LaboratoryResultPayload<ExtArgs>
        fields: Prisma.LaboratoryResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaboratoryResultFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaboratoryResultFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          findFirst: {
            args: Prisma.LaboratoryResultFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaboratoryResultFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          findMany: {
            args: Prisma.LaboratoryResultFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>[]
          }
          create: {
            args: Prisma.LaboratoryResultCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          createMany: {
            args: Prisma.LaboratoryResultCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LaboratoryResultDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          update: {
            args: Prisma.LaboratoryResultUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          deleteMany: {
            args: Prisma.LaboratoryResultDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LaboratoryResultUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LaboratoryResultUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LaboratoryResultPayload>
          }
          aggregate: {
            args: Prisma.LaboratoryResultAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLaboratoryResult>
          }
          groupBy: {
            args: Prisma.LaboratoryResultGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LaboratoryResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaboratoryResultCountArgs<ExtArgs>,
            result: $Utils.Optional<LaboratoryResultCountAggregateOutputType> | number
          }
        }
      }
      MedicalImage: {
        payload: Prisma.$MedicalImagePayload<ExtArgs>
        fields: Prisma.MedicalImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalImageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalImageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          findFirst: {
            args: Prisma.MedicalImageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalImageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          findMany: {
            args: Prisma.MedicalImageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>[]
          }
          create: {
            args: Prisma.MedicalImageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          createMany: {
            args: Prisma.MedicalImageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MedicalImageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          update: {
            args: Prisma.MedicalImageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          deleteMany: {
            args: Prisma.MedicalImageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalImageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MedicalImageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MedicalImagePayload>
          }
          aggregate: {
            args: Prisma.MedicalImageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMedicalImage>
          }
          groupBy: {
            args: Prisma.MedicalImageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MedicalImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalImageCountArgs<ExtArgs>,
            result: $Utils.Optional<MedicalImageCountAggregateOutputType> | number
          }
        }
      }
      FeedbackEvent: {
        payload: Prisma.$FeedbackEventPayload<ExtArgs>
        fields: Prisma.FeedbackEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          findFirst: {
            args: Prisma.FeedbackEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          findMany: {
            args: Prisma.FeedbackEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>[]
          }
          create: {
            args: Prisma.FeedbackEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          createMany: {
            args: Prisma.FeedbackEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          update: {
            args: Prisma.FeedbackEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackEventPayload>
          }
          aggregate: {
            args: Prisma.FeedbackEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedbackEvent>
          }
          groupBy: {
            args: Prisma.FeedbackEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackEventCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackEventCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      AppointmentReminder: {
        payload: Prisma.$AppointmentReminderPayload<ExtArgs>
        fields: Prisma.AppointmentReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentReminderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentReminderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          findFirst: {
            args: Prisma.AppointmentReminderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentReminderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          findMany: {
            args: Prisma.AppointmentReminderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>[]
          }
          create: {
            args: Prisma.AppointmentReminderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          createMany: {
            args: Prisma.AppointmentReminderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppointmentReminderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          update: {
            args: Prisma.AppointmentReminderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentReminderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentReminderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentReminderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentReminderPayload>
          }
          aggregate: {
            args: Prisma.AppointmentReminderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointmentReminder>
          }
          groupBy: {
            args: Prisma.AppointmentReminderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentReminderCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentReminderCountAggregateOutputType> | number
          }
        }
      }
      InternalMessage: {
        payload: Prisma.$InternalMessagePayload<ExtArgs>
        fields: Prisma.InternalMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternalMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternalMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          findFirst: {
            args: Prisma.InternalMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternalMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          findMany: {
            args: Prisma.InternalMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>[]
          }
          create: {
            args: Prisma.InternalMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          createMany: {
            args: Prisma.InternalMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InternalMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          update: {
            args: Prisma.InternalMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          deleteMany: {
            args: Prisma.InternalMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InternalMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InternalMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InternalMessagePayload>
          }
          aggregate: {
            args: Prisma.InternalMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInternalMessage>
          }
          groupBy: {
            args: Prisma.InternalMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InternalMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternalMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<InternalMessageCountAggregateOutputType> | number
          }
        }
      }
      MessageThread: {
        payload: Prisma.$MessageThreadPayload<ExtArgs>
        fields: Prisma.MessageThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageThreadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageThreadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findFirst: {
            args: Prisma.MessageThreadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageThreadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findMany: {
            args: Prisma.MessageThreadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          create: {
            args: Prisma.MessageThreadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          createMany: {
            args: Prisma.MessageThreadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageThreadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          update: {
            args: Prisma.MessageThreadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          deleteMany: {
            args: Prisma.MessageThreadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageThreadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageThreadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          aggregate: {
            args: Prisma.MessageThreadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessageThread>
          }
          groupBy: {
            args: Prisma.MessageThreadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageThreadCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageThreadCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      StaffMember: {
        payload: Prisma.$StaffMemberPayload<ExtArgs>
        fields: Prisma.StaffMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          findFirst: {
            args: Prisma.StaffMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          findMany: {
            args: Prisma.StaffMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>[]
          }
          create: {
            args: Prisma.StaffMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          createMany: {
            args: Prisma.StaffMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          update: {
            args: Prisma.StaffMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          deleteMany: {
            args: Prisma.StaffMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StaffMemberPayload>
          }
          aggregate: {
            args: Prisma.StaffMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaffMember>
          }
          groupBy: {
            args: Prisma.StaffMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffMemberCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>,
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>,
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      StockItem: {
        payload: Prisma.$StockItemPayload<ExtArgs>
        fields: Prisma.StockItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findFirst: {
            args: Prisma.StockItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findMany: {
            args: Prisma.StockItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          create: {
            args: Prisma.StockItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          createMany: {
            args: Prisma.StockItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          update: {
            args: Prisma.StockItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          deleteMany: {
            args: Prisma.StockItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          aggregate: {
            args: Prisma.StockItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockItem>
          }
          groupBy: {
            args: Prisma.StockItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockItemCountArgs<ExtArgs>,
            result: $Utils.Optional<StockItemCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>,
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      StockAlert: {
        payload: Prisma.$StockAlertPayload<ExtArgs>
        fields: Prisma.StockAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockAlertFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockAlertFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          findFirst: {
            args: Prisma.StockAlertFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockAlertFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          findMany: {
            args: Prisma.StockAlertFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>[]
          }
          create: {
            args: Prisma.StockAlertCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          createMany: {
            args: Prisma.StockAlertCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockAlertDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          update: {
            args: Prisma.StockAlertUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          deleteMany: {
            args: Prisma.StockAlertDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockAlertUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockAlertUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockAlertPayload>
          }
          aggregate: {
            args: Prisma.StockAlertAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockAlert>
          }
          groupBy: {
            args: Prisma.StockAlertGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockAlertCountArgs<ExtArgs>,
            result: $Utils.Optional<StockAlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    consultations: number
    semanticNodes: number
    medicalDocuments: number
    prescriptions: number
    medicalReports: number
    laboratoryResults: number
    medicalImages: number
    appointments: number
    allergies: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | PatientCountOutputTypeCountConsultationsArgs
    semanticNodes?: boolean | PatientCountOutputTypeCountSemanticNodesArgs
    medicalDocuments?: boolean | PatientCountOutputTypeCountMedicalDocumentsArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    medicalReports?: boolean | PatientCountOutputTypeCountMedicalReportsArgs
    laboratoryResults?: boolean | PatientCountOutputTypeCountLaboratoryResultsArgs
    medicalImages?: boolean | PatientCountOutputTypeCountMedicalImagesArgs
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    allergies?: boolean | PatientCountOutputTypeCountAllergiesArgs
  }

  // Custom InputTypes

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountSemanticNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticNodeWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalDocumentWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalReportWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLaboratoryResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaboratoryResultWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalImageWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
  }



  /**
   * Count Type SemanticNodeCountOutputType
   */

  export type SemanticNodeCountOutputType = {
    sourceRelations: number
    targetRelations: number
  }

  export type SemanticNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceRelations?: boolean | SemanticNodeCountOutputTypeCountSourceRelationsArgs
    targetRelations?: boolean | SemanticNodeCountOutputTypeCountTargetRelationsArgs
  }

  // Custom InputTypes

  /**
   * SemanticNodeCountOutputType without action
   */
  export type SemanticNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNodeCountOutputType
     */
    select?: SemanticNodeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SemanticNodeCountOutputType without action
   */
  export type SemanticNodeCountOutputTypeCountSourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticRelationWhereInput
  }


  /**
   * SemanticNodeCountOutputType without action
   */
  export type SemanticNodeCountOutputTypeCountTargetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticRelationWhereInput
  }



  /**
   * Count Type ConsultationCountOutputType
   */

  export type ConsultationCountOutputType = {
    semanticNodes: number
    medicalDocuments: number
    medicalReports: number
    billingEvents: number
  }

  export type ConsultationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semanticNodes?: boolean | ConsultationCountOutputTypeCountSemanticNodesArgs
    medicalDocuments?: boolean | ConsultationCountOutputTypeCountMedicalDocumentsArgs
    medicalReports?: boolean | ConsultationCountOutputTypeCountMedicalReportsArgs
    billingEvents?: boolean | ConsultationCountOutputTypeCountBillingEventsArgs
  }

  // Custom InputTypes

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationCountOutputType
     */
    select?: ConsultationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountSemanticNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticNodeWhereInput
  }


  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountMedicalDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalDocumentWhereInput
  }


  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountMedicalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalReportWhereInput
  }


  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountBillingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingEventWhereInput
  }



  /**
   * Count Type MedicalDocumentCountOutputType
   */

  export type MedicalDocumentCountOutputType = {
    attachments: number
  }

  export type MedicalDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MedicalDocumentCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes

  /**
   * MedicalDocumentCountOutputType without action
   */
  export type MedicalDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocumentCountOutputType
     */
    select?: MedicalDocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MedicalDocumentCountOutputType without action
   */
  export type MedicalDocumentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
  }



  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    reminders: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reminders?: boolean | AppointmentCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentReminderWhereInput
  }



  /**
   * Count Type InternalMessageCountOutputType
   */

  export type InternalMessageCountOutputType = {
    attachments: number
  }

  export type InternalMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | InternalMessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes

  /**
   * InternalMessageCountOutputType without action
   */
  export type InternalMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessageCountOutputType
     */
    select?: InternalMessageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InternalMessageCountOutputType without action
   */
  export type InternalMessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }



  /**
   * Count Type MessageThreadCountOutputType
   */

  export type MessageThreadCountOutputType = {
    messages: number
  }

  export type MessageThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageThreadCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadCountOutputType
     */
    select?: MessageThreadCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalMessageWhereInput
  }



  /**
   * Count Type StaffMemberCountOutputType
   */

  export type StaffMemberCountOutputType = {
    shifts: number
    leaves: number
    schedules: number
  }

  export type StaffMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | StaffMemberCountOutputTypeCountShiftsArgs
    leaves?: boolean | StaffMemberCountOutputTypeCountLeavesArgs
    schedules?: boolean | StaffMemberCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes

  /**
   * StaffMemberCountOutputType without action
   */
  export type StaffMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMemberCountOutputType
     */
    select?: StaffMemberCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StaffMemberCountOutputType without action
   */
  export type StaffMemberCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }


  /**
   * StaffMemberCountOutputType without action
   */
  export type StaffMemberCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }


  /**
   * StaffMemberCountOutputType without action
   */
  export type StaffMemberCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }



  /**
   * Count Type StockItemCountOutputType
   */

  export type StockItemCountOutputType = {
    movements: number
    alerts: number
  }

  export type StockItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | StockItemCountOutputTypeCountMovementsArgs
    alerts?: boolean | StockItemCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes

  /**
   * StockItemCountOutputType without action
   */
  export type StockItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItemCountOutputType
     */
    select?: StockItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StockItemCountOutputType without action
   */
  export type StockItemCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * StockItemCountOutputType without action
   */
  export type StockItemCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAlertWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    insToken: string | null
    insHash: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    birthPlace: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    insToken: string | null
    insHash: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    birthPlace: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    insToken: number
    insHash: number
    firstName: number
    lastName: number
    birthDate: number
    birthPlace: number
    email: number
    phone: number
    addressLine1: number
    addressLine2: number
    city: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    insToken?: true
    insHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    insToken?: true
    insHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    insToken?: true
    insHash?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date
    birthPlace: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postalCode: string | null
    country: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insToken?: boolean
    insHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    semanticNodes?: boolean | Patient$semanticNodesArgs<ExtArgs>
    medicalDocuments?: boolean | Patient$medicalDocumentsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    medicalReports?: boolean | Patient$medicalReportsArgs<ExtArgs>
    laboratoryResults?: boolean | Patient$laboratoryResultsArgs<ExtArgs>
    medicalImages?: boolean | Patient$medicalImagesArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    insToken?: boolean
    insHash?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    semanticNodes?: boolean | Patient$semanticNodesArgs<ExtArgs>
    medicalDocuments?: boolean | Patient$medicalDocumentsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    medicalReports?: boolean | Patient$medicalReportsArgs<ExtArgs>
    laboratoryResults?: boolean | Patient$laboratoryResultsArgs<ExtArgs>
    medicalImages?: boolean | Patient$medicalImagesArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      semanticNodes: Prisma.$SemanticNodePayload<ExtArgs>[]
      medicalDocuments: Prisma.$MedicalDocumentPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      medicalReports: Prisma.$MedicalReportPayload<ExtArgs>[]
      laboratoryResults: Prisma.$LaboratoryResultPayload<ExtArgs>[]
      medicalImages: Prisma.$MedicalImagePayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      allergies: Prisma.$AllergyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insToken: string
      insHash: string
      firstName: string
      lastName: string
      birthDate: Date
      birthPlace: string | null
      email: string | null
      phone: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      postalCode: string | null
      country: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Patients.
     *     @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     *     @example
     *     // Create many Patients
     *     const patient = await prisma.patient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    consultations<T extends Patient$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findMany'> | Null>;

    semanticNodes<T extends Patient$semanticNodesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$semanticNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findMany'> | Null>;

    medicalDocuments<T extends Patient$medicalDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    medicalReports<T extends Patient$medicalReportsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    laboratoryResults<T extends Patient$laboratoryResultsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$laboratoryResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findMany'> | Null>;

    medicalImages<T extends Patient$medicalImagesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findMany'> | Null>;

    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    allergies<T extends Patient$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly insToken: FieldRef<"Patient", 'String'>
    readonly insHash: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly birthPlace: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly addressLine1: FieldRef<"Patient", 'String'>
    readonly addressLine2: FieldRef<"Patient", 'String'>
    readonly city: FieldRef<"Patient", 'String'>
    readonly postalCode: FieldRef<"Patient", 'String'>
    readonly country: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly createdBy: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }


  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }


  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }


  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }


  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }


  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }


  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }


  /**
   * Patient.consultations
   */
  export type Patient$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }


  /**
   * Patient.semanticNodes
   */
  export type Patient$semanticNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    where?: SemanticNodeWhereInput
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    cursor?: SemanticNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemanticNodeScalarFieldEnum | SemanticNodeScalarFieldEnum[]
  }


  /**
   * Patient.medicalDocuments
   */
  export type Patient$medicalDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    cursor?: MedicalDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }


  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }


  /**
   * Patient.medicalReports
   */
  export type Patient$medicalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    where?: MedicalReportWhereInput
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    cursor?: MedicalReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalReportScalarFieldEnum | MedicalReportScalarFieldEnum[]
  }


  /**
   * Patient.laboratoryResults
   */
  export type Patient$laboratoryResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    where?: LaboratoryResultWhereInput
    orderBy?: LaboratoryResultOrderByWithRelationInput | LaboratoryResultOrderByWithRelationInput[]
    cursor?: LaboratoryResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaboratoryResultScalarFieldEnum | LaboratoryResultScalarFieldEnum[]
  }


  /**
   * Patient.medicalImages
   */
  export type Patient$medicalImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    where?: MedicalImageWhereInput
    orderBy?: MedicalImageOrderByWithRelationInput | MedicalImageOrderByWithRelationInput[]
    cursor?: MedicalImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalImageScalarFieldEnum | MedicalImageScalarFieldEnum[]
  }


  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * Patient.allergies
   */
  export type Patient$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    cursor?: AllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }


  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
  }



  /**
   * Model SemanticNode
   */

  export type AggregateSemanticNode = {
    _count: SemanticNodeCountAggregateOutputType | null
    _avg: SemanticNodeAvgAggregateOutputType | null
    _sum: SemanticNodeSumAggregateOutputType | null
    _min: SemanticNodeMinAggregateOutputType | null
    _max: SemanticNodeMaxAggregateOutputType | null
  }

  export type SemanticNodeAvgAggregateOutputType = {
    confidence: number | null
  }

  export type SemanticNodeSumAggregateOutputType = {
    confidence: number | null
  }

  export type SemanticNodeMinAggregateOutputType = {
    id: string | null
    nodeType: string | null
    snomedCtCode: string | null
    cim10Code: string | null
    cim11Code: string | null
    label: string | null
    description: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confidence: number | null
    patientId: string | null
    consultationId: string | null
  }

  export type SemanticNodeMaxAggregateOutputType = {
    id: string | null
    nodeType: string | null
    snomedCtCode: string | null
    cim10Code: string | null
    cim11Code: string | null
    label: string | null
    description: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confidence: number | null
    patientId: string | null
    consultationId: string | null
  }

  export type SemanticNodeCountAggregateOutputType = {
    id: number
    nodeType: number
    snomedCtCode: number
    cim10Code: number
    cim11Code: number
    label: number
    description: number
    embedding: number
    value: number
    unit: number
    createdAt: number
    updatedAt: number
    confidence: number
    patientId: number
    consultationId: number
    _all: number
  }


  export type SemanticNodeAvgAggregateInputType = {
    confidence?: true
  }

  export type SemanticNodeSumAggregateInputType = {
    confidence?: true
  }

  export type SemanticNodeMinAggregateInputType = {
    id?: true
    nodeType?: true
    snomedCtCode?: true
    cim10Code?: true
    cim11Code?: true
    label?: true
    description?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    confidence?: true
    patientId?: true
    consultationId?: true
  }

  export type SemanticNodeMaxAggregateInputType = {
    id?: true
    nodeType?: true
    snomedCtCode?: true
    cim10Code?: true
    cim11Code?: true
    label?: true
    description?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    confidence?: true
    patientId?: true
    consultationId?: true
  }

  export type SemanticNodeCountAggregateInputType = {
    id?: true
    nodeType?: true
    snomedCtCode?: true
    cim10Code?: true
    cim11Code?: true
    label?: true
    description?: true
    embedding?: true
    value?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    confidence?: true
    patientId?: true
    consultationId?: true
    _all?: true
  }

  export type SemanticNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticNode to aggregate.
     */
    where?: SemanticNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticNodes to fetch.
     */
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemanticNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemanticNodes
    **/
    _count?: true | SemanticNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemanticNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemanticNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemanticNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemanticNodeMaxAggregateInputType
  }

  export type GetSemanticNodeAggregateType<T extends SemanticNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateSemanticNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemanticNode[P]>
      : GetScalarType<T[P], AggregateSemanticNode[P]>
  }




  export type SemanticNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticNodeWhereInput
    orderBy?: SemanticNodeOrderByWithAggregationInput | SemanticNodeOrderByWithAggregationInput[]
    by: SemanticNodeScalarFieldEnum[] | SemanticNodeScalarFieldEnum
    having?: SemanticNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemanticNodeCountAggregateInputType | true
    _avg?: SemanticNodeAvgAggregateInputType
    _sum?: SemanticNodeSumAggregateInputType
    _min?: SemanticNodeMinAggregateInputType
    _max?: SemanticNodeMaxAggregateInputType
  }

  export type SemanticNodeGroupByOutputType = {
    id: string
    nodeType: string
    snomedCtCode: string | null
    cim10Code: string | null
    cim11Code: string | null
    label: string
    description: string | null
    embedding: JsonValue | null
    value: JsonValue | null
    unit: string | null
    createdAt: Date
    updatedAt: Date
    confidence: number | null
    patientId: string | null
    consultationId: string | null
    _count: SemanticNodeCountAggregateOutputType | null
    _avg: SemanticNodeAvgAggregateOutputType | null
    _sum: SemanticNodeSumAggregateOutputType | null
    _min: SemanticNodeMinAggregateOutputType | null
    _max: SemanticNodeMaxAggregateOutputType | null
  }

  type GetSemanticNodeGroupByPayload<T extends SemanticNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemanticNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemanticNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemanticNodeGroupByOutputType[P]>
            : GetScalarType<T[P], SemanticNodeGroupByOutputType[P]>
        }
      >
    >


  export type SemanticNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeType?: boolean
    snomedCtCode?: boolean
    cim10Code?: boolean
    cim11Code?: boolean
    label?: boolean
    description?: boolean
    embedding?: boolean
    value?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confidence?: boolean
    patientId?: boolean
    consultationId?: boolean
    patient?: boolean | SemanticNode$patientArgs<ExtArgs>
    sourceRelations?: boolean | SemanticNode$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | SemanticNode$targetRelationsArgs<ExtArgs>
    consultation?: boolean | SemanticNode$consultationArgs<ExtArgs>
    _count?: boolean | SemanticNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semanticNode"]>

  export type SemanticNodeSelectScalar = {
    id?: boolean
    nodeType?: boolean
    snomedCtCode?: boolean
    cim10Code?: boolean
    cim11Code?: boolean
    label?: boolean
    description?: boolean
    embedding?: boolean
    value?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confidence?: boolean
    patientId?: boolean
    consultationId?: boolean
  }

  export type SemanticNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | SemanticNode$patientArgs<ExtArgs>
    sourceRelations?: boolean | SemanticNode$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | SemanticNode$targetRelationsArgs<ExtArgs>
    consultation?: boolean | SemanticNode$consultationArgs<ExtArgs>
    _count?: boolean | SemanticNodeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SemanticNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SemanticNode"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      sourceRelations: Prisma.$SemanticRelationPayload<ExtArgs>[]
      targetRelations: Prisma.$SemanticRelationPayload<ExtArgs>[]
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeType: string
      snomedCtCode: string | null
      cim10Code: string | null
      cim11Code: string | null
      label: string
      description: string | null
      embedding: Prisma.JsonValue | null
      value: Prisma.JsonValue | null
      unit: string | null
      createdAt: Date
      updatedAt: Date
      confidence: number | null
      patientId: string | null
      consultationId: string | null
    }, ExtArgs["result"]["semanticNode"]>
    composites: {}
  }


  type SemanticNodeGetPayload<S extends boolean | null | undefined | SemanticNodeDefaultArgs> = $Result.GetResult<Prisma.$SemanticNodePayload, S>

  type SemanticNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SemanticNodeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SemanticNodeCountAggregateInputType | true
    }

  export interface SemanticNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemanticNode'], meta: { name: 'SemanticNode' } }
    /**
     * Find zero or one SemanticNode that matches the filter.
     * @param {SemanticNodeFindUniqueArgs} args - Arguments to find a SemanticNode
     * @example
     * // Get one SemanticNode
     * const semanticNode = await prisma.semanticNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SemanticNodeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeFindUniqueArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SemanticNode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SemanticNodeFindUniqueOrThrowArgs} args - Arguments to find a SemanticNode
     * @example
     * // Get one SemanticNode
     * const semanticNode = await prisma.semanticNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SemanticNodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SemanticNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeFindFirstArgs} args - Arguments to find a SemanticNode
     * @example
     * // Get one SemanticNode
     * const semanticNode = await prisma.semanticNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SemanticNodeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeFindFirstArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SemanticNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeFindFirstOrThrowArgs} args - Arguments to find a SemanticNode
     * @example
     * // Get one SemanticNode
     * const semanticNode = await prisma.semanticNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SemanticNodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SemanticNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemanticNodes
     * const semanticNodes = await prisma.semanticNode.findMany()
     * 
     * // Get first 10 SemanticNodes
     * const semanticNodes = await prisma.semanticNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semanticNodeWithIdOnly = await prisma.semanticNode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SemanticNodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SemanticNode.
     * @param {SemanticNodeCreateArgs} args - Arguments to create a SemanticNode.
     * @example
     * // Create one SemanticNode
     * const SemanticNode = await prisma.semanticNode.create({
     *   data: {
     *     // ... data to create a SemanticNode
     *   }
     * })
     * 
    **/
    create<T extends SemanticNodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeCreateArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SemanticNodes.
     *     @param {SemanticNodeCreateManyArgs} args - Arguments to create many SemanticNodes.
     *     @example
     *     // Create many SemanticNodes
     *     const semanticNode = await prisma.semanticNode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SemanticNodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SemanticNode.
     * @param {SemanticNodeDeleteArgs} args - Arguments to delete one SemanticNode.
     * @example
     * // Delete one SemanticNode
     * const SemanticNode = await prisma.semanticNode.delete({
     *   where: {
     *     // ... filter to delete one SemanticNode
     *   }
     * })
     * 
    **/
    delete<T extends SemanticNodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeDeleteArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SemanticNode.
     * @param {SemanticNodeUpdateArgs} args - Arguments to update one SemanticNode.
     * @example
     * // Update one SemanticNode
     * const semanticNode = await prisma.semanticNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SemanticNodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeUpdateArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SemanticNodes.
     * @param {SemanticNodeDeleteManyArgs} args - Arguments to filter SemanticNodes to delete.
     * @example
     * // Delete a few SemanticNodes
     * const { count } = await prisma.semanticNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SemanticNodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticNodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemanticNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemanticNodes
     * const semanticNode = await prisma.semanticNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SemanticNodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemanticNode.
     * @param {SemanticNodeUpsertArgs} args - Arguments to update or create a SemanticNode.
     * @example
     * // Update or create a SemanticNode
     * const semanticNode = await prisma.semanticNode.upsert({
     *   create: {
     *     // ... data to create a SemanticNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemanticNode we want to update
     *   }
     * })
    **/
    upsert<T extends SemanticNodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticNodeUpsertArgs<ExtArgs>>
    ): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SemanticNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeCountArgs} args - Arguments to filter SemanticNodes to count.
     * @example
     * // Count the number of SemanticNodes
     * const count = await prisma.semanticNode.count({
     *   where: {
     *     // ... the filter for the SemanticNodes we want to count
     *   }
     * })
    **/
    count<T extends SemanticNodeCountArgs>(
      args?: Subset<T, SemanticNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemanticNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemanticNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemanticNodeAggregateArgs>(args: Subset<T, SemanticNodeAggregateArgs>): Prisma.PrismaPromise<GetSemanticNodeAggregateType<T>>

    /**
     * Group by SemanticNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemanticNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemanticNodeGroupByArgs['orderBy'] }
        : { orderBy?: SemanticNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemanticNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemanticNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemanticNode model
   */
  readonly fields: SemanticNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemanticNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemanticNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends SemanticNode$patientArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNode$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    sourceRelations<T extends SemanticNode$sourceRelationsArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNode$sourceRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    targetRelations<T extends SemanticNode$targetRelationsArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNode$targetRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    consultation<T extends SemanticNode$consultationArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNode$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SemanticNode model
   */ 
  interface SemanticNodeFieldRefs {
    readonly id: FieldRef<"SemanticNode", 'String'>
    readonly nodeType: FieldRef<"SemanticNode", 'String'>
    readonly snomedCtCode: FieldRef<"SemanticNode", 'String'>
    readonly cim10Code: FieldRef<"SemanticNode", 'String'>
    readonly cim11Code: FieldRef<"SemanticNode", 'String'>
    readonly label: FieldRef<"SemanticNode", 'String'>
    readonly description: FieldRef<"SemanticNode", 'String'>
    readonly embedding: FieldRef<"SemanticNode", 'Json'>
    readonly value: FieldRef<"SemanticNode", 'Json'>
    readonly unit: FieldRef<"SemanticNode", 'String'>
    readonly createdAt: FieldRef<"SemanticNode", 'DateTime'>
    readonly updatedAt: FieldRef<"SemanticNode", 'DateTime'>
    readonly confidence: FieldRef<"SemanticNode", 'Float'>
    readonly patientId: FieldRef<"SemanticNode", 'String'>
    readonly consultationId: FieldRef<"SemanticNode", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SemanticNode findUnique
   */
  export type SemanticNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter, which SemanticNode to fetch.
     */
    where: SemanticNodeWhereUniqueInput
  }


  /**
   * SemanticNode findUniqueOrThrow
   */
  export type SemanticNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter, which SemanticNode to fetch.
     */
    where: SemanticNodeWhereUniqueInput
  }


  /**
   * SemanticNode findFirst
   */
  export type SemanticNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter, which SemanticNode to fetch.
     */
    where?: SemanticNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticNodes to fetch.
     */
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticNodes.
     */
    cursor?: SemanticNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticNodes.
     */
    distinct?: SemanticNodeScalarFieldEnum | SemanticNodeScalarFieldEnum[]
  }


  /**
   * SemanticNode findFirstOrThrow
   */
  export type SemanticNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter, which SemanticNode to fetch.
     */
    where?: SemanticNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticNodes to fetch.
     */
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticNodes.
     */
    cursor?: SemanticNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticNodes.
     */
    distinct?: SemanticNodeScalarFieldEnum | SemanticNodeScalarFieldEnum[]
  }


  /**
   * SemanticNode findMany
   */
  export type SemanticNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter, which SemanticNodes to fetch.
     */
    where?: SemanticNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticNodes to fetch.
     */
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemanticNodes.
     */
    cursor?: SemanticNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticNodes.
     */
    skip?: number
    distinct?: SemanticNodeScalarFieldEnum | SemanticNodeScalarFieldEnum[]
  }


  /**
   * SemanticNode create
   */
  export type SemanticNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a SemanticNode.
     */
    data: XOR<SemanticNodeCreateInput, SemanticNodeUncheckedCreateInput>
  }


  /**
   * SemanticNode createMany
   */
  export type SemanticNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemanticNodes.
     */
    data: SemanticNodeCreateManyInput | SemanticNodeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SemanticNode update
   */
  export type SemanticNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a SemanticNode.
     */
    data: XOR<SemanticNodeUpdateInput, SemanticNodeUncheckedUpdateInput>
    /**
     * Choose, which SemanticNode to update.
     */
    where: SemanticNodeWhereUniqueInput
  }


  /**
   * SemanticNode updateMany
   */
  export type SemanticNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemanticNodes.
     */
    data: XOR<SemanticNodeUpdateManyMutationInput, SemanticNodeUncheckedUpdateManyInput>
    /**
     * Filter which SemanticNodes to update
     */
    where?: SemanticNodeWhereInput
  }


  /**
   * SemanticNode upsert
   */
  export type SemanticNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the SemanticNode to update in case it exists.
     */
    where: SemanticNodeWhereUniqueInput
    /**
     * In case the SemanticNode found by the `where` argument doesn't exist, create a new SemanticNode with this data.
     */
    create: XOR<SemanticNodeCreateInput, SemanticNodeUncheckedCreateInput>
    /**
     * In case the SemanticNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemanticNodeUpdateInput, SemanticNodeUncheckedUpdateInput>
  }


  /**
   * SemanticNode delete
   */
  export type SemanticNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    /**
     * Filter which SemanticNode to delete.
     */
    where: SemanticNodeWhereUniqueInput
  }


  /**
   * SemanticNode deleteMany
   */
  export type SemanticNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticNodes to delete
     */
    where?: SemanticNodeWhereInput
  }


  /**
   * SemanticNode.patient
   */
  export type SemanticNode$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }


  /**
   * SemanticNode.sourceRelations
   */
  export type SemanticNode$sourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    where?: SemanticRelationWhereInput
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    cursor?: SemanticRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemanticRelationScalarFieldEnum | SemanticRelationScalarFieldEnum[]
  }


  /**
   * SemanticNode.targetRelations
   */
  export type SemanticNode$targetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    where?: SemanticRelationWhereInput
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    cursor?: SemanticRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemanticRelationScalarFieldEnum | SemanticRelationScalarFieldEnum[]
  }


  /**
   * SemanticNode.consultation
   */
  export type SemanticNode$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }


  /**
   * SemanticNode without action
   */
  export type SemanticNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
  }



  /**
   * Model SemanticRelation
   */

  export type AggregateSemanticRelation = {
    _count: SemanticRelationCountAggregateOutputType | null
    _avg: SemanticRelationAvgAggregateOutputType | null
    _sum: SemanticRelationSumAggregateOutputType | null
    _min: SemanticRelationMinAggregateOutputType | null
    _max: SemanticRelationMaxAggregateOutputType | null
  }

  export type SemanticRelationAvgAggregateOutputType = {
    strength: number | null
    confidence: number | null
  }

  export type SemanticRelationSumAggregateOutputType = {
    strength: number | null
    confidence: number | null
  }

  export type SemanticRelationMinAggregateOutputType = {
    id: string | null
    sourceNodeId: string | null
    targetNodeId: string | null
    relationType: string | null
    strength: number | null
    evidence: string | null
    createdAt: Date | null
    confidence: number | null
  }

  export type SemanticRelationMaxAggregateOutputType = {
    id: string | null
    sourceNodeId: string | null
    targetNodeId: string | null
    relationType: string | null
    strength: number | null
    evidence: string | null
    createdAt: Date | null
    confidence: number | null
  }

  export type SemanticRelationCountAggregateOutputType = {
    id: number
    sourceNodeId: number
    targetNodeId: number
    relationType: number
    strength: number
    evidence: number
    createdAt: number
    confidence: number
    _all: number
  }


  export type SemanticRelationAvgAggregateInputType = {
    strength?: true
    confidence?: true
  }

  export type SemanticRelationSumAggregateInputType = {
    strength?: true
    confidence?: true
  }

  export type SemanticRelationMinAggregateInputType = {
    id?: true
    sourceNodeId?: true
    targetNodeId?: true
    relationType?: true
    strength?: true
    evidence?: true
    createdAt?: true
    confidence?: true
  }

  export type SemanticRelationMaxAggregateInputType = {
    id?: true
    sourceNodeId?: true
    targetNodeId?: true
    relationType?: true
    strength?: true
    evidence?: true
    createdAt?: true
    confidence?: true
  }

  export type SemanticRelationCountAggregateInputType = {
    id?: true
    sourceNodeId?: true
    targetNodeId?: true
    relationType?: true
    strength?: true
    evidence?: true
    createdAt?: true
    confidence?: true
    _all?: true
  }

  export type SemanticRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticRelation to aggregate.
     */
    where?: SemanticRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticRelations to fetch.
     */
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemanticRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemanticRelations
    **/
    _count?: true | SemanticRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemanticRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemanticRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemanticRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemanticRelationMaxAggregateInputType
  }

  export type GetSemanticRelationAggregateType<T extends SemanticRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateSemanticRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemanticRelation[P]>
      : GetScalarType<T[P], AggregateSemanticRelation[P]>
  }




  export type SemanticRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemanticRelationWhereInput
    orderBy?: SemanticRelationOrderByWithAggregationInput | SemanticRelationOrderByWithAggregationInput[]
    by: SemanticRelationScalarFieldEnum[] | SemanticRelationScalarFieldEnum
    having?: SemanticRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemanticRelationCountAggregateInputType | true
    _avg?: SemanticRelationAvgAggregateInputType
    _sum?: SemanticRelationSumAggregateInputType
    _min?: SemanticRelationMinAggregateInputType
    _max?: SemanticRelationMaxAggregateInputType
  }

  export type SemanticRelationGroupByOutputType = {
    id: string
    sourceNodeId: string
    targetNodeId: string
    relationType: string
    strength: number | null
    evidence: string | null
    createdAt: Date
    confidence: number | null
    _count: SemanticRelationCountAggregateOutputType | null
    _avg: SemanticRelationAvgAggregateOutputType | null
    _sum: SemanticRelationSumAggregateOutputType | null
    _min: SemanticRelationMinAggregateOutputType | null
    _max: SemanticRelationMaxAggregateOutputType | null
  }

  type GetSemanticRelationGroupByPayload<T extends SemanticRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemanticRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemanticRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemanticRelationGroupByOutputType[P]>
            : GetScalarType<T[P], SemanticRelationGroupByOutputType[P]>
        }
      >
    >


  export type SemanticRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    relationType?: boolean
    strength?: boolean
    evidence?: boolean
    createdAt?: boolean
    confidence?: boolean
    sourceNode?: boolean | SemanticNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | SemanticNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semanticRelation"]>

  export type SemanticRelationSelectScalar = {
    id?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    relationType?: boolean
    strength?: boolean
    evidence?: boolean
    createdAt?: boolean
    confidence?: boolean
  }

  export type SemanticRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceNode?: boolean | SemanticNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | SemanticNodeDefaultArgs<ExtArgs>
  }


  export type $SemanticRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SemanticRelation"
    objects: {
      sourceNode: Prisma.$SemanticNodePayload<ExtArgs>
      targetNode: Prisma.$SemanticNodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceNodeId: string
      targetNodeId: string
      relationType: string
      strength: number | null
      evidence: string | null
      createdAt: Date
      confidence: number | null
    }, ExtArgs["result"]["semanticRelation"]>
    composites: {}
  }


  type SemanticRelationGetPayload<S extends boolean | null | undefined | SemanticRelationDefaultArgs> = $Result.GetResult<Prisma.$SemanticRelationPayload, S>

  type SemanticRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SemanticRelationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SemanticRelationCountAggregateInputType | true
    }

  export interface SemanticRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemanticRelation'], meta: { name: 'SemanticRelation' } }
    /**
     * Find zero or one SemanticRelation that matches the filter.
     * @param {SemanticRelationFindUniqueArgs} args - Arguments to find a SemanticRelation
     * @example
     * // Get one SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SemanticRelationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationFindUniqueArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SemanticRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SemanticRelationFindUniqueOrThrowArgs} args - Arguments to find a SemanticRelation
     * @example
     * // Get one SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SemanticRelationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SemanticRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationFindFirstArgs} args - Arguments to find a SemanticRelation
     * @example
     * // Get one SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SemanticRelationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationFindFirstArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SemanticRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationFindFirstOrThrowArgs} args - Arguments to find a SemanticRelation
     * @example
     * // Get one SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SemanticRelationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SemanticRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemanticRelations
     * const semanticRelations = await prisma.semanticRelation.findMany()
     * 
     * // Get first 10 SemanticRelations
     * const semanticRelations = await prisma.semanticRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semanticRelationWithIdOnly = await prisma.semanticRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SemanticRelationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SemanticRelation.
     * @param {SemanticRelationCreateArgs} args - Arguments to create a SemanticRelation.
     * @example
     * // Create one SemanticRelation
     * const SemanticRelation = await prisma.semanticRelation.create({
     *   data: {
     *     // ... data to create a SemanticRelation
     *   }
     * })
     * 
    **/
    create<T extends SemanticRelationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationCreateArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SemanticRelations.
     *     @param {SemanticRelationCreateManyArgs} args - Arguments to create many SemanticRelations.
     *     @example
     *     // Create many SemanticRelations
     *     const semanticRelation = await prisma.semanticRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SemanticRelationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SemanticRelation.
     * @param {SemanticRelationDeleteArgs} args - Arguments to delete one SemanticRelation.
     * @example
     * // Delete one SemanticRelation
     * const SemanticRelation = await prisma.semanticRelation.delete({
     *   where: {
     *     // ... filter to delete one SemanticRelation
     *   }
     * })
     * 
    **/
    delete<T extends SemanticRelationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationDeleteArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SemanticRelation.
     * @param {SemanticRelationUpdateArgs} args - Arguments to update one SemanticRelation.
     * @example
     * // Update one SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SemanticRelationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationUpdateArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SemanticRelations.
     * @param {SemanticRelationDeleteManyArgs} args - Arguments to filter SemanticRelations to delete.
     * @example
     * // Delete a few SemanticRelations
     * const { count } = await prisma.semanticRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SemanticRelationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemanticRelationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemanticRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemanticRelations
     * const semanticRelation = await prisma.semanticRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SemanticRelationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemanticRelation.
     * @param {SemanticRelationUpsertArgs} args - Arguments to update or create a SemanticRelation.
     * @example
     * // Update or create a SemanticRelation
     * const semanticRelation = await prisma.semanticRelation.upsert({
     *   create: {
     *     // ... data to create a SemanticRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemanticRelation we want to update
     *   }
     * })
    **/
    upsert<T extends SemanticRelationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SemanticRelationUpsertArgs<ExtArgs>>
    ): Prisma__SemanticRelationClient<$Result.GetResult<Prisma.$SemanticRelationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SemanticRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationCountArgs} args - Arguments to filter SemanticRelations to count.
     * @example
     * // Count the number of SemanticRelations
     * const count = await prisma.semanticRelation.count({
     *   where: {
     *     // ... the filter for the SemanticRelations we want to count
     *   }
     * })
    **/
    count<T extends SemanticRelationCountArgs>(
      args?: Subset<T, SemanticRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemanticRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemanticRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemanticRelationAggregateArgs>(args: Subset<T, SemanticRelationAggregateArgs>): Prisma.PrismaPromise<GetSemanticRelationAggregateType<T>>

    /**
     * Group by SemanticRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemanticRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemanticRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemanticRelationGroupByArgs['orderBy'] }
        : { orderBy?: SemanticRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemanticRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemanticRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemanticRelation model
   */
  readonly fields: SemanticRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemanticRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemanticRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sourceNode<T extends SemanticNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNodeDefaultArgs<ExtArgs>>): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    targetNode<T extends SemanticNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemanticNodeDefaultArgs<ExtArgs>>): Prisma__SemanticNodeClient<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SemanticRelation model
   */ 
  interface SemanticRelationFieldRefs {
    readonly id: FieldRef<"SemanticRelation", 'String'>
    readonly sourceNodeId: FieldRef<"SemanticRelation", 'String'>
    readonly targetNodeId: FieldRef<"SemanticRelation", 'String'>
    readonly relationType: FieldRef<"SemanticRelation", 'String'>
    readonly strength: FieldRef<"SemanticRelation", 'Float'>
    readonly evidence: FieldRef<"SemanticRelation", 'String'>
    readonly createdAt: FieldRef<"SemanticRelation", 'DateTime'>
    readonly confidence: FieldRef<"SemanticRelation", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * SemanticRelation findUnique
   */
  export type SemanticRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter, which SemanticRelation to fetch.
     */
    where: SemanticRelationWhereUniqueInput
  }


  /**
   * SemanticRelation findUniqueOrThrow
   */
  export type SemanticRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter, which SemanticRelation to fetch.
     */
    where: SemanticRelationWhereUniqueInput
  }


  /**
   * SemanticRelation findFirst
   */
  export type SemanticRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter, which SemanticRelation to fetch.
     */
    where?: SemanticRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticRelations to fetch.
     */
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticRelations.
     */
    cursor?: SemanticRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticRelations.
     */
    distinct?: SemanticRelationScalarFieldEnum | SemanticRelationScalarFieldEnum[]
  }


  /**
   * SemanticRelation findFirstOrThrow
   */
  export type SemanticRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter, which SemanticRelation to fetch.
     */
    where?: SemanticRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticRelations to fetch.
     */
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemanticRelations.
     */
    cursor?: SemanticRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemanticRelations.
     */
    distinct?: SemanticRelationScalarFieldEnum | SemanticRelationScalarFieldEnum[]
  }


  /**
   * SemanticRelation findMany
   */
  export type SemanticRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter, which SemanticRelations to fetch.
     */
    where?: SemanticRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemanticRelations to fetch.
     */
    orderBy?: SemanticRelationOrderByWithRelationInput | SemanticRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemanticRelations.
     */
    cursor?: SemanticRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemanticRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemanticRelations.
     */
    skip?: number
    distinct?: SemanticRelationScalarFieldEnum | SemanticRelationScalarFieldEnum[]
  }


  /**
   * SemanticRelation create
   */
  export type SemanticRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a SemanticRelation.
     */
    data: XOR<SemanticRelationCreateInput, SemanticRelationUncheckedCreateInput>
  }


  /**
   * SemanticRelation createMany
   */
  export type SemanticRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemanticRelations.
     */
    data: SemanticRelationCreateManyInput | SemanticRelationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SemanticRelation update
   */
  export type SemanticRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a SemanticRelation.
     */
    data: XOR<SemanticRelationUpdateInput, SemanticRelationUncheckedUpdateInput>
    /**
     * Choose, which SemanticRelation to update.
     */
    where: SemanticRelationWhereUniqueInput
  }


  /**
   * SemanticRelation updateMany
   */
  export type SemanticRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemanticRelations.
     */
    data: XOR<SemanticRelationUpdateManyMutationInput, SemanticRelationUncheckedUpdateManyInput>
    /**
     * Filter which SemanticRelations to update
     */
    where?: SemanticRelationWhereInput
  }


  /**
   * SemanticRelation upsert
   */
  export type SemanticRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the SemanticRelation to update in case it exists.
     */
    where: SemanticRelationWhereUniqueInput
    /**
     * In case the SemanticRelation found by the `where` argument doesn't exist, create a new SemanticRelation with this data.
     */
    create: XOR<SemanticRelationCreateInput, SemanticRelationUncheckedCreateInput>
    /**
     * In case the SemanticRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemanticRelationUpdateInput, SemanticRelationUncheckedUpdateInput>
  }


  /**
   * SemanticRelation delete
   */
  export type SemanticRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
    /**
     * Filter which SemanticRelation to delete.
     */
    where: SemanticRelationWhereUniqueInput
  }


  /**
   * SemanticRelation deleteMany
   */
  export type SemanticRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemanticRelations to delete
     */
    where?: SemanticRelationWhereInput
  }


  /**
   * SemanticRelation without action
   */
  export type SemanticRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticRelation
     */
    select?: SemanticRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticRelationInclude<ExtArgs> | null
  }



  /**
   * Model ConsultationDraft
   */

  export type AggregateConsultationDraft = {
    _count: ConsultationDraftCountAggregateOutputType | null
    _min: ConsultationDraftMinAggregateOutputType | null
    _max: ConsultationDraftMaxAggregateOutputType | null
  }

  export type ConsultationDraftMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationDraftMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationDraftCountAggregateOutputType = {
    id: number
    patientId: number
    status: number
    createdAt: number
    updatedAt: number
    structuredData: number
    _all: number
  }


  export type ConsultationDraftMinAggregateInputType = {
    id?: true
    patientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationDraftMaxAggregateInputType = {
    id?: true
    patientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationDraftCountAggregateInputType = {
    id?: true
    patientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    structuredData?: true
    _all?: true
  }

  export type ConsultationDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationDraft to aggregate.
     */
    where?: ConsultationDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDrafts to fetch.
     */
    orderBy?: ConsultationDraftOrderByWithRelationInput | ConsultationDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationDrafts
    **/
    _count?: true | ConsultationDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationDraftMaxAggregateInputType
  }

  export type GetConsultationDraftAggregateType<T extends ConsultationDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationDraft[P]>
      : GetScalarType<T[P], AggregateConsultationDraft[P]>
  }




  export type ConsultationDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationDraftWhereInput
    orderBy?: ConsultationDraftOrderByWithAggregationInput | ConsultationDraftOrderByWithAggregationInput[]
    by: ConsultationDraftScalarFieldEnum[] | ConsultationDraftScalarFieldEnum
    having?: ConsultationDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationDraftCountAggregateInputType | true
    _min?: ConsultationDraftMinAggregateInputType
    _max?: ConsultationDraftMaxAggregateInputType
  }

  export type ConsultationDraftGroupByOutputType = {
    id: string
    patientId: string
    status: string
    createdAt: Date
    updatedAt: Date
    structuredData: JsonValue
    _count: ConsultationDraftCountAggregateOutputType | null
    _min: ConsultationDraftMinAggregateOutputType | null
    _max: ConsultationDraftMaxAggregateOutputType | null
  }

  type GetConsultationDraftGroupByPayload<T extends ConsultationDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationDraftGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationDraftGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    structuredData?: boolean
  }, ExtArgs["result"]["consultationDraft"]>

  export type ConsultationDraftSelectScalar = {
    id?: boolean
    patientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    structuredData?: boolean
  }


  export type $ConsultationDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationDraft"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      status: string
      createdAt: Date
      updatedAt: Date
      structuredData: Prisma.JsonValue
    }, ExtArgs["result"]["consultationDraft"]>
    composites: {}
  }


  type ConsultationDraftGetPayload<S extends boolean | null | undefined | ConsultationDraftDefaultArgs> = $Result.GetResult<Prisma.$ConsultationDraftPayload, S>

  type ConsultationDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationDraftFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConsultationDraftCountAggregateInputType | true
    }

  export interface ConsultationDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationDraft'], meta: { name: 'ConsultationDraft' } }
    /**
     * Find zero or one ConsultationDraft that matches the filter.
     * @param {ConsultationDraftFindUniqueArgs} args - Arguments to find a ConsultationDraft
     * @example
     * // Get one ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConsultationDraftFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftFindUniqueArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConsultationDraft that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConsultationDraftFindUniqueOrThrowArgs} args - Arguments to find a ConsultationDraft
     * @example
     * // Get one ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConsultationDraftFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConsultationDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftFindFirstArgs} args - Arguments to find a ConsultationDraft
     * @example
     * // Get one ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConsultationDraftFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftFindFirstArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConsultationDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftFindFirstOrThrowArgs} args - Arguments to find a ConsultationDraft
     * @example
     * // Get one ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConsultationDraftFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConsultationDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationDrafts
     * const consultationDrafts = await prisma.consultationDraft.findMany()
     * 
     * // Get first 10 ConsultationDrafts
     * const consultationDrafts = await prisma.consultationDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationDraftWithIdOnly = await prisma.consultationDraft.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConsultationDraftFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConsultationDraft.
     * @param {ConsultationDraftCreateArgs} args - Arguments to create a ConsultationDraft.
     * @example
     * // Create one ConsultationDraft
     * const ConsultationDraft = await prisma.consultationDraft.create({
     *   data: {
     *     // ... data to create a ConsultationDraft
     *   }
     * })
     * 
    **/
    create<T extends ConsultationDraftCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftCreateArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConsultationDrafts.
     *     @param {ConsultationDraftCreateManyArgs} args - Arguments to create many ConsultationDrafts.
     *     @example
     *     // Create many ConsultationDrafts
     *     const consultationDraft = await prisma.consultationDraft.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConsultationDraftCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConsultationDraft.
     * @param {ConsultationDraftDeleteArgs} args - Arguments to delete one ConsultationDraft.
     * @example
     * // Delete one ConsultationDraft
     * const ConsultationDraft = await prisma.consultationDraft.delete({
     *   where: {
     *     // ... filter to delete one ConsultationDraft
     *   }
     * })
     * 
    **/
    delete<T extends ConsultationDraftDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftDeleteArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConsultationDraft.
     * @param {ConsultationDraftUpdateArgs} args - Arguments to update one ConsultationDraft.
     * @example
     * // Update one ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConsultationDraftUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftUpdateArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConsultationDrafts.
     * @param {ConsultationDraftDeleteManyArgs} args - Arguments to filter ConsultationDrafts to delete.
     * @example
     * // Delete a few ConsultationDrafts
     * const { count } = await prisma.consultationDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConsultationDraftDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDraftDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationDrafts
     * const consultationDraft = await prisma.consultationDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConsultationDraftUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationDraft.
     * @param {ConsultationDraftUpsertArgs} args - Arguments to update or create a ConsultationDraft.
     * @example
     * // Update or create a ConsultationDraft
     * const consultationDraft = await prisma.consultationDraft.upsert({
     *   create: {
     *     // ... data to create a ConsultationDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationDraft we want to update
     *   }
     * })
    **/
    upsert<T extends ConsultationDraftUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDraftUpsertArgs<ExtArgs>>
    ): Prisma__ConsultationDraftClient<$Result.GetResult<Prisma.$ConsultationDraftPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConsultationDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftCountArgs} args - Arguments to filter ConsultationDrafts to count.
     * @example
     * // Count the number of ConsultationDrafts
     * const count = await prisma.consultationDraft.count({
     *   where: {
     *     // ... the filter for the ConsultationDrafts we want to count
     *   }
     * })
    **/
    count<T extends ConsultationDraftCountArgs>(
      args?: Subset<T, ConsultationDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationDraftAggregateArgs>(args: Subset<T, ConsultationDraftAggregateArgs>): Prisma.PrismaPromise<GetConsultationDraftAggregateType<T>>

    /**
     * Group by ConsultationDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationDraftGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationDraft model
   */
  readonly fields: ConsultationDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConsultationDraft model
   */ 
  interface ConsultationDraftFieldRefs {
    readonly id: FieldRef<"ConsultationDraft", 'String'>
    readonly patientId: FieldRef<"ConsultationDraft", 'String'>
    readonly status: FieldRef<"ConsultationDraft", 'String'>
    readonly createdAt: FieldRef<"ConsultationDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"ConsultationDraft", 'DateTime'>
    readonly structuredData: FieldRef<"ConsultationDraft", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * ConsultationDraft findUnique
   */
  export type ConsultationDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter, which ConsultationDraft to fetch.
     */
    where: ConsultationDraftWhereUniqueInput
  }


  /**
   * ConsultationDraft findUniqueOrThrow
   */
  export type ConsultationDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter, which ConsultationDraft to fetch.
     */
    where: ConsultationDraftWhereUniqueInput
  }


  /**
   * ConsultationDraft findFirst
   */
  export type ConsultationDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter, which ConsultationDraft to fetch.
     */
    where?: ConsultationDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDrafts to fetch.
     */
    orderBy?: ConsultationDraftOrderByWithRelationInput | ConsultationDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationDrafts.
     */
    cursor?: ConsultationDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationDrafts.
     */
    distinct?: ConsultationDraftScalarFieldEnum | ConsultationDraftScalarFieldEnum[]
  }


  /**
   * ConsultationDraft findFirstOrThrow
   */
  export type ConsultationDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter, which ConsultationDraft to fetch.
     */
    where?: ConsultationDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDrafts to fetch.
     */
    orderBy?: ConsultationDraftOrderByWithRelationInput | ConsultationDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationDrafts.
     */
    cursor?: ConsultationDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationDrafts.
     */
    distinct?: ConsultationDraftScalarFieldEnum | ConsultationDraftScalarFieldEnum[]
  }


  /**
   * ConsultationDraft findMany
   */
  export type ConsultationDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter, which ConsultationDrafts to fetch.
     */
    where?: ConsultationDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDrafts to fetch.
     */
    orderBy?: ConsultationDraftOrderByWithRelationInput | ConsultationDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationDrafts.
     */
    cursor?: ConsultationDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDrafts.
     */
    skip?: number
    distinct?: ConsultationDraftScalarFieldEnum | ConsultationDraftScalarFieldEnum[]
  }


  /**
   * ConsultationDraft create
   */
  export type ConsultationDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * The data needed to create a ConsultationDraft.
     */
    data: XOR<ConsultationDraftCreateInput, ConsultationDraftUncheckedCreateInput>
  }


  /**
   * ConsultationDraft createMany
   */
  export type ConsultationDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationDrafts.
     */
    data: ConsultationDraftCreateManyInput | ConsultationDraftCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConsultationDraft update
   */
  export type ConsultationDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * The data needed to update a ConsultationDraft.
     */
    data: XOR<ConsultationDraftUpdateInput, ConsultationDraftUncheckedUpdateInput>
    /**
     * Choose, which ConsultationDraft to update.
     */
    where: ConsultationDraftWhereUniqueInput
  }


  /**
   * ConsultationDraft updateMany
   */
  export type ConsultationDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationDrafts.
     */
    data: XOR<ConsultationDraftUpdateManyMutationInput, ConsultationDraftUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationDrafts to update
     */
    where?: ConsultationDraftWhereInput
  }


  /**
   * ConsultationDraft upsert
   */
  export type ConsultationDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * The filter to search for the ConsultationDraft to update in case it exists.
     */
    where: ConsultationDraftWhereUniqueInput
    /**
     * In case the ConsultationDraft found by the `where` argument doesn't exist, create a new ConsultationDraft with this data.
     */
    create: XOR<ConsultationDraftCreateInput, ConsultationDraftUncheckedCreateInput>
    /**
     * In case the ConsultationDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationDraftUpdateInput, ConsultationDraftUncheckedUpdateInput>
  }


  /**
   * ConsultationDraft delete
   */
  export type ConsultationDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
    /**
     * Filter which ConsultationDraft to delete.
     */
    where: ConsultationDraftWhereUniqueInput
  }


  /**
   * ConsultationDraft deleteMany
   */
  export type ConsultationDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationDrafts to delete
     */
    where?: ConsultationDraftWhereInput
  }


  /**
   * ConsultationDraft without action
   */
  export type ConsultationDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDraft
     */
    select?: ConsultationDraftSelect<ExtArgs> | null
  }



  /**
   * Model Consultation
   */

  export type AggregateConsultation = {
    _count: ConsultationCountAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  export type ConsultationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    consultationDate: Date | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    rawTranscript: string | null
    rawText: string | null
    createdAt: Date | null
    updatedAt: Date | null
    validatedAt: Date | null
    createdBy: string | null
  }

  export type ConsultationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    consultationDate: Date | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    rawTranscript: string | null
    rawText: string | null
    createdAt: Date | null
    updatedAt: Date | null
    validatedAt: Date | null
    createdBy: string | null
  }

  export type ConsultationCountAggregateOutputType = {
    id: number
    patientId: number
    consultationDate: number
    startTime: number
    endTime: number
    status: number
    rawTranscript: number
    rawText: number
    draftData: number
    createdAt: number
    updatedAt: number
    validatedAt: number
    createdBy: number
    _all: number
  }


  export type ConsultationMinAggregateInputType = {
    id?: true
    patientId?: true
    consultationDate?: true
    startTime?: true
    endTime?: true
    status?: true
    rawTranscript?: true
    rawText?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    createdBy?: true
  }

  export type ConsultationMaxAggregateInputType = {
    id?: true
    patientId?: true
    consultationDate?: true
    startTime?: true
    endTime?: true
    status?: true
    rawTranscript?: true
    rawText?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    createdBy?: true
  }

  export type ConsultationCountAggregateInputType = {
    id?: true
    patientId?: true
    consultationDate?: true
    startTime?: true
    endTime?: true
    status?: true
    rawTranscript?: true
    rawText?: true
    draftData?: true
    createdAt?: true
    updatedAt?: true
    validatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultation to aggregate.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationMaxAggregateInputType
  }

  export type GetConsultationAggregateType<T extends ConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultation[P]>
      : GetScalarType<T[P], AggregateConsultation[P]>
  }




  export type ConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithAggregationInput | ConsultationOrderByWithAggregationInput[]
    by: ConsultationScalarFieldEnum[] | ConsultationScalarFieldEnum
    having?: ConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationCountAggregateInputType | true
    _min?: ConsultationMinAggregateInputType
    _max?: ConsultationMaxAggregateInputType
  }

  export type ConsultationGroupByOutputType = {
    id: string
    patientId: string
    consultationDate: Date
    startTime: Date
    endTime: Date | null
    status: string
    rawTranscript: string | null
    rawText: string | null
    draftData: JsonValue
    createdAt: Date
    updatedAt: Date
    validatedAt: Date | null
    createdBy: string
    _count: ConsultationCountAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  type GetConsultationGroupByPayload<T extends ConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consultationDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    rawTranscript?: boolean
    rawText?: boolean
    draftData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    createdBy?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    semanticNodes?: boolean | Consultation$semanticNodesArgs<ExtArgs>
    medicalDocuments?: boolean | Consultation$medicalDocumentsArgs<ExtArgs>
    medicalReports?: boolean | Consultation$medicalReportsArgs<ExtArgs>
    appointment?: boolean | Consultation$appointmentArgs<ExtArgs>
    billingEvents?: boolean | Consultation$billingEventsArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectScalar = {
    id?: boolean
    patientId?: boolean
    consultationDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    rawTranscript?: boolean
    rawText?: boolean
    draftData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    validatedAt?: boolean
    createdBy?: boolean
  }

  export type ConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    semanticNodes?: boolean | Consultation$semanticNodesArgs<ExtArgs>
    medicalDocuments?: boolean | Consultation$medicalDocumentsArgs<ExtArgs>
    medicalReports?: boolean | Consultation$medicalReportsArgs<ExtArgs>
    appointment?: boolean | Consultation$appointmentArgs<ExtArgs>
    billingEvents?: boolean | Consultation$billingEventsArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      semanticNodes: Prisma.$SemanticNodePayload<ExtArgs>[]
      medicalDocuments: Prisma.$MedicalDocumentPayload<ExtArgs>[]
      medicalReports: Prisma.$MedicalReportPayload<ExtArgs>[]
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      billingEvents: Prisma.$BillingEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      consultationDate: Date
      startTime: Date
      endTime: Date | null
      status: string
      rawTranscript: string | null
      rawText: string | null
      draftData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      validatedAt: Date | null
      createdBy: string
    }, ExtArgs["result"]["consultation"]>
    composites: {}
  }


  type ConsultationGetPayload<S extends boolean | null | undefined | ConsultationDefaultArgs> = $Result.GetResult<Prisma.$ConsultationPayload, S>

  type ConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConsultationCountAggregateInputType | true
    }

  export interface ConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultation'], meta: { name: 'Consultation' } }
    /**
     * Find zero or one Consultation that matches the filter.
     * @param {ConsultationFindUniqueArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConsultationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Consultation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConsultationFindUniqueOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConsultationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConsultationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationFindFirstArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConsultationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultation.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationWithIdOnly = await prisma.consultation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConsultationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Consultation.
     * @param {ConsultationCreateArgs} args - Arguments to create a Consultation.
     * @example
     * // Create one Consultation
     * const Consultation = await prisma.consultation.create({
     *   data: {
     *     // ... data to create a Consultation
     *   }
     * })
     * 
    **/
    create<T extends ConsultationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationCreateArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Consultations.
     *     @param {ConsultationCreateManyArgs} args - Arguments to create many Consultations.
     *     @example
     *     // Create many Consultations
     *     const consultation = await prisma.consultation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConsultationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultation.
     * @param {ConsultationDeleteArgs} args - Arguments to delete one Consultation.
     * @example
     * // Delete one Consultation
     * const Consultation = await prisma.consultation.delete({
     *   where: {
     *     // ... filter to delete one Consultation
     *   }
     * })
     * 
    **/
    delete<T extends ConsultationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationDeleteArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Consultation.
     * @param {ConsultationUpdateArgs} args - Arguments to update one Consultation.
     * @example
     * // Update one Consultation
     * const consultation = await prisma.consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConsultationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationUpdateArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConsultationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConsultationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultation.
     * @param {ConsultationUpsertArgs} args - Arguments to update or create a Consultation.
     * @example
     * // Update or create a Consultation
     * const consultation = await prisma.consultation.upsert({
     *   create: {
     *     // ... data to create a Consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultation we want to update
     *   }
     * })
    **/
    upsert<T extends ConsultationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultationUpsertArgs<ExtArgs>>
    ): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultation.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationCountArgs>(
      args?: Subset<T, ConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationAggregateArgs>(args: Subset<T, ConsultationAggregateArgs>): Prisma.PrismaPromise<GetConsultationAggregateType<T>>

    /**
     * Group by Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultation model
   */
  readonly fields: ConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semanticNodes<T extends Consultation$semanticNodesArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$semanticNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemanticNodePayload<ExtArgs>, T, 'findMany'> | Null>;

    medicalDocuments<T extends Consultation$medicalDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$medicalDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    medicalReports<T extends Consultation$medicalReportsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$medicalReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    appointment<T extends Consultation$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    billingEvents<T extends Consultation$billingEventsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$billingEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Consultation model
   */ 
  interface ConsultationFieldRefs {
    readonly id: FieldRef<"Consultation", 'String'>
    readonly patientId: FieldRef<"Consultation", 'String'>
    readonly consultationDate: FieldRef<"Consultation", 'DateTime'>
    readonly startTime: FieldRef<"Consultation", 'DateTime'>
    readonly endTime: FieldRef<"Consultation", 'DateTime'>
    readonly status: FieldRef<"Consultation", 'String'>
    readonly rawTranscript: FieldRef<"Consultation", 'String'>
    readonly rawText: FieldRef<"Consultation", 'String'>
    readonly draftData: FieldRef<"Consultation", 'Json'>
    readonly createdAt: FieldRef<"Consultation", 'DateTime'>
    readonly updatedAt: FieldRef<"Consultation", 'DateTime'>
    readonly validatedAt: FieldRef<"Consultation", 'DateTime'>
    readonly createdBy: FieldRef<"Consultation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Consultation findUnique
   */
  export type ConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }


  /**
   * Consultation findUniqueOrThrow
   */
  export type ConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }


  /**
   * Consultation findFirst
   */
  export type ConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }


  /**
   * Consultation findFirstOrThrow
   */
  export type ConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }


  /**
   * Consultation findMany
   */
  export type ConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultations to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }


  /**
   * Consultation create
   */
  export type ConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultation.
     */
    data: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
  }


  /**
   * Consultation createMany
   */
  export type ConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Consultation update
   */
  export type ConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultation.
     */
    data: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
    /**
     * Choose, which Consultation to update.
     */
    where: ConsultationWhereUniqueInput
  }


  /**
   * Consultation updateMany
   */
  export type ConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
  }


  /**
   * Consultation upsert
   */
  export type ConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultation to update in case it exists.
     */
    where: ConsultationWhereUniqueInput
    /**
     * In case the Consultation found by the `where` argument doesn't exist, create a new Consultation with this data.
     */
    create: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
    /**
     * In case the Consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
  }


  /**
   * Consultation delete
   */
  export type ConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter which Consultation to delete.
     */
    where: ConsultationWhereUniqueInput
  }


  /**
   * Consultation deleteMany
   */
  export type ConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultations to delete
     */
    where?: ConsultationWhereInput
  }


  /**
   * Consultation.semanticNodes
   */
  export type Consultation$semanticNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemanticNode
     */
    select?: SemanticNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemanticNodeInclude<ExtArgs> | null
    where?: SemanticNodeWhereInput
    orderBy?: SemanticNodeOrderByWithRelationInput | SemanticNodeOrderByWithRelationInput[]
    cursor?: SemanticNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemanticNodeScalarFieldEnum | SemanticNodeScalarFieldEnum[]
  }


  /**
   * Consultation.medicalDocuments
   */
  export type Consultation$medicalDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    cursor?: MedicalDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }


  /**
   * Consultation.medicalReports
   */
  export type Consultation$medicalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    where?: MedicalReportWhereInput
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    cursor?: MedicalReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalReportScalarFieldEnum | MedicalReportScalarFieldEnum[]
  }


  /**
   * Consultation.appointment
   */
  export type Consultation$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }


  /**
   * Consultation.billingEvents
   */
  export type Consultation$billingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    where?: BillingEventWhereInput
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[]
    cursor?: BillingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[]
  }


  /**
   * Consultation without action
   */
  export type ConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
  }



  /**
   * Model BillingEvent
   */

  export type AggregateBillingEvent = {
    _count: BillingEventCountAggregateOutputType | null
    _min: BillingEventMinAggregateOutputType | null
    _max: BillingEventMaxAggregateOutputType | null
  }

  export type BillingEventMinAggregateOutputType = {
    id: string | null
    consultationId: string | null
    ghmCode: string | null
    actCode: string | null
    actType: string | null
    status: string | null
    createdAt: Date | null
    transmittedAt: Date | null
  }

  export type BillingEventMaxAggregateOutputType = {
    id: string | null
    consultationId: string | null
    ghmCode: string | null
    actCode: string | null
    actType: string | null
    status: string | null
    createdAt: Date | null
    transmittedAt: Date | null
  }

  export type BillingEventCountAggregateOutputType = {
    id: number
    consultationId: number
    ghmCode: number
    actCode: number
    actType: number
    status: number
    evidenceNodeIds: number
    createdAt: number
    transmittedAt: number
    _all: number
  }


  export type BillingEventMinAggregateInputType = {
    id?: true
    consultationId?: true
    ghmCode?: true
    actCode?: true
    actType?: true
    status?: true
    createdAt?: true
    transmittedAt?: true
  }

  export type BillingEventMaxAggregateInputType = {
    id?: true
    consultationId?: true
    ghmCode?: true
    actCode?: true
    actType?: true
    status?: true
    createdAt?: true
    transmittedAt?: true
  }

  export type BillingEventCountAggregateInputType = {
    id?: true
    consultationId?: true
    ghmCode?: true
    actCode?: true
    actType?: true
    status?: true
    evidenceNodeIds?: true
    createdAt?: true
    transmittedAt?: true
    _all?: true
  }

  export type BillingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingEvent to aggregate.
     */
    where?: BillingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingEvents
    **/
    _count?: true | BillingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingEventMaxAggregateInputType
  }

  export type GetBillingEventAggregateType<T extends BillingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingEvent[P]>
      : GetScalarType<T[P], AggregateBillingEvent[P]>
  }




  export type BillingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingEventWhereInput
    orderBy?: BillingEventOrderByWithAggregationInput | BillingEventOrderByWithAggregationInput[]
    by: BillingEventScalarFieldEnum[] | BillingEventScalarFieldEnum
    having?: BillingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingEventCountAggregateInputType | true
    _min?: BillingEventMinAggregateInputType
    _max?: BillingEventMaxAggregateInputType
  }

  export type BillingEventGroupByOutputType = {
    id: string
    consultationId: string
    ghmCode: string | null
    actCode: string | null
    actType: string
    status: string
    evidenceNodeIds: string[]
    createdAt: Date
    transmittedAt: Date | null
    _count: BillingEventCountAggregateOutputType | null
    _min: BillingEventMinAggregateOutputType | null
    _max: BillingEventMaxAggregateOutputType | null
  }

  type GetBillingEventGroupByPayload<T extends BillingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingEventGroupByOutputType[P]>
            : GetScalarType<T[P], BillingEventGroupByOutputType[P]>
        }
      >
    >


  export type BillingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    ghmCode?: boolean
    actCode?: boolean
    actType?: boolean
    status?: boolean
    evidenceNodeIds?: boolean
    createdAt?: boolean
    transmittedAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingEvent"]>

  export type BillingEventSelectScalar = {
    id?: boolean
    consultationId?: boolean
    ghmCode?: boolean
    actCode?: boolean
    actType?: boolean
    status?: boolean
    evidenceNodeIds?: boolean
    createdAt?: boolean
    transmittedAt?: boolean
  }

  export type BillingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }


  export type $BillingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingEvent"
    objects: {
      consultation: Prisma.$ConsultationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationId: string
      ghmCode: string | null
      actCode: string | null
      actType: string
      status: string
      evidenceNodeIds: string[]
      createdAt: Date
      transmittedAt: Date | null
    }, ExtArgs["result"]["billingEvent"]>
    composites: {}
  }


  type BillingEventGetPayload<S extends boolean | null | undefined | BillingEventDefaultArgs> = $Result.GetResult<Prisma.$BillingEventPayload, S>

  type BillingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingEventFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BillingEventCountAggregateInputType | true
    }

  export interface BillingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingEvent'], meta: { name: 'BillingEvent' } }
    /**
     * Find zero or one BillingEvent that matches the filter.
     * @param {BillingEventFindUniqueArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillingEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventFindUniqueArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BillingEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BillingEventFindUniqueOrThrowArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillingEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BillingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindFirstArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillingEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventFindFirstArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BillingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindFirstOrThrowArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillingEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BillingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingEvents
     * const billingEvents = await prisma.billingEvent.findMany()
     * 
     * // Get first 10 BillingEvents
     * const billingEvents = await prisma.billingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingEventWithIdOnly = await prisma.billingEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillingEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BillingEvent.
     * @param {BillingEventCreateArgs} args - Arguments to create a BillingEvent.
     * @example
     * // Create one BillingEvent
     * const BillingEvent = await prisma.billingEvent.create({
     *   data: {
     *     // ... data to create a BillingEvent
     *   }
     * })
     * 
    **/
    create<T extends BillingEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventCreateArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BillingEvents.
     *     @param {BillingEventCreateManyArgs} args - Arguments to create many BillingEvents.
     *     @example
     *     // Create many BillingEvents
     *     const billingEvent = await prisma.billingEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillingEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillingEvent.
     * @param {BillingEventDeleteArgs} args - Arguments to delete one BillingEvent.
     * @example
     * // Delete one BillingEvent
     * const BillingEvent = await prisma.billingEvent.delete({
     *   where: {
     *     // ... filter to delete one BillingEvent
     *   }
     * })
     * 
    **/
    delete<T extends BillingEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventDeleteArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BillingEvent.
     * @param {BillingEventUpdateArgs} args - Arguments to update one BillingEvent.
     * @example
     * // Update one BillingEvent
     * const billingEvent = await prisma.billingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillingEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventUpdateArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BillingEvents.
     * @param {BillingEventDeleteManyArgs} args - Arguments to filter BillingEvents to delete.
     * @example
     * // Delete a few BillingEvents
     * const { count } = await prisma.billingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillingEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingEvents
     * const billingEvent = await prisma.billingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillingEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingEvent.
     * @param {BillingEventUpsertArgs} args - Arguments to update or create a BillingEvent.
     * @example
     * // Update or create a BillingEvent
     * const billingEvent = await prisma.billingEvent.upsert({
     *   create: {
     *     // ... data to create a BillingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingEvent we want to update
     *   }
     * })
    **/
    upsert<T extends BillingEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillingEventUpsertArgs<ExtArgs>>
    ): Prisma__BillingEventClient<$Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BillingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventCountArgs} args - Arguments to filter BillingEvents to count.
     * @example
     * // Count the number of BillingEvents
     * const count = await prisma.billingEvent.count({
     *   where: {
     *     // ... the filter for the BillingEvents we want to count
     *   }
     * })
    **/
    count<T extends BillingEventCountArgs>(
      args?: Subset<T, BillingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingEventAggregateArgs>(args: Subset<T, BillingEventAggregateArgs>): Prisma.PrismaPromise<GetBillingEventAggregateType<T>>

    /**
     * Group by BillingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingEventGroupByArgs['orderBy'] }
        : { orderBy?: BillingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingEvent model
   */
  readonly fields: BillingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    consultation<T extends ConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationDefaultArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BillingEvent model
   */ 
  interface BillingEventFieldRefs {
    readonly id: FieldRef<"BillingEvent", 'String'>
    readonly consultationId: FieldRef<"BillingEvent", 'String'>
    readonly ghmCode: FieldRef<"BillingEvent", 'String'>
    readonly actCode: FieldRef<"BillingEvent", 'String'>
    readonly actType: FieldRef<"BillingEvent", 'String'>
    readonly status: FieldRef<"BillingEvent", 'String'>
    readonly evidenceNodeIds: FieldRef<"BillingEvent", 'String[]'>
    readonly createdAt: FieldRef<"BillingEvent", 'DateTime'>
    readonly transmittedAt: FieldRef<"BillingEvent", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BillingEvent findUnique
   */
  export type BillingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter, which BillingEvent to fetch.
     */
    where: BillingEventWhereUniqueInput
  }


  /**
   * BillingEvent findUniqueOrThrow
   */
  export type BillingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter, which BillingEvent to fetch.
     */
    where: BillingEventWhereUniqueInput
  }


  /**
   * BillingEvent findFirst
   */
  export type BillingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter, which BillingEvent to fetch.
     */
    where?: BillingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingEvents.
     */
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[]
  }


  /**
   * BillingEvent findFirstOrThrow
   */
  export type BillingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter, which BillingEvent to fetch.
     */
    where?: BillingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingEvents.
     */
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[]
  }


  /**
   * BillingEvent findMany
   */
  export type BillingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter, which BillingEvents to fetch.
     */
    where?: BillingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingEvents.
     */
    skip?: number
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[]
  }


  /**
   * BillingEvent create
   */
  export type BillingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingEvent.
     */
    data: XOR<BillingEventCreateInput, BillingEventUncheckedCreateInput>
  }


  /**
   * BillingEvent createMany
   */
  export type BillingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingEvents.
     */
    data: BillingEventCreateManyInput | BillingEventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BillingEvent update
   */
  export type BillingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingEvent.
     */
    data: XOR<BillingEventUpdateInput, BillingEventUncheckedUpdateInput>
    /**
     * Choose, which BillingEvent to update.
     */
    where: BillingEventWhereUniqueInput
  }


  /**
   * BillingEvent updateMany
   */
  export type BillingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingEvents.
     */
    data: XOR<BillingEventUpdateManyMutationInput, BillingEventUncheckedUpdateManyInput>
    /**
     * Filter which BillingEvents to update
     */
    where?: BillingEventWhereInput
  }


  /**
   * BillingEvent upsert
   */
  export type BillingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingEvent to update in case it exists.
     */
    where: BillingEventWhereUniqueInput
    /**
     * In case the BillingEvent found by the `where` argument doesn't exist, create a new BillingEvent with this data.
     */
    create: XOR<BillingEventCreateInput, BillingEventUncheckedCreateInput>
    /**
     * In case the BillingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingEventUpdateInput, BillingEventUncheckedUpdateInput>
  }


  /**
   * BillingEvent delete
   */
  export type BillingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
    /**
     * Filter which BillingEvent to delete.
     */
    where: BillingEventWhereUniqueInput
  }


  /**
   * BillingEvent deleteMany
   */
  export type BillingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingEvents to delete
     */
    where?: BillingEventWhereInput
  }


  /**
   * BillingEvent without action
   */
  export type BillingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BillingEventInclude<ExtArgs> | null
  }



  /**
   * Model Allergy
   */

  export type AggregateAllergy = {
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  export type AllergyMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    substance: string | null
    snomedCtCode: string | null
    severity: string | null
    createdAt: Date | null
    source: string | null
  }

  export type AllergyMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    substance: string | null
    snomedCtCode: string | null
    severity: string | null
    createdAt: Date | null
    source: string | null
  }

  export type AllergyCountAggregateOutputType = {
    id: number
    patientId: number
    substance: number
    snomedCtCode: number
    severity: number
    createdAt: number
    source: number
    _all: number
  }


  export type AllergyMinAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    snomedCtCode?: true
    severity?: true
    createdAt?: true
    source?: true
  }

  export type AllergyMaxAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    snomedCtCode?: true
    severity?: true
    createdAt?: true
    source?: true
  }

  export type AllergyCountAggregateInputType = {
    id?: true
    patientId?: true
    substance?: true
    snomedCtCode?: true
    severity?: true
    createdAt?: true
    source?: true
    _all?: true
  }

  export type AllergyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergy to aggregate.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allergies
    **/
    _count?: true | AllergyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergyMaxAggregateInputType
  }

  export type GetAllergyAggregateType<T extends AllergyAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergy[P]>
      : GetScalarType<T[P], AggregateAllergy[P]>
  }




  export type AllergyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyWhereInput
    orderBy?: AllergyOrderByWithAggregationInput | AllergyOrderByWithAggregationInput[]
    by: AllergyScalarFieldEnum[] | AllergyScalarFieldEnum
    having?: AllergyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergyCountAggregateInputType | true
    _min?: AllergyMinAggregateInputType
    _max?: AllergyMaxAggregateInputType
  }

  export type AllergyGroupByOutputType = {
    id: string
    patientId: string
    substance: string
    snomedCtCode: string | null
    severity: string
    createdAt: Date
    source: string | null
    _count: AllergyCountAggregateOutputType | null
    _min: AllergyMinAggregateOutputType | null
    _max: AllergyMaxAggregateOutputType | null
  }

  type GetAllergyGroupByPayload<T extends AllergyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergyGroupByOutputType[P]>
            : GetScalarType<T[P], AllergyGroupByOutputType[P]>
        }
      >
    >


  export type AllergySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    substance?: boolean
    snomedCtCode?: boolean
    severity?: boolean
    createdAt?: boolean
    source?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergy"]>

  export type AllergySelectScalar = {
    id?: boolean
    patientId?: boolean
    substance?: boolean
    snomedCtCode?: boolean
    severity?: boolean
    createdAt?: boolean
    source?: boolean
  }

  export type AllergyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }


  export type $AllergyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allergy"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      substance: string
      snomedCtCode: string | null
      severity: string
      createdAt: Date
      source: string | null
    }, ExtArgs["result"]["allergy"]>
    composites: {}
  }


  type AllergyGetPayload<S extends boolean | null | undefined | AllergyDefaultArgs> = $Result.GetResult<Prisma.$AllergyPayload, S>

  type AllergyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AllergyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AllergyCountAggregateInputType | true
    }

  export interface AllergyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allergy'], meta: { name: 'Allergy' } }
    /**
     * Find zero or one Allergy that matches the filter.
     * @param {AllergyFindUniqueArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AllergyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyFindUniqueArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Allergy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AllergyFindUniqueOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AllergyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Allergy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AllergyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyFindFirstArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Allergy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindFirstOrThrowArgs} args - Arguments to find a Allergy
     * @example
     * // Get one Allergy
     * const allergy = await prisma.allergy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AllergyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Allergies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allergies
     * const allergies = await prisma.allergy.findMany()
     * 
     * // Get first 10 Allergies
     * const allergies = await prisma.allergy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergyWithIdOnly = await prisma.allergy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AllergyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Allergy.
     * @param {AllergyCreateArgs} args - Arguments to create a Allergy.
     * @example
     * // Create one Allergy
     * const Allergy = await prisma.allergy.create({
     *   data: {
     *     // ... data to create a Allergy
     *   }
     * })
     * 
    **/
    create<T extends AllergyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyCreateArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Allergies.
     *     @param {AllergyCreateManyArgs} args - Arguments to create many Allergies.
     *     @example
     *     // Create many Allergies
     *     const allergy = await prisma.allergy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AllergyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Allergy.
     * @param {AllergyDeleteArgs} args - Arguments to delete one Allergy.
     * @example
     * // Delete one Allergy
     * const Allergy = await prisma.allergy.delete({
     *   where: {
     *     // ... filter to delete one Allergy
     *   }
     * })
     * 
    **/
    delete<T extends AllergyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyDeleteArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Allergy.
     * @param {AllergyUpdateArgs} args - Arguments to update one Allergy.
     * @example
     * // Update one Allergy
     * const allergy = await prisma.allergy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AllergyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyUpdateArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Allergies.
     * @param {AllergyDeleteManyArgs} args - Arguments to filter Allergies to delete.
     * @example
     * // Delete a few Allergies
     * const { count } = await prisma.allergy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AllergyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AllergyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allergies
     * const allergy = await prisma.allergy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AllergyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Allergy.
     * @param {AllergyUpsertArgs} args - Arguments to update or create a Allergy.
     * @example
     * // Update or create a Allergy
     * const allergy = await prisma.allergy.upsert({
     *   create: {
     *     // ... data to create a Allergy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allergy we want to update
     *   }
     * })
    **/
    upsert<T extends AllergyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AllergyUpsertArgs<ExtArgs>>
    ): Prisma__AllergyClient<$Result.GetResult<Prisma.$AllergyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyCountArgs} args - Arguments to filter Allergies to count.
     * @example
     * // Count the number of Allergies
     * const count = await prisma.allergy.count({
     *   where: {
     *     // ... the filter for the Allergies we want to count
     *   }
     * })
    **/
    count<T extends AllergyCountArgs>(
      args?: Subset<T, AllergyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergyAggregateArgs>(args: Subset<T, AllergyAggregateArgs>): Prisma.PrismaPromise<GetAllergyAggregateType<T>>

    /**
     * Group by Allergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergyGroupByArgs['orderBy'] }
        : { orderBy?: AllergyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allergy model
   */
  readonly fields: AllergyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allergy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Allergy model
   */ 
  interface AllergyFieldRefs {
    readonly id: FieldRef<"Allergy", 'String'>
    readonly patientId: FieldRef<"Allergy", 'String'>
    readonly substance: FieldRef<"Allergy", 'String'>
    readonly snomedCtCode: FieldRef<"Allergy", 'String'>
    readonly severity: FieldRef<"Allergy", 'String'>
    readonly createdAt: FieldRef<"Allergy", 'DateTime'>
    readonly source: FieldRef<"Allergy", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Allergy findUnique
   */
  export type AllergyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }


  /**
   * Allergy findUniqueOrThrow
   */
  export type AllergyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where: AllergyWhereUniqueInput
  }


  /**
   * Allergy findFirst
   */
  export type AllergyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }


  /**
   * Allergy findFirstOrThrow
   */
  export type AllergyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergy to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }


  /**
   * Allergy findMany
   */
  export type AllergyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter, which Allergies to fetch.
     */
    where?: AllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergyOrderByWithRelationInput | AllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allergies.
     */
    cursor?: AllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    distinct?: AllergyScalarFieldEnum | AllergyScalarFieldEnum[]
  }


  /**
   * Allergy create
   */
  export type AllergyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to create a Allergy.
     */
    data: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
  }


  /**
   * Allergy createMany
   */
  export type AllergyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allergies.
     */
    data: AllergyCreateManyInput | AllergyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Allergy update
   */
  export type AllergyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The data needed to update a Allergy.
     */
    data: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
    /**
     * Choose, which Allergy to update.
     */
    where: AllergyWhereUniqueInput
  }


  /**
   * Allergy updateMany
   */
  export type AllergyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergyWhereInput
  }


  /**
   * Allergy upsert
   */
  export type AllergyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * The filter to search for the Allergy to update in case it exists.
     */
    where: AllergyWhereUniqueInput
    /**
     * In case the Allergy found by the `where` argument doesn't exist, create a new Allergy with this data.
     */
    create: XOR<AllergyCreateInput, AllergyUncheckedCreateInput>
    /**
     * In case the Allergy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergyUpdateInput, AllergyUncheckedUpdateInput>
  }


  /**
   * Allergy delete
   */
  export type AllergyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
    /**
     * Filter which Allergy to delete.
     */
    where: AllergyWhereUniqueInput
  }


  /**
   * Allergy deleteMany
   */
  export type AllergyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergies to delete
     */
    where?: AllergyWhereInput
  }


  /**
   * Allergy without action
   */
  export type AllergyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergy
     */
    select?: AllergySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AllergyInclude<ExtArgs> | null
  }



  /**
   * Model MedicalDocument
   */

  export type AggregateMedicalDocument = {
    _count: MedicalDocumentCountAggregateOutputType | null
    _min: MedicalDocumentMinAggregateOutputType | null
    _max: MedicalDocumentMaxAggregateOutputType | null
  }

  export type MedicalDocumentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    documentType: string | null
    title: string | null
    rawContent: string | null
    documentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    consultationId: string | null
  }

  export type MedicalDocumentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    documentType: string | null
    title: string | null
    rawContent: string | null
    documentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    consultationId: string | null
  }

  export type MedicalDocumentCountAggregateOutputType = {
    id: number
    patientId: number
    documentType: number
    title: number
    content: number
    rawContent: number
    documentDate: number
    createdAt: number
    updatedAt: number
    createdBy: number
    consultationId: number
    _all: number
  }


  export type MedicalDocumentMinAggregateInputType = {
    id?: true
    patientId?: true
    documentType?: true
    title?: true
    rawContent?: true
    documentDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    consultationId?: true
  }

  export type MedicalDocumentMaxAggregateInputType = {
    id?: true
    patientId?: true
    documentType?: true
    title?: true
    rawContent?: true
    documentDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    consultationId?: true
  }

  export type MedicalDocumentCountAggregateInputType = {
    id?: true
    patientId?: true
    documentType?: true
    title?: true
    content?: true
    rawContent?: true
    documentDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    consultationId?: true
    _all?: true
  }

  export type MedicalDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalDocument to aggregate.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalDocuments
    **/
    _count?: true | MedicalDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalDocumentMaxAggregateInputType
  }

  export type GetMedicalDocumentAggregateType<T extends MedicalDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalDocument[P]>
      : GetScalarType<T[P], AggregateMedicalDocument[P]>
  }




  export type MedicalDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalDocumentWhereInput
    orderBy?: MedicalDocumentOrderByWithAggregationInput | MedicalDocumentOrderByWithAggregationInput[]
    by: MedicalDocumentScalarFieldEnum[] | MedicalDocumentScalarFieldEnum
    having?: MedicalDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalDocumentCountAggregateInputType | true
    _min?: MedicalDocumentMinAggregateInputType
    _max?: MedicalDocumentMaxAggregateInputType
  }

  export type MedicalDocumentGroupByOutputType = {
    id: string
    patientId: string
    documentType: string
    title: string
    content: JsonValue
    rawContent: string | null
    documentDate: Date
    createdAt: Date
    updatedAt: Date
    createdBy: string
    consultationId: string | null
    _count: MedicalDocumentCountAggregateOutputType | null
    _min: MedicalDocumentMinAggregateOutputType | null
    _max: MedicalDocumentMaxAggregateOutputType | null
  }

  type GetMedicalDocumentGroupByPayload<T extends MedicalDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalDocumentGroupByOutputType[P]>
        }
      >
    >


  export type MedicalDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    documentType?: boolean
    title?: boolean
    content?: boolean
    rawContent?: boolean
    documentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    consultationId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | MedicalDocument$consultationArgs<ExtArgs>
    prescription?: boolean | MedicalDocument$prescriptionArgs<ExtArgs>
    medicalReport?: boolean | MedicalDocument$medicalReportArgs<ExtArgs>
    laboratoryResult?: boolean | MedicalDocument$laboratoryResultArgs<ExtArgs>
    medicalImage?: boolean | MedicalDocument$medicalImageArgs<ExtArgs>
    attachments?: boolean | MedicalDocument$attachmentsArgs<ExtArgs>
    _count?: boolean | MedicalDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalDocument"]>

  export type MedicalDocumentSelectScalar = {
    id?: boolean
    patientId?: boolean
    documentType?: boolean
    title?: boolean
    content?: boolean
    rawContent?: boolean
    documentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    consultationId?: boolean
  }

  export type MedicalDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | MedicalDocument$consultationArgs<ExtArgs>
    prescription?: boolean | MedicalDocument$prescriptionArgs<ExtArgs>
    medicalReport?: boolean | MedicalDocument$medicalReportArgs<ExtArgs>
    laboratoryResult?: boolean | MedicalDocument$laboratoryResultArgs<ExtArgs>
    medicalImage?: boolean | MedicalDocument$medicalImageArgs<ExtArgs>
    attachments?: boolean | MedicalDocument$attachmentsArgs<ExtArgs>
    _count?: boolean | MedicalDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MedicalDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalDocument"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
      medicalReport: Prisma.$MedicalReportPayload<ExtArgs> | null
      laboratoryResult: Prisma.$LaboratoryResultPayload<ExtArgs> | null
      medicalImage: Prisma.$MedicalImagePayload<ExtArgs> | null
      attachments: Prisma.$DocumentAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      documentType: string
      title: string
      content: Prisma.JsonValue
      rawContent: string | null
      documentDate: Date
      createdAt: Date
      updatedAt: Date
      createdBy: string
      consultationId: string | null
    }, ExtArgs["result"]["medicalDocument"]>
    composites: {}
  }


  type MedicalDocumentGetPayload<S extends boolean | null | undefined | MedicalDocumentDefaultArgs> = $Result.GetResult<Prisma.$MedicalDocumentPayload, S>

  type MedicalDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalDocumentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MedicalDocumentCountAggregateInputType | true
    }

  export interface MedicalDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalDocument'], meta: { name: 'MedicalDocument' } }
    /**
     * Find zero or one MedicalDocument that matches the filter.
     * @param {MedicalDocumentFindUniqueArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MedicalDocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MedicalDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MedicalDocumentFindUniqueOrThrowArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MedicalDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MedicalDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindFirstArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MedicalDocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentFindFirstArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MedicalDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindFirstOrThrowArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MedicalDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MedicalDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalDocuments
     * const medicalDocuments = await prisma.medicalDocument.findMany()
     * 
     * // Get first 10 MedicalDocuments
     * const medicalDocuments = await prisma.medicalDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalDocumentWithIdOnly = await prisma.medicalDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MedicalDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MedicalDocument.
     * @param {MedicalDocumentCreateArgs} args - Arguments to create a MedicalDocument.
     * @example
     * // Create one MedicalDocument
     * const MedicalDocument = await prisma.medicalDocument.create({
     *   data: {
     *     // ... data to create a MedicalDocument
     *   }
     * })
     * 
    **/
    create<T extends MedicalDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentCreateArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MedicalDocuments.
     *     @param {MedicalDocumentCreateManyArgs} args - Arguments to create many MedicalDocuments.
     *     @example
     *     // Create many MedicalDocuments
     *     const medicalDocument = await prisma.medicalDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MedicalDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalDocument.
     * @param {MedicalDocumentDeleteArgs} args - Arguments to delete one MedicalDocument.
     * @example
     * // Delete one MedicalDocument
     * const MedicalDocument = await prisma.medicalDocument.delete({
     *   where: {
     *     // ... filter to delete one MedicalDocument
     *   }
     * })
     * 
    **/
    delete<T extends MedicalDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentDeleteArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MedicalDocument.
     * @param {MedicalDocumentUpdateArgs} args - Arguments to update one MedicalDocument.
     * @example
     * // Update one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MedicalDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentUpdateArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MedicalDocuments.
     * @param {MedicalDocumentDeleteManyArgs} args - Arguments to filter MedicalDocuments to delete.
     * @example
     * // Delete a few MedicalDocuments
     * const { count } = await prisma.medicalDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MedicalDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalDocuments
     * const medicalDocument = await prisma.medicalDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MedicalDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalDocument.
     * @param {MedicalDocumentUpsertArgs} args - Arguments to update or create a MedicalDocument.
     * @example
     * // Update or create a MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.upsert({
     *   create: {
     *     // ... data to create a MedicalDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalDocument we want to update
     *   }
     * })
    **/
    upsert<T extends MedicalDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalDocumentUpsertArgs<ExtArgs>>
    ): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MedicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentCountArgs} args - Arguments to filter MedicalDocuments to count.
     * @example
     * // Count the number of MedicalDocuments
     * const count = await prisma.medicalDocument.count({
     *   where: {
     *     // ... the filter for the MedicalDocuments we want to count
     *   }
     * })
    **/
    count<T extends MedicalDocumentCountArgs>(
      args?: Subset<T, MedicalDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalDocumentAggregateArgs>(args: Subset<T, MedicalDocumentAggregateArgs>): Prisma.PrismaPromise<GetMedicalDocumentAggregateType<T>>

    /**
     * Group by MedicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalDocumentGroupByArgs['orderBy'] }
        : { orderBy?: MedicalDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalDocument model
   */
  readonly fields: MedicalDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    consultation<T extends MedicalDocument$consultationArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    prescription<T extends MedicalDocument$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    medicalReport<T extends MedicalDocument$medicalReportArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$medicalReportArgs<ExtArgs>>): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    laboratoryResult<T extends MedicalDocument$laboratoryResultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$laboratoryResultArgs<ExtArgs>>): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    medicalImage<T extends MedicalDocument$medicalImageArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$medicalImageArgs<ExtArgs>>): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    attachments<T extends MedicalDocument$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MedicalDocument model
   */ 
  interface MedicalDocumentFieldRefs {
    readonly id: FieldRef<"MedicalDocument", 'String'>
    readonly patientId: FieldRef<"MedicalDocument", 'String'>
    readonly documentType: FieldRef<"MedicalDocument", 'String'>
    readonly title: FieldRef<"MedicalDocument", 'String'>
    readonly content: FieldRef<"MedicalDocument", 'Json'>
    readonly rawContent: FieldRef<"MedicalDocument", 'String'>
    readonly documentDate: FieldRef<"MedicalDocument", 'DateTime'>
    readonly createdAt: FieldRef<"MedicalDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalDocument", 'DateTime'>
    readonly createdBy: FieldRef<"MedicalDocument", 'String'>
    readonly consultationId: FieldRef<"MedicalDocument", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MedicalDocument findUnique
   */
  export type MedicalDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where: MedicalDocumentWhereUniqueInput
  }


  /**
   * MedicalDocument findUniqueOrThrow
   */
  export type MedicalDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where: MedicalDocumentWhereUniqueInput
  }


  /**
   * MedicalDocument findFirst
   */
  export type MedicalDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalDocuments.
     */
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }


  /**
   * MedicalDocument findFirstOrThrow
   */
  export type MedicalDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalDocuments.
     */
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }


  /**
   * MedicalDocument findMany
   */
  export type MedicalDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocuments to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }


  /**
   * MedicalDocument create
   */
  export type MedicalDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalDocument.
     */
    data: XOR<MedicalDocumentCreateInput, MedicalDocumentUncheckedCreateInput>
  }


  /**
   * MedicalDocument createMany
   */
  export type MedicalDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalDocuments.
     */
    data: MedicalDocumentCreateManyInput | MedicalDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MedicalDocument update
   */
  export type MedicalDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalDocument.
     */
    data: XOR<MedicalDocumentUpdateInput, MedicalDocumentUncheckedUpdateInput>
    /**
     * Choose, which MedicalDocument to update.
     */
    where: MedicalDocumentWhereUniqueInput
  }


  /**
   * MedicalDocument updateMany
   */
  export type MedicalDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalDocuments.
     */
    data: XOR<MedicalDocumentUpdateManyMutationInput, MedicalDocumentUncheckedUpdateManyInput>
    /**
     * Filter which MedicalDocuments to update
     */
    where?: MedicalDocumentWhereInput
  }


  /**
   * MedicalDocument upsert
   */
  export type MedicalDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalDocument to update in case it exists.
     */
    where: MedicalDocumentWhereUniqueInput
    /**
     * In case the MedicalDocument found by the `where` argument doesn't exist, create a new MedicalDocument with this data.
     */
    create: XOR<MedicalDocumentCreateInput, MedicalDocumentUncheckedCreateInput>
    /**
     * In case the MedicalDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalDocumentUpdateInput, MedicalDocumentUncheckedUpdateInput>
  }


  /**
   * MedicalDocument delete
   */
  export type MedicalDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter which MedicalDocument to delete.
     */
    where: MedicalDocumentWhereUniqueInput
  }


  /**
   * MedicalDocument deleteMany
   */
  export type MedicalDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalDocuments to delete
     */
    where?: MedicalDocumentWhereInput
  }


  /**
   * MedicalDocument.consultation
   */
  export type MedicalDocument$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }


  /**
   * MedicalDocument.prescription
   */
  export type MedicalDocument$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }


  /**
   * MedicalDocument.medicalReport
   */
  export type MedicalDocument$medicalReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    where?: MedicalReportWhereInput
  }


  /**
   * MedicalDocument.laboratoryResult
   */
  export type MedicalDocument$laboratoryResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    where?: LaboratoryResultWhereInput
  }


  /**
   * MedicalDocument.medicalImage
   */
  export type MedicalDocument$medicalImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    where?: MedicalImageWhereInput
  }


  /**
   * MedicalDocument.attachments
   */
  export type MedicalDocument$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    cursor?: DocumentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }


  /**
   * MedicalDocument without action
   */
  export type MedicalDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
  }



  /**
   * Model DocumentAttachment
   */

  export type AggregateDocumentAttachment = {
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  export type DocumentAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentAttachmentMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type DocumentAttachmentMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type DocumentAttachmentCountAggregateOutputType = {
    id: number
    documentId: number
    fileName: number
    filePath: number
    mimeType: number
    fileSize: number
    uploadedAt: number
    uploadedBy: number
    _all: number
  }


  export type DocumentAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentAttachmentMinAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type DocumentAttachmentMaxAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type DocumentAttachmentCountAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type DocumentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachment to aggregate.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentAttachments
    **/
    _count?: true | DocumentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type GetDocumentAttachmentAggregateType<T extends DocumentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAttachment[P]>
      : GetScalarType<T[P], AggregateDocumentAttachment[P]>
  }




  export type DocumentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithAggregationInput | DocumentAttachmentOrderByWithAggregationInput[]
    by: DocumentAttachmentScalarFieldEnum[] | DocumentAttachmentScalarFieldEnum
    having?: DocumentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAttachmentCountAggregateInputType | true
    _avg?: DocumentAttachmentAvgAggregateInputType
    _sum?: DocumentAttachmentSumAggregateInputType
    _min?: DocumentAttachmentMinAggregateInputType
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type DocumentAttachmentGroupByOutputType = {
    id: string
    documentId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt: Date
    uploadedBy: string
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  type GetDocumentAttachmentGroupByPayload<T extends DocumentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    document?: boolean | MedicalDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectScalar = {
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
  }

  export type DocumentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | MedicalDocumentDefaultArgs<ExtArgs>
  }


  export type $DocumentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAttachment"
    objects: {
      document: Prisma.$MedicalDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      fileName: string
      filePath: string
      mimeType: string
      fileSize: number
      uploadedAt: Date
      uploadedBy: string
    }, ExtArgs["result"]["documentAttachment"]>
    composites: {}
  }


  type DocumentAttachmentGetPayload<S extends boolean | null | undefined | DocumentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$DocumentAttachmentPayload, S>

  type DocumentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentAttachmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DocumentAttachmentCountAggregateInputType | true
    }

  export interface DocumentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAttachment'], meta: { name: 'DocumentAttachment' } }
    /**
     * Find zero or one DocumentAttachment that matches the filter.
     * @param {DocumentAttachmentFindUniqueArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DocumentAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DocumentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DocumentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DocumentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany()
     * 
     * // Get first 10 DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DocumentAttachment.
     * @param {DocumentAttachmentCreateArgs} args - Arguments to create a DocumentAttachment.
     * @example
     * // Create one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.create({
     *   data: {
     *     // ... data to create a DocumentAttachment
     *   }
     * })
     * 
    **/
    create<T extends DocumentAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentCreateArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DocumentAttachments.
     *     @param {DocumentAttachmentCreateManyArgs} args - Arguments to create many DocumentAttachments.
     *     @example
     *     // Create many DocumentAttachments
     *     const documentAttachment = await prisma.documentAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentAttachment.
     * @param {DocumentAttachmentDeleteArgs} args - Arguments to delete one DocumentAttachment.
     * @example
     * // Delete one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.delete({
     *   where: {
     *     // ... filter to delete one DocumentAttachment
     *   }
     * })
     * 
    **/
    delete<T extends DocumentAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DocumentAttachment.
     * @param {DocumentAttachmentUpdateArgs} args - Arguments to update one DocumentAttachment.
     * @example
     * // Update one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DocumentAttachments.
     * @param {DocumentAttachmentDeleteManyArgs} args - Arguments to filter DocumentAttachments to delete.
     * @example
     * // Delete a few DocumentAttachments
     * const { count } = await prisma.documentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentAttachment.
     * @param {DocumentAttachmentUpsertArgs} args - Arguments to update or create a DocumentAttachment.
     * @example
     * // Update or create a DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.upsert({
     *   create: {
     *     // ... data to create a DocumentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentCountArgs} args - Arguments to filter DocumentAttachments to count.
     * @example
     * // Count the number of DocumentAttachments
     * const count = await prisma.documentAttachment.count({
     *   where: {
     *     // ... the filter for the DocumentAttachments we want to count
     *   }
     * })
    **/
    count<T extends DocumentAttachmentCountArgs>(
      args?: Subset<T, DocumentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAttachmentAggregateArgs>(args: Subset<T, DocumentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAttachmentAggregateType<T>>

    /**
     * Group by DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAttachment model
   */
  readonly fields: DocumentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends MedicalDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocumentDefaultArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DocumentAttachment model
   */ 
  interface DocumentAttachmentFieldRefs {
    readonly id: FieldRef<"DocumentAttachment", 'String'>
    readonly documentId: FieldRef<"DocumentAttachment", 'String'>
    readonly fileName: FieldRef<"DocumentAttachment", 'String'>
    readonly filePath: FieldRef<"DocumentAttachment", 'String'>
    readonly mimeType: FieldRef<"DocumentAttachment", 'String'>
    readonly fileSize: FieldRef<"DocumentAttachment", 'Int'>
    readonly uploadedAt: FieldRef<"DocumentAttachment", 'DateTime'>
    readonly uploadedBy: FieldRef<"DocumentAttachment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DocumentAttachment findUnique
   */
  export type DocumentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }


  /**
   * DocumentAttachment findUniqueOrThrow
   */
  export type DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }


  /**
   * DocumentAttachment findFirst
   */
  export type DocumentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }


  /**
   * DocumentAttachment findFirstOrThrow
   */
  export type DocumentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }


  /**
   * DocumentAttachment findMany
   */
  export type DocumentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachments to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }


  /**
   * DocumentAttachment create
   */
  export type DocumentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
  }


  /**
   * DocumentAttachment createMany
   */
  export type DocumentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentAttachments.
     */
    data: DocumentAttachmentCreateManyInput | DocumentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DocumentAttachment update
   */
  export type DocumentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which DocumentAttachment to update.
     */
    where: DocumentAttachmentWhereUniqueInput
  }


  /**
   * DocumentAttachment updateMany
   */
  export type DocumentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentAttachments.
     */
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAttachments to update
     */
    where?: DocumentAttachmentWhereInput
  }


  /**
   * DocumentAttachment upsert
   */
  export type DocumentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAttachment to update in case it exists.
     */
    where: DocumentAttachmentWhereUniqueInput
    /**
     * In case the DocumentAttachment found by the `where` argument doesn't exist, create a new DocumentAttachment with this data.
     */
    create: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
    /**
     * In case the DocumentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
  }


  /**
   * DocumentAttachment delete
   */
  export type DocumentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which DocumentAttachment to delete.
     */
    where: DocumentAttachmentWhereUniqueInput
  }


  /**
   * DocumentAttachment deleteMany
   */
  export type DocumentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachments to delete
     */
    where?: DocumentAttachmentWhereInput
  }


  /**
   * DocumentAttachment without action
   */
  export type DocumentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    medicationName: string | null
    atcCode: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    status: string | null
    outpassReason: string | null
    documentId: string | null
    createdAt: Date | null
    prescribedBy: string | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    medicationName: string | null
    atcCode: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    status: string | null
    outpassReason: string | null
    documentId: string | null
    createdAt: Date | null
    prescribedBy: string | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientId: number
    medicationName: number
    atcCode: number
    dosage: number
    frequency: number
    duration: number
    status: number
    safetyChecks: number
    outpassReason: number
    documentId: number
    createdAt: number
    prescribedBy: number
    _all: number
  }


  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientId?: true
    medicationName?: true
    atcCode?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    outpassReason?: true
    documentId?: true
    createdAt?: true
    prescribedBy?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientId?: true
    medicationName?: true
    atcCode?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    outpassReason?: true
    documentId?: true
    createdAt?: true
    prescribedBy?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientId?: true
    medicationName?: true
    atcCode?: true
    dosage?: true
    frequency?: true
    duration?: true
    status?: true
    safetyChecks?: true
    outpassReason?: true
    documentId?: true
    createdAt?: true
    prescribedBy?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    patientId: string
    medicationName: string
    atcCode: string | null
    dosage: string
    frequency: string
    duration: string | null
    status: string
    safetyChecks: JsonValue | null
    outpassReason: string | null
    documentId: string | null
    createdAt: Date
    prescribedBy: string
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medicationName?: boolean
    atcCode?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    safetyChecks?: boolean
    outpassReason?: boolean
    documentId?: boolean
    createdAt?: boolean
    prescribedBy?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | Prescription$documentArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientId?: boolean
    medicationName?: boolean
    atcCode?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    status?: boolean
    safetyChecks?: boolean
    outpassReason?: boolean
    documentId?: boolean
    createdAt?: boolean
    prescribedBy?: boolean
  }

  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | Prescription$documentArgs<ExtArgs>
  }


  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      document: Prisma.$MedicalDocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      medicationName: string
      atcCode: string | null
      dosage: string
      frequency: string
      duration: string | null
      status: string
      safetyChecks: Prisma.JsonValue | null
      outpassReason: string | null
      documentId: string | null
      createdAt: Date
      prescribedBy: string
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }


  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrescriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrescriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PrescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
    **/
    create<T extends PrescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Prescriptions.
     *     @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     *     @example
     *     // Create many Prescriptions
     *     const prescription = await prisma.prescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PrescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
    **/
    delete<T extends PrescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
    **/
    upsert<T extends PrescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    document<T extends Prescription$documentArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$documentArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly medicationName: FieldRef<"Prescription", 'String'>
    readonly atcCode: FieldRef<"Prescription", 'String'>
    readonly dosage: FieldRef<"Prescription", 'String'>
    readonly frequency: FieldRef<"Prescription", 'String'>
    readonly duration: FieldRef<"Prescription", 'String'>
    readonly status: FieldRef<"Prescription", 'String'>
    readonly safetyChecks: FieldRef<"Prescription", 'Json'>
    readonly outpassReason: FieldRef<"Prescription", 'String'>
    readonly documentId: FieldRef<"Prescription", 'String'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly prescribedBy: FieldRef<"Prescription", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }


  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }


  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }


  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }


  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }


  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }


  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }


  /**
   * Prescription.document
   */
  export type Prescription$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
  }


  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }



  /**
   * Model MedicalReport
   */

  export type AggregateMedicalReport = {
    _count: MedicalReportCountAggregateOutputType | null
    _min: MedicalReportMinAggregateOutputType | null
    _max: MedicalReportMaxAggregateOutputType | null
  }

  export type MedicalReportMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    reportType: string | null
    title: string | null
    chiefComplaint: string | null
    history: string | null
    examination: string | null
    assessment: string | null
    plan: string | null
    documentId: string | null
    consultationId: string | null
    reportDate: Date | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type MedicalReportMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    reportType: string | null
    title: string | null
    chiefComplaint: string | null
    history: string | null
    examination: string | null
    assessment: string | null
    plan: string | null
    documentId: string | null
    consultationId: string | null
    reportDate: Date | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type MedicalReportCountAggregateOutputType = {
    id: number
    patientId: number
    reportType: number
    title: number
    chiefComplaint: number
    history: number
    examination: number
    assessment: number
    plan: number
    documentId: number
    consultationId: number
    reportDate: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type MedicalReportMinAggregateInputType = {
    id?: true
    patientId?: true
    reportType?: true
    title?: true
    chiefComplaint?: true
    history?: true
    examination?: true
    assessment?: true
    plan?: true
    documentId?: true
    consultationId?: true
    reportDate?: true
    createdAt?: true
    createdBy?: true
  }

  export type MedicalReportMaxAggregateInputType = {
    id?: true
    patientId?: true
    reportType?: true
    title?: true
    chiefComplaint?: true
    history?: true
    examination?: true
    assessment?: true
    plan?: true
    documentId?: true
    consultationId?: true
    reportDate?: true
    createdAt?: true
    createdBy?: true
  }

  export type MedicalReportCountAggregateInputType = {
    id?: true
    patientId?: true
    reportType?: true
    title?: true
    chiefComplaint?: true
    history?: true
    examination?: true
    assessment?: true
    plan?: true
    documentId?: true
    consultationId?: true
    reportDate?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type MedicalReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalReport to aggregate.
     */
    where?: MedicalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalReports to fetch.
     */
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalReports
    **/
    _count?: true | MedicalReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalReportMaxAggregateInputType
  }

  export type GetMedicalReportAggregateType<T extends MedicalReportAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalReport[P]>
      : GetScalarType<T[P], AggregateMedicalReport[P]>
  }




  export type MedicalReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalReportWhereInput
    orderBy?: MedicalReportOrderByWithAggregationInput | MedicalReportOrderByWithAggregationInput[]
    by: MedicalReportScalarFieldEnum[] | MedicalReportScalarFieldEnum
    having?: MedicalReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalReportCountAggregateInputType | true
    _min?: MedicalReportMinAggregateInputType
    _max?: MedicalReportMaxAggregateInputType
  }

  export type MedicalReportGroupByOutputType = {
    id: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint: string | null
    history: string | null
    examination: string | null
    assessment: string | null
    plan: string | null
    documentId: string | null
    consultationId: string | null
    reportDate: Date
    createdAt: Date
    createdBy: string
    _count: MedicalReportCountAggregateOutputType | null
    _min: MedicalReportMinAggregateOutputType | null
    _max: MedicalReportMaxAggregateOutputType | null
  }

  type GetMedicalReportGroupByPayload<T extends MedicalReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalReportGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalReportGroupByOutputType[P]>
        }
      >
    >


  export type MedicalReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reportType?: boolean
    title?: boolean
    chiefComplaint?: boolean
    history?: boolean
    examination?: boolean
    assessment?: boolean
    plan?: boolean
    documentId?: boolean
    consultationId?: boolean
    reportDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | MedicalReport$documentArgs<ExtArgs>
    consultation?: boolean | MedicalReport$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["medicalReport"]>

  export type MedicalReportSelectScalar = {
    id?: boolean
    patientId?: boolean
    reportType?: boolean
    title?: boolean
    chiefComplaint?: boolean
    history?: boolean
    examination?: boolean
    assessment?: boolean
    plan?: boolean
    documentId?: boolean
    consultationId?: boolean
    reportDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type MedicalReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | MedicalReport$documentArgs<ExtArgs>
    consultation?: boolean | MedicalReport$consultationArgs<ExtArgs>
  }


  export type $MedicalReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalReport"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      document: Prisma.$MedicalDocumentPayload<ExtArgs> | null
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      reportType: string
      title: string
      chiefComplaint: string | null
      history: string | null
      examination: string | null
      assessment: string | null
      plan: string | null
      documentId: string | null
      consultationId: string | null
      reportDate: Date
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["medicalReport"]>
    composites: {}
  }


  type MedicalReportGetPayload<S extends boolean | null | undefined | MedicalReportDefaultArgs> = $Result.GetResult<Prisma.$MedicalReportPayload, S>

  type MedicalReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalReportFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MedicalReportCountAggregateInputType | true
    }

  export interface MedicalReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalReport'], meta: { name: 'MedicalReport' } }
    /**
     * Find zero or one MedicalReport that matches the filter.
     * @param {MedicalReportFindUniqueArgs} args - Arguments to find a MedicalReport
     * @example
     * // Get one MedicalReport
     * const medicalReport = await prisma.medicalReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MedicalReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportFindUniqueArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MedicalReport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MedicalReportFindUniqueOrThrowArgs} args - Arguments to find a MedicalReport
     * @example
     * // Get one MedicalReport
     * const medicalReport = await prisma.medicalReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MedicalReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MedicalReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportFindFirstArgs} args - Arguments to find a MedicalReport
     * @example
     * // Get one MedicalReport
     * const medicalReport = await prisma.medicalReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MedicalReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportFindFirstArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MedicalReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportFindFirstOrThrowArgs} args - Arguments to find a MedicalReport
     * @example
     * // Get one MedicalReport
     * const medicalReport = await prisma.medicalReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MedicalReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MedicalReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalReports
     * const medicalReports = await prisma.medicalReport.findMany()
     * 
     * // Get first 10 MedicalReports
     * const medicalReports = await prisma.medicalReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalReportWithIdOnly = await prisma.medicalReport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MedicalReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MedicalReport.
     * @param {MedicalReportCreateArgs} args - Arguments to create a MedicalReport.
     * @example
     * // Create one MedicalReport
     * const MedicalReport = await prisma.medicalReport.create({
     *   data: {
     *     // ... data to create a MedicalReport
     *   }
     * })
     * 
    **/
    create<T extends MedicalReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportCreateArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MedicalReports.
     *     @param {MedicalReportCreateManyArgs} args - Arguments to create many MedicalReports.
     *     @example
     *     // Create many MedicalReports
     *     const medicalReport = await prisma.medicalReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MedicalReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalReport.
     * @param {MedicalReportDeleteArgs} args - Arguments to delete one MedicalReport.
     * @example
     * // Delete one MedicalReport
     * const MedicalReport = await prisma.medicalReport.delete({
     *   where: {
     *     // ... filter to delete one MedicalReport
     *   }
     * })
     * 
    **/
    delete<T extends MedicalReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportDeleteArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MedicalReport.
     * @param {MedicalReportUpdateArgs} args - Arguments to update one MedicalReport.
     * @example
     * // Update one MedicalReport
     * const medicalReport = await prisma.medicalReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MedicalReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportUpdateArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MedicalReports.
     * @param {MedicalReportDeleteManyArgs} args - Arguments to filter MedicalReports to delete.
     * @example
     * // Delete a few MedicalReports
     * const { count } = await prisma.medicalReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MedicalReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalReports
     * const medicalReport = await prisma.medicalReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MedicalReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalReport.
     * @param {MedicalReportUpsertArgs} args - Arguments to update or create a MedicalReport.
     * @example
     * // Update or create a MedicalReport
     * const medicalReport = await prisma.medicalReport.upsert({
     *   create: {
     *     // ... data to create a MedicalReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalReport we want to update
     *   }
     * })
    **/
    upsert<T extends MedicalReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalReportUpsertArgs<ExtArgs>>
    ): Prisma__MedicalReportClient<$Result.GetResult<Prisma.$MedicalReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MedicalReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportCountArgs} args - Arguments to filter MedicalReports to count.
     * @example
     * // Count the number of MedicalReports
     * const count = await prisma.medicalReport.count({
     *   where: {
     *     // ... the filter for the MedicalReports we want to count
     *   }
     * })
    **/
    count<T extends MedicalReportCountArgs>(
      args?: Subset<T, MedicalReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalReportAggregateArgs>(args: Subset<T, MedicalReportAggregateArgs>): Prisma.PrismaPromise<GetMedicalReportAggregateType<T>>

    /**
     * Group by MedicalReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalReportGroupByArgs['orderBy'] }
        : { orderBy?: MedicalReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalReport model
   */
  readonly fields: MedicalReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    document<T extends MedicalReport$documentArgs<ExtArgs> = {}>(args?: Subset<T, MedicalReport$documentArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    consultation<T extends MedicalReport$consultationArgs<ExtArgs> = {}>(args?: Subset<T, MedicalReport$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MedicalReport model
   */ 
  interface MedicalReportFieldRefs {
    readonly id: FieldRef<"MedicalReport", 'String'>
    readonly patientId: FieldRef<"MedicalReport", 'String'>
    readonly reportType: FieldRef<"MedicalReport", 'String'>
    readonly title: FieldRef<"MedicalReport", 'String'>
    readonly chiefComplaint: FieldRef<"MedicalReport", 'String'>
    readonly history: FieldRef<"MedicalReport", 'String'>
    readonly examination: FieldRef<"MedicalReport", 'String'>
    readonly assessment: FieldRef<"MedicalReport", 'String'>
    readonly plan: FieldRef<"MedicalReport", 'String'>
    readonly documentId: FieldRef<"MedicalReport", 'String'>
    readonly consultationId: FieldRef<"MedicalReport", 'String'>
    readonly reportDate: FieldRef<"MedicalReport", 'DateTime'>
    readonly createdAt: FieldRef<"MedicalReport", 'DateTime'>
    readonly createdBy: FieldRef<"MedicalReport", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MedicalReport findUnique
   */
  export type MedicalReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter, which MedicalReport to fetch.
     */
    where: MedicalReportWhereUniqueInput
  }


  /**
   * MedicalReport findUniqueOrThrow
   */
  export type MedicalReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter, which MedicalReport to fetch.
     */
    where: MedicalReportWhereUniqueInput
  }


  /**
   * MedicalReport findFirst
   */
  export type MedicalReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter, which MedicalReport to fetch.
     */
    where?: MedicalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalReports to fetch.
     */
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalReports.
     */
    cursor?: MedicalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalReports.
     */
    distinct?: MedicalReportScalarFieldEnum | MedicalReportScalarFieldEnum[]
  }


  /**
   * MedicalReport findFirstOrThrow
   */
  export type MedicalReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter, which MedicalReport to fetch.
     */
    where?: MedicalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalReports to fetch.
     */
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalReports.
     */
    cursor?: MedicalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalReports.
     */
    distinct?: MedicalReportScalarFieldEnum | MedicalReportScalarFieldEnum[]
  }


  /**
   * MedicalReport findMany
   */
  export type MedicalReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter, which MedicalReports to fetch.
     */
    where?: MedicalReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalReports to fetch.
     */
    orderBy?: MedicalReportOrderByWithRelationInput | MedicalReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalReports.
     */
    cursor?: MedicalReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalReports.
     */
    skip?: number
    distinct?: MedicalReportScalarFieldEnum | MedicalReportScalarFieldEnum[]
  }


  /**
   * MedicalReport create
   */
  export type MedicalReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalReport.
     */
    data: XOR<MedicalReportCreateInput, MedicalReportUncheckedCreateInput>
  }


  /**
   * MedicalReport createMany
   */
  export type MedicalReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalReports.
     */
    data: MedicalReportCreateManyInput | MedicalReportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MedicalReport update
   */
  export type MedicalReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalReport.
     */
    data: XOR<MedicalReportUpdateInput, MedicalReportUncheckedUpdateInput>
    /**
     * Choose, which MedicalReport to update.
     */
    where: MedicalReportWhereUniqueInput
  }


  /**
   * MedicalReport updateMany
   */
  export type MedicalReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalReports.
     */
    data: XOR<MedicalReportUpdateManyMutationInput, MedicalReportUncheckedUpdateManyInput>
    /**
     * Filter which MedicalReports to update
     */
    where?: MedicalReportWhereInput
  }


  /**
   * MedicalReport upsert
   */
  export type MedicalReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalReport to update in case it exists.
     */
    where: MedicalReportWhereUniqueInput
    /**
     * In case the MedicalReport found by the `where` argument doesn't exist, create a new MedicalReport with this data.
     */
    create: XOR<MedicalReportCreateInput, MedicalReportUncheckedCreateInput>
    /**
     * In case the MedicalReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalReportUpdateInput, MedicalReportUncheckedUpdateInput>
  }


  /**
   * MedicalReport delete
   */
  export type MedicalReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
    /**
     * Filter which MedicalReport to delete.
     */
    where: MedicalReportWhereUniqueInput
  }


  /**
   * MedicalReport deleteMany
   */
  export type MedicalReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalReports to delete
     */
    where?: MedicalReportWhereInput
  }


  /**
   * MedicalReport.document
   */
  export type MedicalReport$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
  }


  /**
   * MedicalReport.consultation
   */
  export type MedicalReport$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }


  /**
   * MedicalReport without action
   */
  export type MedicalReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalReport
     */
    select?: MedicalReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalReportInclude<ExtArgs> | null
  }



  /**
   * Model LaboratoryResult
   */

  export type AggregateLaboratoryResult = {
    _count: LaboratoryResultCountAggregateOutputType | null
    _min: LaboratoryResultMinAggregateOutputType | null
    _max: LaboratoryResultMaxAggregateOutputType | null
  }

  export type LaboratoryResultMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    testName: string | null
    testCode: string | null
    resultValue: string | null
    unit: string | null
    referenceRange: string | null
    status: string | null
    testDate: Date | null
    receivedAt: Date | null
    laboratoryName: string | null
    documentId: string | null
  }

  export type LaboratoryResultMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    testName: string | null
    testCode: string | null
    resultValue: string | null
    unit: string | null
    referenceRange: string | null
    status: string | null
    testDate: Date | null
    receivedAt: Date | null
    laboratoryName: string | null
    documentId: string | null
  }

  export type LaboratoryResultCountAggregateOutputType = {
    id: number
    patientId: number
    testName: number
    testCode: number
    resultValue: number
    unit: number
    referenceRange: number
    status: number
    testDate: number
    receivedAt: number
    laboratoryName: number
    documentId: number
    _all: number
  }


  export type LaboratoryResultMinAggregateInputType = {
    id?: true
    patientId?: true
    testName?: true
    testCode?: true
    resultValue?: true
    unit?: true
    referenceRange?: true
    status?: true
    testDate?: true
    receivedAt?: true
    laboratoryName?: true
    documentId?: true
  }

  export type LaboratoryResultMaxAggregateInputType = {
    id?: true
    patientId?: true
    testName?: true
    testCode?: true
    resultValue?: true
    unit?: true
    referenceRange?: true
    status?: true
    testDate?: true
    receivedAt?: true
    laboratoryName?: true
    documentId?: true
  }

  export type LaboratoryResultCountAggregateInputType = {
    id?: true
    patientId?: true
    testName?: true
    testCode?: true
    resultValue?: true
    unit?: true
    referenceRange?: true
    status?: true
    testDate?: true
    receivedAt?: true
    laboratoryName?: true
    documentId?: true
    _all?: true
  }

  export type LaboratoryResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaboratoryResult to aggregate.
     */
    where?: LaboratoryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryResults to fetch.
     */
    orderBy?: LaboratoryResultOrderByWithRelationInput | LaboratoryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaboratoryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaboratoryResults
    **/
    _count?: true | LaboratoryResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaboratoryResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaboratoryResultMaxAggregateInputType
  }

  export type GetLaboratoryResultAggregateType<T extends LaboratoryResultAggregateArgs> = {
        [P in keyof T & keyof AggregateLaboratoryResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaboratoryResult[P]>
      : GetScalarType<T[P], AggregateLaboratoryResult[P]>
  }




  export type LaboratoryResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaboratoryResultWhereInput
    orderBy?: LaboratoryResultOrderByWithAggregationInput | LaboratoryResultOrderByWithAggregationInput[]
    by: LaboratoryResultScalarFieldEnum[] | LaboratoryResultScalarFieldEnum
    having?: LaboratoryResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaboratoryResultCountAggregateInputType | true
    _min?: LaboratoryResultMinAggregateInputType
    _max?: LaboratoryResultMaxAggregateInputType
  }

  export type LaboratoryResultGroupByOutputType = {
    id: string
    patientId: string
    testName: string
    testCode: string | null
    resultValue: string
    unit: string | null
    referenceRange: string | null
    status: string
    testDate: Date
    receivedAt: Date
    laboratoryName: string | null
    documentId: string | null
    _count: LaboratoryResultCountAggregateOutputType | null
    _min: LaboratoryResultMinAggregateOutputType | null
    _max: LaboratoryResultMaxAggregateOutputType | null
  }

  type GetLaboratoryResultGroupByPayload<T extends LaboratoryResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaboratoryResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaboratoryResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaboratoryResultGroupByOutputType[P]>
            : GetScalarType<T[P], LaboratoryResultGroupByOutputType[P]>
        }
      >
    >


  export type LaboratoryResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    testName?: boolean
    testCode?: boolean
    resultValue?: boolean
    unit?: boolean
    referenceRange?: boolean
    status?: boolean
    testDate?: boolean
    receivedAt?: boolean
    laboratoryName?: boolean
    documentId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | LaboratoryResult$documentArgs<ExtArgs>
  }, ExtArgs["result"]["laboratoryResult"]>

  export type LaboratoryResultSelectScalar = {
    id?: boolean
    patientId?: boolean
    testName?: boolean
    testCode?: boolean
    resultValue?: boolean
    unit?: boolean
    referenceRange?: boolean
    status?: boolean
    testDate?: boolean
    receivedAt?: boolean
    laboratoryName?: boolean
    documentId?: boolean
  }

  export type LaboratoryResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | LaboratoryResult$documentArgs<ExtArgs>
  }


  export type $LaboratoryResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaboratoryResult"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      document: Prisma.$MedicalDocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      testName: string
      testCode: string | null
      resultValue: string
      unit: string | null
      referenceRange: string | null
      status: string
      testDate: Date
      receivedAt: Date
      laboratoryName: string | null
      documentId: string | null
    }, ExtArgs["result"]["laboratoryResult"]>
    composites: {}
  }


  type LaboratoryResultGetPayload<S extends boolean | null | undefined | LaboratoryResultDefaultArgs> = $Result.GetResult<Prisma.$LaboratoryResultPayload, S>

  type LaboratoryResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LaboratoryResultFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LaboratoryResultCountAggregateInputType | true
    }

  export interface LaboratoryResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaboratoryResult'], meta: { name: 'LaboratoryResult' } }
    /**
     * Find zero or one LaboratoryResult that matches the filter.
     * @param {LaboratoryResultFindUniqueArgs} args - Arguments to find a LaboratoryResult
     * @example
     * // Get one LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaboratoryResultFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultFindUniqueArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LaboratoryResult that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaboratoryResultFindUniqueOrThrowArgs} args - Arguments to find a LaboratoryResult
     * @example
     * // Get one LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaboratoryResultFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LaboratoryResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultFindFirstArgs} args - Arguments to find a LaboratoryResult
     * @example
     * // Get one LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaboratoryResultFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultFindFirstArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LaboratoryResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultFindFirstOrThrowArgs} args - Arguments to find a LaboratoryResult
     * @example
     * // Get one LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaboratoryResultFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LaboratoryResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaboratoryResults
     * const laboratoryResults = await prisma.laboratoryResult.findMany()
     * 
     * // Get first 10 LaboratoryResults
     * const laboratoryResults = await prisma.laboratoryResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laboratoryResultWithIdOnly = await prisma.laboratoryResult.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaboratoryResultFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LaboratoryResult.
     * @param {LaboratoryResultCreateArgs} args - Arguments to create a LaboratoryResult.
     * @example
     * // Create one LaboratoryResult
     * const LaboratoryResult = await prisma.laboratoryResult.create({
     *   data: {
     *     // ... data to create a LaboratoryResult
     *   }
     * })
     * 
    **/
    create<T extends LaboratoryResultCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultCreateArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LaboratoryResults.
     *     @param {LaboratoryResultCreateManyArgs} args - Arguments to create many LaboratoryResults.
     *     @example
     *     // Create many LaboratoryResults
     *     const laboratoryResult = await prisma.laboratoryResult.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaboratoryResultCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaboratoryResult.
     * @param {LaboratoryResultDeleteArgs} args - Arguments to delete one LaboratoryResult.
     * @example
     * // Delete one LaboratoryResult
     * const LaboratoryResult = await prisma.laboratoryResult.delete({
     *   where: {
     *     // ... filter to delete one LaboratoryResult
     *   }
     * })
     * 
    **/
    delete<T extends LaboratoryResultDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultDeleteArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LaboratoryResult.
     * @param {LaboratoryResultUpdateArgs} args - Arguments to update one LaboratoryResult.
     * @example
     * // Update one LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaboratoryResultUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultUpdateArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LaboratoryResults.
     * @param {LaboratoryResultDeleteManyArgs} args - Arguments to filter LaboratoryResults to delete.
     * @example
     * // Delete a few LaboratoryResults
     * const { count } = await prisma.laboratoryResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaboratoryResultDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaboratoryResultDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaboratoryResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaboratoryResults
     * const laboratoryResult = await prisma.laboratoryResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaboratoryResultUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaboratoryResult.
     * @param {LaboratoryResultUpsertArgs} args - Arguments to update or create a LaboratoryResult.
     * @example
     * // Update or create a LaboratoryResult
     * const laboratoryResult = await prisma.laboratoryResult.upsert({
     *   create: {
     *     // ... data to create a LaboratoryResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaboratoryResult we want to update
     *   }
     * })
    **/
    upsert<T extends LaboratoryResultUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LaboratoryResultUpsertArgs<ExtArgs>>
    ): Prisma__LaboratoryResultClient<$Result.GetResult<Prisma.$LaboratoryResultPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LaboratoryResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultCountArgs} args - Arguments to filter LaboratoryResults to count.
     * @example
     * // Count the number of LaboratoryResults
     * const count = await prisma.laboratoryResult.count({
     *   where: {
     *     // ... the filter for the LaboratoryResults we want to count
     *   }
     * })
    **/
    count<T extends LaboratoryResultCountArgs>(
      args?: Subset<T, LaboratoryResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaboratoryResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaboratoryResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaboratoryResultAggregateArgs>(args: Subset<T, LaboratoryResultAggregateArgs>): Prisma.PrismaPromise<GetLaboratoryResultAggregateType<T>>

    /**
     * Group by LaboratoryResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaboratoryResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaboratoryResultGroupByArgs['orderBy'] }
        : { orderBy?: LaboratoryResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaboratoryResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaboratoryResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaboratoryResult model
   */
  readonly fields: LaboratoryResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaboratoryResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaboratoryResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    document<T extends LaboratoryResult$documentArgs<ExtArgs> = {}>(args?: Subset<T, LaboratoryResult$documentArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LaboratoryResult model
   */ 
  interface LaboratoryResultFieldRefs {
    readonly id: FieldRef<"LaboratoryResult", 'String'>
    readonly patientId: FieldRef<"LaboratoryResult", 'String'>
    readonly testName: FieldRef<"LaboratoryResult", 'String'>
    readonly testCode: FieldRef<"LaboratoryResult", 'String'>
    readonly resultValue: FieldRef<"LaboratoryResult", 'String'>
    readonly unit: FieldRef<"LaboratoryResult", 'String'>
    readonly referenceRange: FieldRef<"LaboratoryResult", 'String'>
    readonly status: FieldRef<"LaboratoryResult", 'String'>
    readonly testDate: FieldRef<"LaboratoryResult", 'DateTime'>
    readonly receivedAt: FieldRef<"LaboratoryResult", 'DateTime'>
    readonly laboratoryName: FieldRef<"LaboratoryResult", 'String'>
    readonly documentId: FieldRef<"LaboratoryResult", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LaboratoryResult findUnique
   */
  export type LaboratoryResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryResult to fetch.
     */
    where: LaboratoryResultWhereUniqueInput
  }


  /**
   * LaboratoryResult findUniqueOrThrow
   */
  export type LaboratoryResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryResult to fetch.
     */
    where: LaboratoryResultWhereUniqueInput
  }


  /**
   * LaboratoryResult findFirst
   */
  export type LaboratoryResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryResult to fetch.
     */
    where?: LaboratoryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryResults to fetch.
     */
    orderBy?: LaboratoryResultOrderByWithRelationInput | LaboratoryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaboratoryResults.
     */
    cursor?: LaboratoryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaboratoryResults.
     */
    distinct?: LaboratoryResultScalarFieldEnum | LaboratoryResultScalarFieldEnum[]
  }


  /**
   * LaboratoryResult findFirstOrThrow
   */
  export type LaboratoryResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryResult to fetch.
     */
    where?: LaboratoryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryResults to fetch.
     */
    orderBy?: LaboratoryResultOrderByWithRelationInput | LaboratoryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaboratoryResults.
     */
    cursor?: LaboratoryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaboratoryResults.
     */
    distinct?: LaboratoryResultScalarFieldEnum | LaboratoryResultScalarFieldEnum[]
  }


  /**
   * LaboratoryResult findMany
   */
  export type LaboratoryResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryResults to fetch.
     */
    where?: LaboratoryResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryResults to fetch.
     */
    orderBy?: LaboratoryResultOrderByWithRelationInput | LaboratoryResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaboratoryResults.
     */
    cursor?: LaboratoryResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryResults.
     */
    skip?: number
    distinct?: LaboratoryResultScalarFieldEnum | LaboratoryResultScalarFieldEnum[]
  }


  /**
   * LaboratoryResult create
   */
  export type LaboratoryResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * The data needed to create a LaboratoryResult.
     */
    data: XOR<LaboratoryResultCreateInput, LaboratoryResultUncheckedCreateInput>
  }


  /**
   * LaboratoryResult createMany
   */
  export type LaboratoryResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaboratoryResults.
     */
    data: LaboratoryResultCreateManyInput | LaboratoryResultCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LaboratoryResult update
   */
  export type LaboratoryResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * The data needed to update a LaboratoryResult.
     */
    data: XOR<LaboratoryResultUpdateInput, LaboratoryResultUncheckedUpdateInput>
    /**
     * Choose, which LaboratoryResult to update.
     */
    where: LaboratoryResultWhereUniqueInput
  }


  /**
   * LaboratoryResult updateMany
   */
  export type LaboratoryResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaboratoryResults.
     */
    data: XOR<LaboratoryResultUpdateManyMutationInput, LaboratoryResultUncheckedUpdateManyInput>
    /**
     * Filter which LaboratoryResults to update
     */
    where?: LaboratoryResultWhereInput
  }


  /**
   * LaboratoryResult upsert
   */
  export type LaboratoryResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * The filter to search for the LaboratoryResult to update in case it exists.
     */
    where: LaboratoryResultWhereUniqueInput
    /**
     * In case the LaboratoryResult found by the `where` argument doesn't exist, create a new LaboratoryResult with this data.
     */
    create: XOR<LaboratoryResultCreateInput, LaboratoryResultUncheckedCreateInput>
    /**
     * In case the LaboratoryResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaboratoryResultUpdateInput, LaboratoryResultUncheckedUpdateInput>
  }


  /**
   * LaboratoryResult delete
   */
  export type LaboratoryResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
    /**
     * Filter which LaboratoryResult to delete.
     */
    where: LaboratoryResultWhereUniqueInput
  }


  /**
   * LaboratoryResult deleteMany
   */
  export type LaboratoryResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaboratoryResults to delete
     */
    where?: LaboratoryResultWhereInput
  }


  /**
   * LaboratoryResult.document
   */
  export type LaboratoryResult$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
  }


  /**
   * LaboratoryResult without action
   */
  export type LaboratoryResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryResult
     */
    select?: LaboratoryResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaboratoryResultInclude<ExtArgs> | null
  }



  /**
   * Model MedicalImage
   */

  export type AggregateMedicalImage = {
    _count: MedicalImageCountAggregateOutputType | null
    _avg: MedicalImageAvgAggregateOutputType | null
    _sum: MedicalImageSumAggregateOutputType | null
    _min: MedicalImageMinAggregateOutputType | null
    _max: MedicalImageMaxAggregateOutputType | null
  }

  export type MedicalImageAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MedicalImageSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MedicalImageMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    studyInstanceUid: string | null
    seriesInstanceUid: string | null
    sopInstanceUid: string | null
    modality: string | null
    bodyPart: string | null
    studyDescription: string | null
    seriesDescription: string | null
    filePath: string | null
    fileSize: number | null
    documentId: string | null
    acquisitionDate: Date | null
    createdAt: Date | null
  }

  export type MedicalImageMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    studyInstanceUid: string | null
    seriesInstanceUid: string | null
    sopInstanceUid: string | null
    modality: string | null
    bodyPart: string | null
    studyDescription: string | null
    seriesDescription: string | null
    filePath: string | null
    fileSize: number | null
    documentId: string | null
    acquisitionDate: Date | null
    createdAt: Date | null
  }

  export type MedicalImageCountAggregateOutputType = {
    id: number
    patientId: number
    studyInstanceUid: number
    seriesInstanceUid: number
    sopInstanceUid: number
    modality: number
    bodyPart: number
    studyDescription: number
    seriesDescription: number
    filePath: number
    fileSize: number
    documentId: number
    acquisitionDate: number
    createdAt: number
    _all: number
  }


  export type MedicalImageAvgAggregateInputType = {
    fileSize?: true
  }

  export type MedicalImageSumAggregateInputType = {
    fileSize?: true
  }

  export type MedicalImageMinAggregateInputType = {
    id?: true
    patientId?: true
    studyInstanceUid?: true
    seriesInstanceUid?: true
    sopInstanceUid?: true
    modality?: true
    bodyPart?: true
    studyDescription?: true
    seriesDescription?: true
    filePath?: true
    fileSize?: true
    documentId?: true
    acquisitionDate?: true
    createdAt?: true
  }

  export type MedicalImageMaxAggregateInputType = {
    id?: true
    patientId?: true
    studyInstanceUid?: true
    seriesInstanceUid?: true
    sopInstanceUid?: true
    modality?: true
    bodyPart?: true
    studyDescription?: true
    seriesDescription?: true
    filePath?: true
    fileSize?: true
    documentId?: true
    acquisitionDate?: true
    createdAt?: true
  }

  export type MedicalImageCountAggregateInputType = {
    id?: true
    patientId?: true
    studyInstanceUid?: true
    seriesInstanceUid?: true
    sopInstanceUid?: true
    modality?: true
    bodyPart?: true
    studyDescription?: true
    seriesDescription?: true
    filePath?: true
    fileSize?: true
    documentId?: true
    acquisitionDate?: true
    createdAt?: true
    _all?: true
  }

  export type MedicalImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalImage to aggregate.
     */
    where?: MedicalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalImages to fetch.
     */
    orderBy?: MedicalImageOrderByWithRelationInput | MedicalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalImages
    **/
    _count?: true | MedicalImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalImageMaxAggregateInputType
  }

  export type GetMedicalImageAggregateType<T extends MedicalImageAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalImage[P]>
      : GetScalarType<T[P], AggregateMedicalImage[P]>
  }




  export type MedicalImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalImageWhereInput
    orderBy?: MedicalImageOrderByWithAggregationInput | MedicalImageOrderByWithAggregationInput[]
    by: MedicalImageScalarFieldEnum[] | MedicalImageScalarFieldEnum
    having?: MedicalImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalImageCountAggregateInputType | true
    _avg?: MedicalImageAvgAggregateInputType
    _sum?: MedicalImageSumAggregateInputType
    _min?: MedicalImageMinAggregateInputType
    _max?: MedicalImageMaxAggregateInputType
  }

  export type MedicalImageGroupByOutputType = {
    id: string
    patientId: string
    studyInstanceUid: string
    seriesInstanceUid: string | null
    sopInstanceUid: string | null
    modality: string
    bodyPart: string | null
    studyDescription: string | null
    seriesDescription: string | null
    filePath: string
    fileSize: number
    documentId: string | null
    acquisitionDate: Date
    createdAt: Date
    _count: MedicalImageCountAggregateOutputType | null
    _avg: MedicalImageAvgAggregateOutputType | null
    _sum: MedicalImageSumAggregateOutputType | null
    _min: MedicalImageMinAggregateOutputType | null
    _max: MedicalImageMaxAggregateOutputType | null
  }

  type GetMedicalImageGroupByPayload<T extends MedicalImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalImageGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalImageGroupByOutputType[P]>
        }
      >
    >


  export type MedicalImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    studyInstanceUid?: boolean
    seriesInstanceUid?: boolean
    sopInstanceUid?: boolean
    modality?: boolean
    bodyPart?: boolean
    studyDescription?: boolean
    seriesDescription?: boolean
    filePath?: boolean
    fileSize?: boolean
    documentId?: boolean
    acquisitionDate?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | MedicalImage$documentArgs<ExtArgs>
  }, ExtArgs["result"]["medicalImage"]>

  export type MedicalImageSelectScalar = {
    id?: boolean
    patientId?: boolean
    studyInstanceUid?: boolean
    seriesInstanceUid?: boolean
    sopInstanceUid?: boolean
    modality?: boolean
    bodyPart?: boolean
    studyDescription?: boolean
    seriesDescription?: boolean
    filePath?: boolean
    fileSize?: boolean
    documentId?: boolean
    acquisitionDate?: boolean
    createdAt?: boolean
  }

  export type MedicalImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    document?: boolean | MedicalImage$documentArgs<ExtArgs>
  }


  export type $MedicalImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalImage"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      document: Prisma.$MedicalDocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      studyInstanceUid: string
      seriesInstanceUid: string | null
      sopInstanceUid: string | null
      modality: string
      bodyPart: string | null
      studyDescription: string | null
      seriesDescription: string | null
      filePath: string
      fileSize: number
      documentId: string | null
      acquisitionDate: Date
      createdAt: Date
    }, ExtArgs["result"]["medicalImage"]>
    composites: {}
  }


  type MedicalImageGetPayload<S extends boolean | null | undefined | MedicalImageDefaultArgs> = $Result.GetResult<Prisma.$MedicalImagePayload, S>

  type MedicalImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalImageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MedicalImageCountAggregateInputType | true
    }

  export interface MedicalImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalImage'], meta: { name: 'MedicalImage' } }
    /**
     * Find zero or one MedicalImage that matches the filter.
     * @param {MedicalImageFindUniqueArgs} args - Arguments to find a MedicalImage
     * @example
     * // Get one MedicalImage
     * const medicalImage = await prisma.medicalImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MedicalImageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageFindUniqueArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MedicalImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MedicalImageFindUniqueOrThrowArgs} args - Arguments to find a MedicalImage
     * @example
     * // Get one MedicalImage
     * const medicalImage = await prisma.medicalImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MedicalImageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MedicalImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageFindFirstArgs} args - Arguments to find a MedicalImage
     * @example
     * // Get one MedicalImage
     * const medicalImage = await prisma.medicalImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MedicalImageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageFindFirstArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MedicalImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageFindFirstOrThrowArgs} args - Arguments to find a MedicalImage
     * @example
     * // Get one MedicalImage
     * const medicalImage = await prisma.medicalImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MedicalImageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MedicalImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalImages
     * const medicalImages = await prisma.medicalImage.findMany()
     * 
     * // Get first 10 MedicalImages
     * const medicalImages = await prisma.medicalImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalImageWithIdOnly = await prisma.medicalImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MedicalImageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MedicalImage.
     * @param {MedicalImageCreateArgs} args - Arguments to create a MedicalImage.
     * @example
     * // Create one MedicalImage
     * const MedicalImage = await prisma.medicalImage.create({
     *   data: {
     *     // ... data to create a MedicalImage
     *   }
     * })
     * 
    **/
    create<T extends MedicalImageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageCreateArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MedicalImages.
     *     @param {MedicalImageCreateManyArgs} args - Arguments to create many MedicalImages.
     *     @example
     *     // Create many MedicalImages
     *     const medicalImage = await prisma.medicalImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MedicalImageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalImage.
     * @param {MedicalImageDeleteArgs} args - Arguments to delete one MedicalImage.
     * @example
     * // Delete one MedicalImage
     * const MedicalImage = await prisma.medicalImage.delete({
     *   where: {
     *     // ... filter to delete one MedicalImage
     *   }
     * })
     * 
    **/
    delete<T extends MedicalImageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageDeleteArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MedicalImage.
     * @param {MedicalImageUpdateArgs} args - Arguments to update one MedicalImage.
     * @example
     * // Update one MedicalImage
     * const medicalImage = await prisma.medicalImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MedicalImageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageUpdateArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MedicalImages.
     * @param {MedicalImageDeleteManyArgs} args - Arguments to filter MedicalImages to delete.
     * @example
     * // Delete a few MedicalImages
     * const { count } = await prisma.medicalImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MedicalImageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalImages
     * const medicalImage = await prisma.medicalImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MedicalImageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalImage.
     * @param {MedicalImageUpsertArgs} args - Arguments to update or create a MedicalImage.
     * @example
     * // Update or create a MedicalImage
     * const medicalImage = await prisma.medicalImage.upsert({
     *   create: {
     *     // ... data to create a MedicalImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalImage we want to update
     *   }
     * })
    **/
    upsert<T extends MedicalImageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalImageUpsertArgs<ExtArgs>>
    ): Prisma__MedicalImageClient<$Result.GetResult<Prisma.$MedicalImagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MedicalImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageCountArgs} args - Arguments to filter MedicalImages to count.
     * @example
     * // Count the number of MedicalImages
     * const count = await prisma.medicalImage.count({
     *   where: {
     *     // ... the filter for the MedicalImages we want to count
     *   }
     * })
    **/
    count<T extends MedicalImageCountArgs>(
      args?: Subset<T, MedicalImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalImageAggregateArgs>(args: Subset<T, MedicalImageAggregateArgs>): Prisma.PrismaPromise<GetMedicalImageAggregateType<T>>

    /**
     * Group by MedicalImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalImageGroupByArgs['orderBy'] }
        : { orderBy?: MedicalImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalImage model
   */
  readonly fields: MedicalImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    document<T extends MedicalImage$documentArgs<ExtArgs> = {}>(args?: Subset<T, MedicalImage$documentArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MedicalImage model
   */ 
  interface MedicalImageFieldRefs {
    readonly id: FieldRef<"MedicalImage", 'String'>
    readonly patientId: FieldRef<"MedicalImage", 'String'>
    readonly studyInstanceUid: FieldRef<"MedicalImage", 'String'>
    readonly seriesInstanceUid: FieldRef<"MedicalImage", 'String'>
    readonly sopInstanceUid: FieldRef<"MedicalImage", 'String'>
    readonly modality: FieldRef<"MedicalImage", 'String'>
    readonly bodyPart: FieldRef<"MedicalImage", 'String'>
    readonly studyDescription: FieldRef<"MedicalImage", 'String'>
    readonly seriesDescription: FieldRef<"MedicalImage", 'String'>
    readonly filePath: FieldRef<"MedicalImage", 'String'>
    readonly fileSize: FieldRef<"MedicalImage", 'Int'>
    readonly documentId: FieldRef<"MedicalImage", 'String'>
    readonly acquisitionDate: FieldRef<"MedicalImage", 'DateTime'>
    readonly createdAt: FieldRef<"MedicalImage", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MedicalImage findUnique
   */
  export type MedicalImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter, which MedicalImage to fetch.
     */
    where: MedicalImageWhereUniqueInput
  }


  /**
   * MedicalImage findUniqueOrThrow
   */
  export type MedicalImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter, which MedicalImage to fetch.
     */
    where: MedicalImageWhereUniqueInput
  }


  /**
   * MedicalImage findFirst
   */
  export type MedicalImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter, which MedicalImage to fetch.
     */
    where?: MedicalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalImages to fetch.
     */
    orderBy?: MedicalImageOrderByWithRelationInput | MedicalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalImages.
     */
    cursor?: MedicalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalImages.
     */
    distinct?: MedicalImageScalarFieldEnum | MedicalImageScalarFieldEnum[]
  }


  /**
   * MedicalImage findFirstOrThrow
   */
  export type MedicalImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter, which MedicalImage to fetch.
     */
    where?: MedicalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalImages to fetch.
     */
    orderBy?: MedicalImageOrderByWithRelationInput | MedicalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalImages.
     */
    cursor?: MedicalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalImages.
     */
    distinct?: MedicalImageScalarFieldEnum | MedicalImageScalarFieldEnum[]
  }


  /**
   * MedicalImage findMany
   */
  export type MedicalImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter, which MedicalImages to fetch.
     */
    where?: MedicalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalImages to fetch.
     */
    orderBy?: MedicalImageOrderByWithRelationInput | MedicalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalImages.
     */
    cursor?: MedicalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalImages.
     */
    skip?: number
    distinct?: MedicalImageScalarFieldEnum | MedicalImageScalarFieldEnum[]
  }


  /**
   * MedicalImage create
   */
  export type MedicalImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalImage.
     */
    data: XOR<MedicalImageCreateInput, MedicalImageUncheckedCreateInput>
  }


  /**
   * MedicalImage createMany
   */
  export type MedicalImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalImages.
     */
    data: MedicalImageCreateManyInput | MedicalImageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MedicalImage update
   */
  export type MedicalImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalImage.
     */
    data: XOR<MedicalImageUpdateInput, MedicalImageUncheckedUpdateInput>
    /**
     * Choose, which MedicalImage to update.
     */
    where: MedicalImageWhereUniqueInput
  }


  /**
   * MedicalImage updateMany
   */
  export type MedicalImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalImages.
     */
    data: XOR<MedicalImageUpdateManyMutationInput, MedicalImageUncheckedUpdateManyInput>
    /**
     * Filter which MedicalImages to update
     */
    where?: MedicalImageWhereInput
  }


  /**
   * MedicalImage upsert
   */
  export type MedicalImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalImage to update in case it exists.
     */
    where: MedicalImageWhereUniqueInput
    /**
     * In case the MedicalImage found by the `where` argument doesn't exist, create a new MedicalImage with this data.
     */
    create: XOR<MedicalImageCreateInput, MedicalImageUncheckedCreateInput>
    /**
     * In case the MedicalImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalImageUpdateInput, MedicalImageUncheckedUpdateInput>
  }


  /**
   * MedicalImage delete
   */
  export type MedicalImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
    /**
     * Filter which MedicalImage to delete.
     */
    where: MedicalImageWhereUniqueInput
  }


  /**
   * MedicalImage deleteMany
   */
  export type MedicalImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalImages to delete
     */
    where?: MedicalImageWhereInput
  }


  /**
   * MedicalImage.document
   */
  export type MedicalImage$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
  }


  /**
   * MedicalImage without action
   */
  export type MedicalImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalImage
     */
    select?: MedicalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalImageInclude<ExtArgs> | null
  }



  /**
   * Model FeedbackEvent
   */

  export type AggregateFeedbackEvent = {
    _count: FeedbackEventCountAggregateOutputType | null
    _min: FeedbackEventMinAggregateOutputType | null
    _max: FeedbackEventMaxAggregateOutputType | null
  }

  export type FeedbackEventMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    correctionReason: string | null
    createdAt: Date | null
    correctedBy: string | null
  }

  export type FeedbackEventMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    correctionReason: string | null
    createdAt: Date | null
    correctedBy: string | null
  }

  export type FeedbackEventCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    originalValue: number
    correctedValue: number
    correctionReason: number
    createdAt: number
    correctedBy: number
    _all: number
  }


  export type FeedbackEventMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    correctionReason?: true
    createdAt?: true
    correctedBy?: true
  }

  export type FeedbackEventMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    correctionReason?: true
    createdAt?: true
    correctedBy?: true
  }

  export type FeedbackEventCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    originalValue?: true
    correctedValue?: true
    correctionReason?: true
    createdAt?: true
    correctedBy?: true
    _all?: true
  }

  export type FeedbackEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackEvent to aggregate.
     */
    where?: FeedbackEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackEvents to fetch.
     */
    orderBy?: FeedbackEventOrderByWithRelationInput | FeedbackEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackEvents
    **/
    _count?: true | FeedbackEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackEventMaxAggregateInputType
  }

  export type GetFeedbackEventAggregateType<T extends FeedbackEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackEvent[P]>
      : GetScalarType<T[P], AggregateFeedbackEvent[P]>
  }




  export type FeedbackEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackEventWhereInput
    orderBy?: FeedbackEventOrderByWithAggregationInput | FeedbackEventOrderByWithAggregationInput[]
    by: FeedbackEventScalarFieldEnum[] | FeedbackEventScalarFieldEnum
    having?: FeedbackEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackEventCountAggregateInputType | true
    _min?: FeedbackEventMinAggregateInputType
    _max?: FeedbackEventMaxAggregateInputType
  }

  export type FeedbackEventGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    originalValue: JsonValue
    correctedValue: JsonValue
    correctionReason: string | null
    createdAt: Date
    correctedBy: string
    _count: FeedbackEventCountAggregateOutputType | null
    _min: FeedbackEventMinAggregateOutputType | null
    _max: FeedbackEventMaxAggregateOutputType | null
  }

  type GetFeedbackEventGroupByPayload<T extends FeedbackEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackEventGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackEventGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    originalValue?: boolean
    correctedValue?: boolean
    correctionReason?: boolean
    createdAt?: boolean
    correctedBy?: boolean
  }, ExtArgs["result"]["feedbackEvent"]>

  export type FeedbackEventSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    originalValue?: boolean
    correctedValue?: boolean
    correctionReason?: boolean
    createdAt?: boolean
    correctedBy?: boolean
  }


  export type $FeedbackEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      originalValue: Prisma.JsonValue
      correctedValue: Prisma.JsonValue
      correctionReason: string | null
      createdAt: Date
      correctedBy: string
    }, ExtArgs["result"]["feedbackEvent"]>
    composites: {}
  }


  type FeedbackEventGetPayload<S extends boolean | null | undefined | FeedbackEventDefaultArgs> = $Result.GetResult<Prisma.$FeedbackEventPayload, S>

  type FeedbackEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackEventFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackEventCountAggregateInputType | true
    }

  export interface FeedbackEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackEvent'], meta: { name: 'FeedbackEvent' } }
    /**
     * Find zero or one FeedbackEvent that matches the filter.
     * @param {FeedbackEventFindUniqueArgs} args - Arguments to find a FeedbackEvent
     * @example
     * // Get one FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeedbackEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackEventFindUniqueOrThrowArgs} args - Arguments to find a FeedbackEvent
     * @example
     * // Get one FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeedbackEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventFindFirstArgs} args - Arguments to find a FeedbackEvent
     * @example
     * // Get one FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeedbackEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventFindFirstOrThrowArgs} args - Arguments to find a FeedbackEvent
     * @example
     * // Get one FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeedbackEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackEvents
     * const feedbackEvents = await prisma.feedbackEvent.findMany()
     * 
     * // Get first 10 FeedbackEvents
     * const feedbackEvents = await prisma.feedbackEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackEventWithIdOnly = await prisma.feedbackEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeedbackEvent.
     * @param {FeedbackEventCreateArgs} args - Arguments to create a FeedbackEvent.
     * @example
     * // Create one FeedbackEvent
     * const FeedbackEvent = await prisma.feedbackEvent.create({
     *   data: {
     *     // ... data to create a FeedbackEvent
     *   }
     * })
     * 
    **/
    create<T extends FeedbackEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventCreateArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeedbackEvents.
     *     @param {FeedbackEventCreateManyArgs} args - Arguments to create many FeedbackEvents.
     *     @example
     *     // Create many FeedbackEvents
     *     const feedbackEvent = await prisma.feedbackEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackEvent.
     * @param {FeedbackEventDeleteArgs} args - Arguments to delete one FeedbackEvent.
     * @example
     * // Delete one FeedbackEvent
     * const FeedbackEvent = await prisma.feedbackEvent.delete({
     *   where: {
     *     // ... filter to delete one FeedbackEvent
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeedbackEvent.
     * @param {FeedbackEventUpdateArgs} args - Arguments to update one FeedbackEvent.
     * @example
     * // Update one FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeedbackEvents.
     * @param {FeedbackEventDeleteManyArgs} args - Arguments to filter FeedbackEvents to delete.
     * @example
     * // Delete a few FeedbackEvents
     * const { count } = await prisma.feedbackEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackEvents
     * const feedbackEvent = await prisma.feedbackEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackEvent.
     * @param {FeedbackEventUpsertArgs} args - Arguments to update or create a FeedbackEvent.
     * @example
     * // Update or create a FeedbackEvent
     * const feedbackEvent = await prisma.feedbackEvent.upsert({
     *   create: {
     *     // ... data to create a FeedbackEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackEvent we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackEventUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackEventClient<$Result.GetResult<Prisma.$FeedbackEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeedbackEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventCountArgs} args - Arguments to filter FeedbackEvents to count.
     * @example
     * // Count the number of FeedbackEvents
     * const count = await prisma.feedbackEvent.count({
     *   where: {
     *     // ... the filter for the FeedbackEvents we want to count
     *   }
     * })
    **/
    count<T extends FeedbackEventCountArgs>(
      args?: Subset<T, FeedbackEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackEventAggregateArgs>(args: Subset<T, FeedbackEventAggregateArgs>): Prisma.PrismaPromise<GetFeedbackEventAggregateType<T>>

    /**
     * Group by FeedbackEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackEventGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackEvent model
   */
  readonly fields: FeedbackEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeedbackEvent model
   */ 
  interface FeedbackEventFieldRefs {
    readonly id: FieldRef<"FeedbackEvent", 'String'>
    readonly entityType: FieldRef<"FeedbackEvent", 'String'>
    readonly entityId: FieldRef<"FeedbackEvent", 'String'>
    readonly originalValue: FieldRef<"FeedbackEvent", 'Json'>
    readonly correctedValue: FieldRef<"FeedbackEvent", 'Json'>
    readonly correctionReason: FieldRef<"FeedbackEvent", 'String'>
    readonly createdAt: FieldRef<"FeedbackEvent", 'DateTime'>
    readonly correctedBy: FieldRef<"FeedbackEvent", 'String'>
  }
    

  // Custom InputTypes

  /**
   * FeedbackEvent findUnique
   */
  export type FeedbackEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter, which FeedbackEvent to fetch.
     */
    where: FeedbackEventWhereUniqueInput
  }


  /**
   * FeedbackEvent findUniqueOrThrow
   */
  export type FeedbackEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter, which FeedbackEvent to fetch.
     */
    where: FeedbackEventWhereUniqueInput
  }


  /**
   * FeedbackEvent findFirst
   */
  export type FeedbackEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter, which FeedbackEvent to fetch.
     */
    where?: FeedbackEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackEvents to fetch.
     */
    orderBy?: FeedbackEventOrderByWithRelationInput | FeedbackEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackEvents.
     */
    cursor?: FeedbackEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackEvents.
     */
    distinct?: FeedbackEventScalarFieldEnum | FeedbackEventScalarFieldEnum[]
  }


  /**
   * FeedbackEvent findFirstOrThrow
   */
  export type FeedbackEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter, which FeedbackEvent to fetch.
     */
    where?: FeedbackEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackEvents to fetch.
     */
    orderBy?: FeedbackEventOrderByWithRelationInput | FeedbackEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackEvents.
     */
    cursor?: FeedbackEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackEvents.
     */
    distinct?: FeedbackEventScalarFieldEnum | FeedbackEventScalarFieldEnum[]
  }


  /**
   * FeedbackEvent findMany
   */
  export type FeedbackEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter, which FeedbackEvents to fetch.
     */
    where?: FeedbackEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackEvents to fetch.
     */
    orderBy?: FeedbackEventOrderByWithRelationInput | FeedbackEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackEvents.
     */
    cursor?: FeedbackEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackEvents.
     */
    skip?: number
    distinct?: FeedbackEventScalarFieldEnum | FeedbackEventScalarFieldEnum[]
  }


  /**
   * FeedbackEvent create
   */
  export type FeedbackEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * The data needed to create a FeedbackEvent.
     */
    data: XOR<FeedbackEventCreateInput, FeedbackEventUncheckedCreateInput>
  }


  /**
   * FeedbackEvent createMany
   */
  export type FeedbackEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackEvents.
     */
    data: FeedbackEventCreateManyInput | FeedbackEventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeedbackEvent update
   */
  export type FeedbackEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * The data needed to update a FeedbackEvent.
     */
    data: XOR<FeedbackEventUpdateInput, FeedbackEventUncheckedUpdateInput>
    /**
     * Choose, which FeedbackEvent to update.
     */
    where: FeedbackEventWhereUniqueInput
  }


  /**
   * FeedbackEvent updateMany
   */
  export type FeedbackEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackEvents.
     */
    data: XOR<FeedbackEventUpdateManyMutationInput, FeedbackEventUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackEvents to update
     */
    where?: FeedbackEventWhereInput
  }


  /**
   * FeedbackEvent upsert
   */
  export type FeedbackEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * The filter to search for the FeedbackEvent to update in case it exists.
     */
    where: FeedbackEventWhereUniqueInput
    /**
     * In case the FeedbackEvent found by the `where` argument doesn't exist, create a new FeedbackEvent with this data.
     */
    create: XOR<FeedbackEventCreateInput, FeedbackEventUncheckedCreateInput>
    /**
     * In case the FeedbackEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackEventUpdateInput, FeedbackEventUncheckedUpdateInput>
  }


  /**
   * FeedbackEvent delete
   */
  export type FeedbackEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
    /**
     * Filter which FeedbackEvent to delete.
     */
    where: FeedbackEventWhereUniqueInput
  }


  /**
   * FeedbackEvent deleteMany
   */
  export type FeedbackEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackEvents to delete
     */
    where?: FeedbackEventWhereInput
  }


  /**
   * FeedbackEvent without action
   */
  export type FeedbackEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackEvent
     */
    select?: FeedbackEventSelect<ExtArgs> | null
  }



  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    duration: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    duration: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    appointmentDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    appointmentType: string | null
    title: string | null
    description: string | null
    status: string | null
    location: string | null
    consultationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    cancelledAt: Date | null
    cancelledBy: string | null
    cancellationReason: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    appointmentDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    appointmentType: string | null
    title: string | null
    description: string | null
    status: string | null
    location: string | null
    consultationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    cancelledAt: Date | null
    cancelledBy: string | null
    cancellationReason: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    doctorName: number
    appointmentDate: number
    startTime: number
    endTime: number
    duration: number
    appointmentType: number
    title: number
    description: number
    status: number
    location: number
    consultationId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    cancelledAt: number
    cancelledBy: number
    cancellationReason: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    duration?: true
  }

  export type AppointmentSumAggregateInputType = {
    duration?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    appointmentType?: true
    title?: true
    description?: true
    status?: true
    location?: true
    consultationId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancellationReason?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    appointmentType?: true
    title?: true
    description?: true
    status?: true
    location?: true
    consultationId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancellationReason?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    appointmentType?: true
    title?: true
    description?: true
    status?: true
    location?: true
    consultationId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancellationReason?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string | null
    doctorName: string | null
    appointmentDate: Date
    startTime: Date
    endTime: Date
    duration: number
    appointmentType: string
    title: string | null
    description: string | null
    status: string
    location: string | null
    consultationId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    cancelledAt: Date | null
    cancelledBy: string | null
    cancellationReason: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    doctorName?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    appointmentType?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    consultationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    cancellationReason?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | Appointment$consultationArgs<ExtArgs>
    reminders?: boolean | Appointment$remindersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    doctorName?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    appointmentType?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    consultationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    cancellationReason?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | Appointment$consultationArgs<ExtArgs>
    reminders?: boolean | Appointment$remindersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      reminders: Prisma.$AppointmentReminderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string | null
      doctorName: string | null
      appointmentDate: Date
      startTime: Date
      endTime: Date
      duration: number
      appointmentType: string
      title: string | null
      description: string | null
      status: string
      location: string | null
      consultationId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      cancelledAt: Date | null
      cancelledBy: string | null
      cancellationReason: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }


  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppointmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
    **/
    create<T extends AppointmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Appointments.
     *     @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     *     @example
     *     // Create many Appointments
     *     const appointment = await prisma.appointment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    consultation<T extends Appointment$consultationArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    reminders<T extends Appointment$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly doctorId: FieldRef<"Appointment", 'String'>
    readonly doctorName: FieldRef<"Appointment", 'String'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly duration: FieldRef<"Appointment", 'Int'>
    readonly appointmentType: FieldRef<"Appointment", 'String'>
    readonly title: FieldRef<"Appointment", 'String'>
    readonly description: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly consultationId: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
    readonly createdBy: FieldRef<"Appointment", 'String'>
    readonly cancelledAt: FieldRef<"Appointment", 'DateTime'>
    readonly cancelledBy: FieldRef<"Appointment", 'String'>
    readonly cancellationReason: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }


  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }


  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }


  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }


  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }


  /**
   * Appointment.consultation
   */
  export type Appointment$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }


  /**
   * Appointment.reminders
   */
  export type Appointment$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    where?: AppointmentReminderWhereInput
    orderBy?: AppointmentReminderOrderByWithRelationInput | AppointmentReminderOrderByWithRelationInput[]
    cursor?: AppointmentReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentReminderScalarFieldEnum | AppointmentReminderScalarFieldEnum[]
  }


  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
  }



  /**
   * Model AppointmentReminder
   */

  export type AggregateAppointmentReminder = {
    _count: AppointmentReminderCountAggregateOutputType | null
    _min: AppointmentReminderMinAggregateOutputType | null
    _max: AppointmentReminderMaxAggregateOutputType | null
  }

  export type AppointmentReminderMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reminderType: string | null
    reminderTime: Date | null
    status: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type AppointmentReminderMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    reminderType: string | null
    reminderTime: Date | null
    status: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type AppointmentReminderCountAggregateOutputType = {
    id: number
    appointmentId: number
    reminderType: number
    reminderTime: number
    status: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type AppointmentReminderMinAggregateInputType = {
    id?: true
    appointmentId?: true
    reminderType?: true
    reminderTime?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type AppointmentReminderMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    reminderType?: true
    reminderTime?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type AppointmentReminderCountAggregateInputType = {
    id?: true
    appointmentId?: true
    reminderType?: true
    reminderTime?: true
    status?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentReminder to aggregate.
     */
    where?: AppointmentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentReminders to fetch.
     */
    orderBy?: AppointmentReminderOrderByWithRelationInput | AppointmentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppointmentReminders
    **/
    _count?: true | AppointmentReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentReminderMaxAggregateInputType
  }

  export type GetAppointmentReminderAggregateType<T extends AppointmentReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointmentReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointmentReminder[P]>
      : GetScalarType<T[P], AggregateAppointmentReminder[P]>
  }




  export type AppointmentReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentReminderWhereInput
    orderBy?: AppointmentReminderOrderByWithAggregationInput | AppointmentReminderOrderByWithAggregationInput[]
    by: AppointmentReminderScalarFieldEnum[] | AppointmentReminderScalarFieldEnum
    having?: AppointmentReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentReminderCountAggregateInputType | true
    _min?: AppointmentReminderMinAggregateInputType
    _max?: AppointmentReminderMaxAggregateInputType
  }

  export type AppointmentReminderGroupByOutputType = {
    id: string
    appointmentId: string
    reminderType: string
    reminderTime: Date
    status: string
    sentAt: Date | null
    createdAt: Date
    _count: AppointmentReminderCountAggregateOutputType | null
    _min: AppointmentReminderMinAggregateOutputType | null
    _max: AppointmentReminderMaxAggregateOutputType | null
  }

  type GetAppointmentReminderGroupByPayload<T extends AppointmentReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentReminderGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentReminderGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    reminderType?: boolean
    reminderTime?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentReminder"]>

  export type AppointmentReminderSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    reminderType?: boolean
    reminderTime?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type AppointmentReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }


  export type $AppointmentReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppointmentReminder"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string
      reminderType: string
      reminderTime: Date
      status: string
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["appointmentReminder"]>
    composites: {}
  }


  type AppointmentReminderGetPayload<S extends boolean | null | undefined | AppointmentReminderDefaultArgs> = $Result.GetResult<Prisma.$AppointmentReminderPayload, S>

  type AppointmentReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentReminderFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AppointmentReminderCountAggregateInputType | true
    }

  export interface AppointmentReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppointmentReminder'], meta: { name: 'AppointmentReminder' } }
    /**
     * Find zero or one AppointmentReminder that matches the filter.
     * @param {AppointmentReminderFindUniqueArgs} args - Arguments to find a AppointmentReminder
     * @example
     * // Get one AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentReminderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderFindUniqueArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AppointmentReminder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppointmentReminderFindUniqueOrThrowArgs} args - Arguments to find a AppointmentReminder
     * @example
     * // Get one AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppointmentReminderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AppointmentReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderFindFirstArgs} args - Arguments to find a AppointmentReminder
     * @example
     * // Get one AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentReminderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderFindFirstArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AppointmentReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderFindFirstOrThrowArgs} args - Arguments to find a AppointmentReminder
     * @example
     * // Get one AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppointmentReminderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AppointmentReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppointmentReminders
     * const appointmentReminders = await prisma.appointmentReminder.findMany()
     * 
     * // Get first 10 AppointmentReminders
     * const appointmentReminders = await prisma.appointmentReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentReminderWithIdOnly = await prisma.appointmentReminder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppointmentReminderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AppointmentReminder.
     * @param {AppointmentReminderCreateArgs} args - Arguments to create a AppointmentReminder.
     * @example
     * // Create one AppointmentReminder
     * const AppointmentReminder = await prisma.appointmentReminder.create({
     *   data: {
     *     // ... data to create a AppointmentReminder
     *   }
     * })
     * 
    **/
    create<T extends AppointmentReminderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderCreateArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AppointmentReminders.
     *     @param {AppointmentReminderCreateManyArgs} args - Arguments to create many AppointmentReminders.
     *     @example
     *     // Create many AppointmentReminders
     *     const appointmentReminder = await prisma.appointmentReminder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentReminderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppointmentReminder.
     * @param {AppointmentReminderDeleteArgs} args - Arguments to delete one AppointmentReminder.
     * @example
     * // Delete one AppointmentReminder
     * const AppointmentReminder = await prisma.appointmentReminder.delete({
     *   where: {
     *     // ... filter to delete one AppointmentReminder
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentReminderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderDeleteArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AppointmentReminder.
     * @param {AppointmentReminderUpdateArgs} args - Arguments to update one AppointmentReminder.
     * @example
     * // Update one AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentReminderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderUpdateArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AppointmentReminders.
     * @param {AppointmentReminderDeleteManyArgs} args - Arguments to filter AppointmentReminders to delete.
     * @example
     * // Delete a few AppointmentReminders
     * const { count } = await prisma.appointmentReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentReminderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentReminderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppointmentReminders
     * const appointmentReminder = await prisma.appointmentReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentReminderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppointmentReminder.
     * @param {AppointmentReminderUpsertArgs} args - Arguments to update or create a AppointmentReminder.
     * @example
     * // Update or create a AppointmentReminder
     * const appointmentReminder = await prisma.appointmentReminder.upsert({
     *   create: {
     *     // ... data to create a AppointmentReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppointmentReminder we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentReminderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentReminderUpsertArgs<ExtArgs>>
    ): Prisma__AppointmentReminderClient<$Result.GetResult<Prisma.$AppointmentReminderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AppointmentReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderCountArgs} args - Arguments to filter AppointmentReminders to count.
     * @example
     * // Count the number of AppointmentReminders
     * const count = await prisma.appointmentReminder.count({
     *   where: {
     *     // ... the filter for the AppointmentReminders we want to count
     *   }
     * })
    **/
    count<T extends AppointmentReminderCountArgs>(
      args?: Subset<T, AppointmentReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppointmentReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentReminderAggregateArgs>(args: Subset<T, AppointmentReminderAggregateArgs>): Prisma.PrismaPromise<GetAppointmentReminderAggregateType<T>>

    /**
     * Group by AppointmentReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentReminderGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppointmentReminder model
   */
  readonly fields: AppointmentReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppointmentReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AppointmentReminder model
   */ 
  interface AppointmentReminderFieldRefs {
    readonly id: FieldRef<"AppointmentReminder", 'String'>
    readonly appointmentId: FieldRef<"AppointmentReminder", 'String'>
    readonly reminderType: FieldRef<"AppointmentReminder", 'String'>
    readonly reminderTime: FieldRef<"AppointmentReminder", 'DateTime'>
    readonly status: FieldRef<"AppointmentReminder", 'String'>
    readonly sentAt: FieldRef<"AppointmentReminder", 'DateTime'>
    readonly createdAt: FieldRef<"AppointmentReminder", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AppointmentReminder findUnique
   */
  export type AppointmentReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentReminder to fetch.
     */
    where: AppointmentReminderWhereUniqueInput
  }


  /**
   * AppointmentReminder findUniqueOrThrow
   */
  export type AppointmentReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentReminder to fetch.
     */
    where: AppointmentReminderWhereUniqueInput
  }


  /**
   * AppointmentReminder findFirst
   */
  export type AppointmentReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentReminder to fetch.
     */
    where?: AppointmentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentReminders to fetch.
     */
    orderBy?: AppointmentReminderOrderByWithRelationInput | AppointmentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentReminders.
     */
    cursor?: AppointmentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentReminders.
     */
    distinct?: AppointmentReminderScalarFieldEnum | AppointmentReminderScalarFieldEnum[]
  }


  /**
   * AppointmentReminder findFirstOrThrow
   */
  export type AppointmentReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentReminder to fetch.
     */
    where?: AppointmentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentReminders to fetch.
     */
    orderBy?: AppointmentReminderOrderByWithRelationInput | AppointmentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentReminders.
     */
    cursor?: AppointmentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentReminders.
     */
    distinct?: AppointmentReminderScalarFieldEnum | AppointmentReminderScalarFieldEnum[]
  }


  /**
   * AppointmentReminder findMany
   */
  export type AppointmentReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentReminders to fetch.
     */
    where?: AppointmentReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentReminders to fetch.
     */
    orderBy?: AppointmentReminderOrderByWithRelationInput | AppointmentReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppointmentReminders.
     */
    cursor?: AppointmentReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentReminders.
     */
    skip?: number
    distinct?: AppointmentReminderScalarFieldEnum | AppointmentReminderScalarFieldEnum[]
  }


  /**
   * AppointmentReminder create
   */
  export type AppointmentReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a AppointmentReminder.
     */
    data: XOR<AppointmentReminderCreateInput, AppointmentReminderUncheckedCreateInput>
  }


  /**
   * AppointmentReminder createMany
   */
  export type AppointmentReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppointmentReminders.
     */
    data: AppointmentReminderCreateManyInput | AppointmentReminderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AppointmentReminder update
   */
  export type AppointmentReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a AppointmentReminder.
     */
    data: XOR<AppointmentReminderUpdateInput, AppointmentReminderUncheckedUpdateInput>
    /**
     * Choose, which AppointmentReminder to update.
     */
    where: AppointmentReminderWhereUniqueInput
  }


  /**
   * AppointmentReminder updateMany
   */
  export type AppointmentReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppointmentReminders.
     */
    data: XOR<AppointmentReminderUpdateManyMutationInput, AppointmentReminderUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentReminders to update
     */
    where?: AppointmentReminderWhereInput
  }


  /**
   * AppointmentReminder upsert
   */
  export type AppointmentReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the AppointmentReminder to update in case it exists.
     */
    where: AppointmentReminderWhereUniqueInput
    /**
     * In case the AppointmentReminder found by the `where` argument doesn't exist, create a new AppointmentReminder with this data.
     */
    create: XOR<AppointmentReminderCreateInput, AppointmentReminderUncheckedCreateInput>
    /**
     * In case the AppointmentReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentReminderUpdateInput, AppointmentReminderUncheckedUpdateInput>
  }


  /**
   * AppointmentReminder delete
   */
  export type AppointmentReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
    /**
     * Filter which AppointmentReminder to delete.
     */
    where: AppointmentReminderWhereUniqueInput
  }


  /**
   * AppointmentReminder deleteMany
   */
  export type AppointmentReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentReminders to delete
     */
    where?: AppointmentReminderWhereInput
  }


  /**
   * AppointmentReminder without action
   */
  export type AppointmentReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentReminder
     */
    select?: AppointmentReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentReminderInclude<ExtArgs> | null
  }



  /**
   * Model InternalMessage
   */

  export type AggregateInternalMessage = {
    _count: InternalMessageCountAggregateOutputType | null
    _min: InternalMessageMinAggregateOutputType | null
    _max: InternalMessageMaxAggregateOutputType | null
  }

  export type InternalMessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    threadId: string | null
    subject: string | null
    content: string | null
    messageType: string | null
    status: string | null
    createdAt: Date | null
    readAt: Date | null
    archivedAt: Date | null
  }

  export type InternalMessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    threadId: string | null
    subject: string | null
    content: string | null
    messageType: string | null
    status: string | null
    createdAt: Date | null
    readAt: Date | null
    archivedAt: Date | null
  }

  export type InternalMessageCountAggregateOutputType = {
    id: number
    senderId: number
    recipientId: number
    threadId: number
    subject: number
    content: number
    messageType: number
    status: number
    createdAt: number
    readAt: number
    archivedAt: number
    _all: number
  }


  export type InternalMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    threadId?: true
    subject?: true
    content?: true
    messageType?: true
    status?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
  }

  export type InternalMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    threadId?: true
    subject?: true
    content?: true
    messageType?: true
    status?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
  }

  export type InternalMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    threadId?: true
    subject?: true
    content?: true
    messageType?: true
    status?: true
    createdAt?: true
    readAt?: true
    archivedAt?: true
    _all?: true
  }

  export type InternalMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalMessage to aggregate.
     */
    where?: InternalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalMessages to fetch.
     */
    orderBy?: InternalMessageOrderByWithRelationInput | InternalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternalMessages
    **/
    _count?: true | InternalMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternalMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternalMessageMaxAggregateInputType
  }

  export type GetInternalMessageAggregateType<T extends InternalMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateInternalMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternalMessage[P]>
      : GetScalarType<T[P], AggregateInternalMessage[P]>
  }




  export type InternalMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalMessageWhereInput
    orderBy?: InternalMessageOrderByWithAggregationInput | InternalMessageOrderByWithAggregationInput[]
    by: InternalMessageScalarFieldEnum[] | InternalMessageScalarFieldEnum
    having?: InternalMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternalMessageCountAggregateInputType | true
    _min?: InternalMessageMinAggregateInputType
    _max?: InternalMessageMaxAggregateInputType
  }

  export type InternalMessageGroupByOutputType = {
    id: string
    senderId: string
    recipientId: string | null
    threadId: string | null
    subject: string | null
    content: string
    messageType: string
    status: string
    createdAt: Date
    readAt: Date | null
    archivedAt: Date | null
    _count: InternalMessageCountAggregateOutputType | null
    _min: InternalMessageMinAggregateOutputType | null
    _max: InternalMessageMaxAggregateOutputType | null
  }

  type GetInternalMessageGroupByPayload<T extends InternalMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternalMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternalMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternalMessageGroupByOutputType[P]>
            : GetScalarType<T[P], InternalMessageGroupByOutputType[P]>
        }
      >
    >


  export type InternalMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    threadId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    status?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
    thread?: boolean | InternalMessage$threadArgs<ExtArgs>
    attachments?: boolean | InternalMessage$attachmentsArgs<ExtArgs>
    _count?: boolean | InternalMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internalMessage"]>

  export type InternalMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    threadId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    status?: boolean
    createdAt?: boolean
    readAt?: boolean
    archivedAt?: boolean
  }

  export type InternalMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | InternalMessage$threadArgs<ExtArgs>
    attachments?: boolean | InternalMessage$attachmentsArgs<ExtArgs>
    _count?: boolean | InternalMessageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InternalMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternalMessage"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs> | null
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      recipientId: string | null
      threadId: string | null
      subject: string | null
      content: string
      messageType: string
      status: string
      createdAt: Date
      readAt: Date | null
      archivedAt: Date | null
    }, ExtArgs["result"]["internalMessage"]>
    composites: {}
  }


  type InternalMessageGetPayload<S extends boolean | null | undefined | InternalMessageDefaultArgs> = $Result.GetResult<Prisma.$InternalMessagePayload, S>

  type InternalMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternalMessageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InternalMessageCountAggregateInputType | true
    }

  export interface InternalMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternalMessage'], meta: { name: 'InternalMessage' } }
    /**
     * Find zero or one InternalMessage that matches the filter.
     * @param {InternalMessageFindUniqueArgs} args - Arguments to find a InternalMessage
     * @example
     * // Get one InternalMessage
     * const internalMessage = await prisma.internalMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InternalMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InternalMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InternalMessageFindUniqueOrThrowArgs} args - Arguments to find a InternalMessage
     * @example
     * // Get one InternalMessage
     * const internalMessage = await prisma.internalMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InternalMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InternalMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageFindFirstArgs} args - Arguments to find a InternalMessage
     * @example
     * // Get one InternalMessage
     * const internalMessage = await prisma.internalMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InternalMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageFindFirstArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InternalMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageFindFirstOrThrowArgs} args - Arguments to find a InternalMessage
     * @example
     * // Get one InternalMessage
     * const internalMessage = await prisma.internalMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InternalMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InternalMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternalMessages
     * const internalMessages = await prisma.internalMessage.findMany()
     * 
     * // Get first 10 InternalMessages
     * const internalMessages = await prisma.internalMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internalMessageWithIdOnly = await prisma.internalMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InternalMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InternalMessage.
     * @param {InternalMessageCreateArgs} args - Arguments to create a InternalMessage.
     * @example
     * // Create one InternalMessage
     * const InternalMessage = await prisma.internalMessage.create({
     *   data: {
     *     // ... data to create a InternalMessage
     *   }
     * })
     * 
    **/
    create<T extends InternalMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageCreateArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InternalMessages.
     *     @param {InternalMessageCreateManyArgs} args - Arguments to create many InternalMessages.
     *     @example
     *     // Create many InternalMessages
     *     const internalMessage = await prisma.internalMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InternalMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InternalMessage.
     * @param {InternalMessageDeleteArgs} args - Arguments to delete one InternalMessage.
     * @example
     * // Delete one InternalMessage
     * const InternalMessage = await prisma.internalMessage.delete({
     *   where: {
     *     // ... filter to delete one InternalMessage
     *   }
     * })
     * 
    **/
    delete<T extends InternalMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageDeleteArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InternalMessage.
     * @param {InternalMessageUpdateArgs} args - Arguments to update one InternalMessage.
     * @example
     * // Update one InternalMessage
     * const internalMessage = await prisma.internalMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InternalMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageUpdateArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InternalMessages.
     * @param {InternalMessageDeleteManyArgs} args - Arguments to filter InternalMessages to delete.
     * @example
     * // Delete a few InternalMessages
     * const { count } = await prisma.internalMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InternalMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InternalMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternalMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternalMessages
     * const internalMessage = await prisma.internalMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InternalMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternalMessage.
     * @param {InternalMessageUpsertArgs} args - Arguments to update or create a InternalMessage.
     * @example
     * // Update or create a InternalMessage
     * const internalMessage = await prisma.internalMessage.upsert({
     *   create: {
     *     // ... data to create a InternalMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternalMessage we want to update
     *   }
     * })
    **/
    upsert<T extends InternalMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InternalMessageUpsertArgs<ExtArgs>>
    ): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InternalMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageCountArgs} args - Arguments to filter InternalMessages to count.
     * @example
     * // Count the number of InternalMessages
     * const count = await prisma.internalMessage.count({
     *   where: {
     *     // ... the filter for the InternalMessages we want to count
     *   }
     * })
    **/
    count<T extends InternalMessageCountArgs>(
      args?: Subset<T, InternalMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternalMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternalMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternalMessageAggregateArgs>(args: Subset<T, InternalMessageAggregateArgs>): Prisma.PrismaPromise<GetInternalMessageAggregateType<T>>

    /**
     * Group by InternalMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternalMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternalMessageGroupByArgs['orderBy'] }
        : { orderBy?: InternalMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternalMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternalMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternalMessage model
   */
  readonly fields: InternalMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternalMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternalMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    thread<T extends InternalMessage$threadArgs<ExtArgs> = {}>(args?: Subset<T, InternalMessage$threadArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    attachments<T extends InternalMessage$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, InternalMessage$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InternalMessage model
   */ 
  interface InternalMessageFieldRefs {
    readonly id: FieldRef<"InternalMessage", 'String'>
    readonly senderId: FieldRef<"InternalMessage", 'String'>
    readonly recipientId: FieldRef<"InternalMessage", 'String'>
    readonly threadId: FieldRef<"InternalMessage", 'String'>
    readonly subject: FieldRef<"InternalMessage", 'String'>
    readonly content: FieldRef<"InternalMessage", 'String'>
    readonly messageType: FieldRef<"InternalMessage", 'String'>
    readonly status: FieldRef<"InternalMessage", 'String'>
    readonly createdAt: FieldRef<"InternalMessage", 'DateTime'>
    readonly readAt: FieldRef<"InternalMessage", 'DateTime'>
    readonly archivedAt: FieldRef<"InternalMessage", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * InternalMessage findUnique
   */
  export type InternalMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter, which InternalMessage to fetch.
     */
    where: InternalMessageWhereUniqueInput
  }


  /**
   * InternalMessage findUniqueOrThrow
   */
  export type InternalMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter, which InternalMessage to fetch.
     */
    where: InternalMessageWhereUniqueInput
  }


  /**
   * InternalMessage findFirst
   */
  export type InternalMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter, which InternalMessage to fetch.
     */
    where?: InternalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalMessages to fetch.
     */
    orderBy?: InternalMessageOrderByWithRelationInput | InternalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalMessages.
     */
    cursor?: InternalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalMessages.
     */
    distinct?: InternalMessageScalarFieldEnum | InternalMessageScalarFieldEnum[]
  }


  /**
   * InternalMessage findFirstOrThrow
   */
  export type InternalMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter, which InternalMessage to fetch.
     */
    where?: InternalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalMessages to fetch.
     */
    orderBy?: InternalMessageOrderByWithRelationInput | InternalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalMessages.
     */
    cursor?: InternalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalMessages.
     */
    distinct?: InternalMessageScalarFieldEnum | InternalMessageScalarFieldEnum[]
  }


  /**
   * InternalMessage findMany
   */
  export type InternalMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter, which InternalMessages to fetch.
     */
    where?: InternalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalMessages to fetch.
     */
    orderBy?: InternalMessageOrderByWithRelationInput | InternalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternalMessages.
     */
    cursor?: InternalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalMessages.
     */
    skip?: number
    distinct?: InternalMessageScalarFieldEnum | InternalMessageScalarFieldEnum[]
  }


  /**
   * InternalMessage create
   */
  export type InternalMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a InternalMessage.
     */
    data: XOR<InternalMessageCreateInput, InternalMessageUncheckedCreateInput>
  }


  /**
   * InternalMessage createMany
   */
  export type InternalMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternalMessages.
     */
    data: InternalMessageCreateManyInput | InternalMessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InternalMessage update
   */
  export type InternalMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a InternalMessage.
     */
    data: XOR<InternalMessageUpdateInput, InternalMessageUncheckedUpdateInput>
    /**
     * Choose, which InternalMessage to update.
     */
    where: InternalMessageWhereUniqueInput
  }


  /**
   * InternalMessage updateMany
   */
  export type InternalMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternalMessages.
     */
    data: XOR<InternalMessageUpdateManyMutationInput, InternalMessageUncheckedUpdateManyInput>
    /**
     * Filter which InternalMessages to update
     */
    where?: InternalMessageWhereInput
  }


  /**
   * InternalMessage upsert
   */
  export type InternalMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the InternalMessage to update in case it exists.
     */
    where: InternalMessageWhereUniqueInput
    /**
     * In case the InternalMessage found by the `where` argument doesn't exist, create a new InternalMessage with this data.
     */
    create: XOR<InternalMessageCreateInput, InternalMessageUncheckedCreateInput>
    /**
     * In case the InternalMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternalMessageUpdateInput, InternalMessageUncheckedUpdateInput>
  }


  /**
   * InternalMessage delete
   */
  export type InternalMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    /**
     * Filter which InternalMessage to delete.
     */
    where: InternalMessageWhereUniqueInput
  }


  /**
   * InternalMessage deleteMany
   */
  export type InternalMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalMessages to delete
     */
    where?: InternalMessageWhereInput
  }


  /**
   * InternalMessage.thread
   */
  export type InternalMessage$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    where?: MessageThreadWhereInput
  }


  /**
   * InternalMessage.attachments
   */
  export type InternalMessage$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * InternalMessage without action
   */
  export type InternalMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
  }



  /**
   * Model MessageThread
   */

  export type AggregateMessageThread = {
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  export type MessageThreadMinAggregateOutputType = {
    id: string | null
    name: string | null
    threadType: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
    createdBy: string | null
  }

  export type MessageThreadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    threadType: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
    createdBy: string | null
  }

  export type MessageThreadCountAggregateOutputType = {
    id: number
    name: number
    threadType: number
    description: number
    participantIds: number
    createdAt: number
    updatedAt: number
    lastMessageAt: number
    createdBy: number
    _all: number
  }


  export type MessageThreadMinAggregateInputType = {
    id?: true
    name?: true
    threadType?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    createdBy?: true
  }

  export type MessageThreadMaxAggregateInputType = {
    id?: true
    name?: true
    threadType?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    createdBy?: true
  }

  export type MessageThreadCountAggregateInputType = {
    id?: true
    name?: true
    threadType?: true
    description?: true
    participantIds?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    createdBy?: true
    _all?: true
  }

  export type MessageThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThread to aggregate.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageThreads
    **/
    _count?: true | MessageThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageThreadMaxAggregateInputType
  }

  export type GetMessageThreadAggregateType<T extends MessageThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageThread[P]>
      : GetScalarType<T[P], AggregateMessageThread[P]>
  }




  export type MessageThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithAggregationInput | MessageThreadOrderByWithAggregationInput[]
    by: MessageThreadScalarFieldEnum[] | MessageThreadScalarFieldEnum
    having?: MessageThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageThreadCountAggregateInputType | true
    _min?: MessageThreadMinAggregateInputType
    _max?: MessageThreadMaxAggregateInputType
  }

  export type MessageThreadGroupByOutputType = {
    id: string
    name: string | null
    threadType: string
    description: string | null
    participantIds: string[]
    createdAt: Date
    updatedAt: Date
    lastMessageAt: Date | null
    createdBy: string
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  type GetMessageThreadGroupByPayload<T extends MessageThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
        }
      >
    >


  export type MessageThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    threadType?: boolean
    description?: boolean
    participantIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    createdBy?: boolean
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectScalar = {
    id?: boolean
    name?: boolean
    threadType?: boolean
    description?: boolean
    participantIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    createdBy?: boolean
  }

  export type MessageThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MessageThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageThread"
    objects: {
      messages: Prisma.$InternalMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      threadType: string
      description: string | null
      participantIds: string[]
      createdAt: Date
      updatedAt: Date
      lastMessageAt: Date | null
      createdBy: string
    }, ExtArgs["result"]["messageThread"]>
    composites: {}
  }


  type MessageThreadGetPayload<S extends boolean | null | undefined | MessageThreadDefaultArgs> = $Result.GetResult<Prisma.$MessageThreadPayload, S>

  type MessageThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageThreadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MessageThreadCountAggregateInputType | true
    }

  export interface MessageThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageThread'], meta: { name: 'MessageThread' } }
    /**
     * Find zero or one MessageThread that matches the filter.
     * @param {MessageThreadFindUniqueArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageThreadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessageThread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageThreadFindUniqueOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageThreadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessageThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageThreadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadFindFirstArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessageThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageThreadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessageThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageThreads
     * const messageThreads = await prisma.messageThread.findMany()
     * 
     * // Get first 10 MessageThreads
     * const messageThreads = await prisma.messageThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageThreadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessageThread.
     * @param {MessageThreadCreateArgs} args - Arguments to create a MessageThread.
     * @example
     * // Create one MessageThread
     * const MessageThread = await prisma.messageThread.create({
     *   data: {
     *     // ... data to create a MessageThread
     *   }
     * })
     * 
    **/
    create<T extends MessageThreadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadCreateArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessageThreads.
     *     @param {MessageThreadCreateManyArgs} args - Arguments to create many MessageThreads.
     *     @example
     *     // Create many MessageThreads
     *     const messageThread = await prisma.messageThread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageThreadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageThread.
     * @param {MessageThreadDeleteArgs} args - Arguments to delete one MessageThread.
     * @example
     * // Delete one MessageThread
     * const MessageThread = await prisma.messageThread.delete({
     *   where: {
     *     // ... filter to delete one MessageThread
     *   }
     * })
     * 
    **/
    delete<T extends MessageThreadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadDeleteArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessageThread.
     * @param {MessageThreadUpdateArgs} args - Arguments to update one MessageThread.
     * @example
     * // Update one MessageThread
     * const messageThread = await prisma.messageThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageThreadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadUpdateArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessageThreads.
     * @param {MessageThreadDeleteManyArgs} args - Arguments to filter MessageThreads to delete.
     * @example
     * // Delete a few MessageThreads
     * const { count } = await prisma.messageThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageThreadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageThreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageThreadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageThread.
     * @param {MessageThreadUpsertArgs} args - Arguments to update or create a MessageThread.
     * @example
     * // Update or create a MessageThread
     * const messageThread = await prisma.messageThread.upsert({
     *   create: {
     *     // ... data to create a MessageThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageThread we want to update
     *   }
     * })
    **/
    upsert<T extends MessageThreadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageThreadUpsertArgs<ExtArgs>>
    ): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadCountArgs} args - Arguments to filter MessageThreads to count.
     * @example
     * // Count the number of MessageThreads
     * const count = await prisma.messageThread.count({
     *   where: {
     *     // ... the filter for the MessageThreads we want to count
     *   }
     * })
    **/
    count<T extends MessageThreadCountArgs>(
      args?: Subset<T, MessageThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageThreadAggregateArgs>(args: Subset<T, MessageThreadAggregateArgs>): Prisma.PrismaPromise<GetMessageThreadAggregateType<T>>

    /**
     * Group by MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageThreadGroupByArgs['orderBy'] }
        : { orderBy?: MessageThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageThread model
   */
  readonly fields: MessageThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    messages<T extends MessageThread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessageThread model
   */ 
  interface MessageThreadFieldRefs {
    readonly id: FieldRef<"MessageThread", 'String'>
    readonly name: FieldRef<"MessageThread", 'String'>
    readonly threadType: FieldRef<"MessageThread", 'String'>
    readonly description: FieldRef<"MessageThread", 'String'>
    readonly participantIds: FieldRef<"MessageThread", 'String[]'>
    readonly createdAt: FieldRef<"MessageThread", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageThread", 'DateTime'>
    readonly lastMessageAt: FieldRef<"MessageThread", 'DateTime'>
    readonly createdBy: FieldRef<"MessageThread", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MessageThread findUnique
   */
  export type MessageThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }


  /**
   * MessageThread findUniqueOrThrow
   */
  export type MessageThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }


  /**
   * MessageThread findFirst
   */
  export type MessageThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }


  /**
   * MessageThread findFirstOrThrow
   */
  export type MessageThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }


  /**
   * MessageThread findMany
   */
  export type MessageThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreads to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }


  /**
   * MessageThread create
   */
  export type MessageThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageThread.
     */
    data: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
  }


  /**
   * MessageThread createMany
   */
  export type MessageThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessageThread update
   */
  export type MessageThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageThread.
     */
    data: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
    /**
     * Choose, which MessageThread to update.
     */
    where: MessageThreadWhereUniqueInput
  }


  /**
   * MessageThread updateMany
   */
  export type MessageThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
  }


  /**
   * MessageThread upsert
   */
  export type MessageThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageThread to update in case it exists.
     */
    where: MessageThreadWhereUniqueInput
    /**
     * In case the MessageThread found by the `where` argument doesn't exist, create a new MessageThread with this data.
     */
    create: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
    /**
     * In case the MessageThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
  }


  /**
   * MessageThread delete
   */
  export type MessageThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter which MessageThread to delete.
     */
    where: MessageThreadWhereUniqueInput
  }


  /**
   * MessageThread deleteMany
   */
  export type MessageThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreads to delete
     */
    where?: MessageThreadWhereInput
  }


  /**
   * MessageThread.messages
   */
  export type MessageThread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalMessage
     */
    select?: InternalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InternalMessageInclude<ExtArgs> | null
    where?: InternalMessageWhereInput
    orderBy?: InternalMessageOrderByWithRelationInput | InternalMessageOrderByWithRelationInput[]
    cursor?: InternalMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternalMessageScalarFieldEnum | InternalMessageScalarFieldEnum[]
  }


  /**
   * MessageThread without action
   */
  export type MessageThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageThreadInclude<ExtArgs> | null
  }



  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedAt: Date | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    fileSize: number | null
    uploadedAt: Date | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    fileName: number
    filePath: number
    mimeType: number
    fileSize: number
    uploadedAt: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    fileSize?: true
    uploadedAt?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt: Date
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
    message?: boolean | InternalMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
  }

  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | InternalMessageDefaultArgs<ExtArgs>
  }


  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$InternalMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      fileName: string
      filePath: string
      mimeType: string
      fileSize: number
      uploadedAt: Date
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }


  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessageAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
    **/
    create<T extends MessageAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessageAttachments.
     *     @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     *     @example
     *     // Create many MessageAttachments
     *     const messageAttachment = await prisma.messageAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
    **/
    delete<T extends MessageAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends MessageAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    message<T extends InternalMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InternalMessageDefaultArgs<ExtArgs>>): Prisma__InternalMessageClient<$Result.GetResult<Prisma.$InternalMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessageAttachment model
   */ 
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
    readonly fileName: FieldRef<"MessageAttachment", 'String'>
    readonly filePath: FieldRef<"MessageAttachment", 'String'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly fileSize: FieldRef<"MessageAttachment", 'Int'>
    readonly uploadedAt: FieldRef<"MessageAttachment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }


  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
  }


  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }


  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
  }


  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model StaffMember
   */

  export type AggregateStaffMember = {
    _count: StaffMemberCountAggregateOutputType | null
    _min: StaffMemberMinAggregateOutputType | null
    _max: StaffMemberMaxAggregateOutputType | null
  }

  export type StaffMemberMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    speciality: string | null
    status: string | null
    hiredDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMemberMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    speciality: string | null
    status: string | null
    hiredDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMemberCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    role: number
    speciality: number
    qualifications: number
    status: number
    hiredDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMemberMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    speciality?: true
    status?: true
    hiredDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMemberMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    speciality?: true
    status?: true
    hiredDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMemberCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    speciality?: true
    qualifications?: true
    status?: true
    hiredDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffMember to aggregate.
     */
    where?: StaffMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffMembers to fetch.
     */
    orderBy?: StaffMemberOrderByWithRelationInput | StaffMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffMembers
    **/
    _count?: true | StaffMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMemberMaxAggregateInputType
  }

  export type GetStaffMemberAggregateType<T extends StaffMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffMember[P]>
      : GetScalarType<T[P], AggregateStaffMember[P]>
  }




  export type StaffMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffMemberWhereInput
    orderBy?: StaffMemberOrderByWithAggregationInput | StaffMemberOrderByWithAggregationInput[]
    by: StaffMemberScalarFieldEnum[] | StaffMemberScalarFieldEnum
    having?: StaffMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffMemberCountAggregateInputType | true
    _min?: StaffMemberMinAggregateInputType
    _max?: StaffMemberMaxAggregateInputType
  }

  export type StaffMemberGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string | null
    role: string
    speciality: string | null
    qualifications: string[]
    status: string
    hiredDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StaffMemberCountAggregateOutputType | null
    _min: StaffMemberMinAggregateOutputType | null
    _max: StaffMemberMaxAggregateOutputType | null
  }

  type GetStaffMemberGroupByPayload<T extends StaffMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffMemberGroupByOutputType[P]>
            : GetScalarType<T[P], StaffMemberGroupByOutputType[P]>
        }
      >
    >


  export type StaffMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    speciality?: boolean
    qualifications?: boolean
    status?: boolean
    hiredDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shifts?: boolean | StaffMember$shiftsArgs<ExtArgs>
    leaves?: boolean | StaffMember$leavesArgs<ExtArgs>
    schedules?: boolean | StaffMember$schedulesArgs<ExtArgs>
    _count?: boolean | StaffMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffMember"]>

  export type StaffMemberSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    speciality?: boolean
    qualifications?: boolean
    status?: boolean
    hiredDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | StaffMember$shiftsArgs<ExtArgs>
    leaves?: boolean | StaffMember$leavesArgs<ExtArgs>
    schedules?: boolean | StaffMember$schedulesArgs<ExtArgs>
    _count?: boolean | StaffMemberCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StaffMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffMember"
    objects: {
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      phone: string | null
      role: string
      speciality: string | null
      qualifications: string[]
      status: string
      hiredDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffMember"]>
    composites: {}
  }


  type StaffMemberGetPayload<S extends boolean | null | undefined | StaffMemberDefaultArgs> = $Result.GetResult<Prisma.$StaffMemberPayload, S>

  type StaffMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffMemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StaffMemberCountAggregateInputType | true
    }

  export interface StaffMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffMember'], meta: { name: 'StaffMember' } }
    /**
     * Find zero or one StaffMember that matches the filter.
     * @param {StaffMemberFindUniqueArgs} args - Arguments to find a StaffMember
     * @example
     * // Get one StaffMember
     * const staffMember = await prisma.staffMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffMemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaffMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffMemberFindUniqueOrThrowArgs} args - Arguments to find a StaffMember
     * @example
     * // Get one StaffMember
     * const staffMember = await prisma.staffMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaffMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberFindFirstArgs} args - Arguments to find a StaffMember
     * @example
     * // Get one StaffMember
     * const staffMember = await prisma.staffMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffMemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberFindFirstArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaffMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberFindFirstOrThrowArgs} args - Arguments to find a StaffMember
     * @example
     * // Get one StaffMember
     * const staffMember = await prisma.staffMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaffMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffMembers
     * const staffMembers = await prisma.staffMember.findMany()
     * 
     * // Get first 10 StaffMembers
     * const staffMembers = await prisma.staffMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffMemberWithIdOnly = await prisma.staffMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaffMember.
     * @param {StaffMemberCreateArgs} args - Arguments to create a StaffMember.
     * @example
     * // Create one StaffMember
     * const StaffMember = await prisma.staffMember.create({
     *   data: {
     *     // ... data to create a StaffMember
     *   }
     * })
     * 
    **/
    create<T extends StaffMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberCreateArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaffMembers.
     *     @param {StaffMemberCreateManyArgs} args - Arguments to create many StaffMembers.
     *     @example
     *     // Create many StaffMembers
     *     const staffMember = await prisma.staffMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaffMember.
     * @param {StaffMemberDeleteArgs} args - Arguments to delete one StaffMember.
     * @example
     * // Delete one StaffMember
     * const StaffMember = await prisma.staffMember.delete({
     *   where: {
     *     // ... filter to delete one StaffMember
     *   }
     * })
     * 
    **/
    delete<T extends StaffMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberDeleteArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaffMember.
     * @param {StaffMemberUpdateArgs} args - Arguments to update one StaffMember.
     * @example
     * // Update one StaffMember
     * const staffMember = await prisma.staffMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberUpdateArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaffMembers.
     * @param {StaffMemberDeleteManyArgs} args - Arguments to filter StaffMembers to delete.
     * @example
     * // Delete a few StaffMembers
     * const { count } = await prisma.staffMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffMembers
     * const staffMember = await prisma.staffMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffMember.
     * @param {StaffMemberUpsertArgs} args - Arguments to update or create a StaffMember.
     * @example
     * // Update or create a StaffMember
     * const staffMember = await prisma.staffMember.upsert({
     *   create: {
     *     // ... data to create a StaffMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffMember we want to update
     *   }
     * })
    **/
    upsert<T extends StaffMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffMemberUpsertArgs<ExtArgs>>
    ): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaffMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberCountArgs} args - Arguments to filter StaffMembers to count.
     * @example
     * // Count the number of StaffMembers
     * const count = await prisma.staffMember.count({
     *   where: {
     *     // ... the filter for the StaffMembers we want to count
     *   }
     * })
    **/
    count<T extends StaffMemberCountArgs>(
      args?: Subset<T, StaffMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffMemberAggregateArgs>(args: Subset<T, StaffMemberAggregateArgs>): Prisma.PrismaPromise<GetStaffMemberAggregateType<T>>

    /**
     * Group by StaffMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffMemberGroupByArgs['orderBy'] }
        : { orderBy?: StaffMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffMember model
   */
  readonly fields: StaffMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shifts<T extends StaffMember$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, StaffMember$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findMany'> | Null>;

    leaves<T extends StaffMember$leavesArgs<ExtArgs> = {}>(args?: Subset<T, StaffMember$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findMany'> | Null>;

    schedules<T extends StaffMember$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, StaffMember$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StaffMember model
   */ 
  interface StaffMemberFieldRefs {
    readonly id: FieldRef<"StaffMember", 'String'>
    readonly firstName: FieldRef<"StaffMember", 'String'>
    readonly lastName: FieldRef<"StaffMember", 'String'>
    readonly email: FieldRef<"StaffMember", 'String'>
    readonly phone: FieldRef<"StaffMember", 'String'>
    readonly role: FieldRef<"StaffMember", 'String'>
    readonly speciality: FieldRef<"StaffMember", 'String'>
    readonly qualifications: FieldRef<"StaffMember", 'String[]'>
    readonly status: FieldRef<"StaffMember", 'String'>
    readonly hiredDate: FieldRef<"StaffMember", 'DateTime'>
    readonly createdAt: FieldRef<"StaffMember", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffMember", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StaffMember findUnique
   */
  export type StaffMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter, which StaffMember to fetch.
     */
    where: StaffMemberWhereUniqueInput
  }


  /**
   * StaffMember findUniqueOrThrow
   */
  export type StaffMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter, which StaffMember to fetch.
     */
    where: StaffMemberWhereUniqueInput
  }


  /**
   * StaffMember findFirst
   */
  export type StaffMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter, which StaffMember to fetch.
     */
    where?: StaffMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffMembers to fetch.
     */
    orderBy?: StaffMemberOrderByWithRelationInput | StaffMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffMembers.
     */
    cursor?: StaffMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffMembers.
     */
    distinct?: StaffMemberScalarFieldEnum | StaffMemberScalarFieldEnum[]
  }


  /**
   * StaffMember findFirstOrThrow
   */
  export type StaffMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter, which StaffMember to fetch.
     */
    where?: StaffMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffMembers to fetch.
     */
    orderBy?: StaffMemberOrderByWithRelationInput | StaffMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffMembers.
     */
    cursor?: StaffMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffMembers.
     */
    distinct?: StaffMemberScalarFieldEnum | StaffMemberScalarFieldEnum[]
  }


  /**
   * StaffMember findMany
   */
  export type StaffMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter, which StaffMembers to fetch.
     */
    where?: StaffMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffMembers to fetch.
     */
    orderBy?: StaffMemberOrderByWithRelationInput | StaffMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffMembers.
     */
    cursor?: StaffMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffMembers.
     */
    skip?: number
    distinct?: StaffMemberScalarFieldEnum | StaffMemberScalarFieldEnum[]
  }


  /**
   * StaffMember create
   */
  export type StaffMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffMember.
     */
    data: XOR<StaffMemberCreateInput, StaffMemberUncheckedCreateInput>
  }


  /**
   * StaffMember createMany
   */
  export type StaffMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffMembers.
     */
    data: StaffMemberCreateManyInput | StaffMemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StaffMember update
   */
  export type StaffMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffMember.
     */
    data: XOR<StaffMemberUpdateInput, StaffMemberUncheckedUpdateInput>
    /**
     * Choose, which StaffMember to update.
     */
    where: StaffMemberWhereUniqueInput
  }


  /**
   * StaffMember updateMany
   */
  export type StaffMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffMembers.
     */
    data: XOR<StaffMemberUpdateManyMutationInput, StaffMemberUncheckedUpdateManyInput>
    /**
     * Filter which StaffMembers to update
     */
    where?: StaffMemberWhereInput
  }


  /**
   * StaffMember upsert
   */
  export type StaffMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffMember to update in case it exists.
     */
    where: StaffMemberWhereUniqueInput
    /**
     * In case the StaffMember found by the `where` argument doesn't exist, create a new StaffMember with this data.
     */
    create: XOR<StaffMemberCreateInput, StaffMemberUncheckedCreateInput>
    /**
     * In case the StaffMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffMemberUpdateInput, StaffMemberUncheckedUpdateInput>
  }


  /**
   * StaffMember delete
   */
  export type StaffMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
    /**
     * Filter which StaffMember to delete.
     */
    where: StaffMemberWhereUniqueInput
  }


  /**
   * StaffMember deleteMany
   */
  export type StaffMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffMembers to delete
     */
    where?: StaffMemberWhereInput
  }


  /**
   * StaffMember.shifts
   */
  export type StaffMember$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }


  /**
   * StaffMember.leaves
   */
  export type StaffMember$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }


  /**
   * StaffMember.schedules
   */
  export type StaffMember$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }


  /**
   * StaffMember without action
   */
  export type StaffMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffMember
     */
    select?: StaffMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffMemberInclude<ExtArgs> | null
  }



  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: Date | null
    endTime: Date | null
    shiftType: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: Date | null
    endTime: Date | null
    shiftType: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    staffMemberId: number
    startDate: number
    endDate: number
    startTime: number
    endTime: number
    shiftType: number
    location: number
    status: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type ShiftMinAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    shiftType?: true
    location?: true
    status?: true
    createdAt?: true
    createdBy?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    shiftType?: true
    location?: true
    status?: true
    createdAt?: true
    createdBy?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    shiftType?: true
    location?: true
    status?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    staffMemberId: string
    startDate: Date
    endDate: Date
    startTime: Date
    endTime: Date
    shiftType: string
    location: string | null
    status: string
    createdAt: Date
    createdBy: string
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    shiftType?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    shiftType?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }


  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      staffMember: Prisma.$StaffMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffMemberId: string
      startDate: Date
      endDate: Date
      startTime: Date
      endTime: Date
      shiftType: string
      location: string | null
      status: string
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }


  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShiftFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Shift that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShiftFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShiftFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
    **/
    create<T extends ShiftCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Shifts.
     *     @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     *     @example
     *     // Create many Shifts
     *     const shift = await prisma.shift.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShiftCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
    **/
    delete<T extends ShiftDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShiftUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShiftDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShiftUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
    **/
    upsert<T extends ShiftUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>
    ): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    staffMember<T extends StaffMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffMemberDefaultArgs<ExtArgs>>): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly staffMemberId: FieldRef<"Shift", 'String'>
    readonly startDate: FieldRef<"Shift", 'DateTime'>
    readonly endDate: FieldRef<"Shift", 'DateTime'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly shiftType: FieldRef<"Shift", 'String'>
    readonly location: FieldRef<"Shift", 'String'>
    readonly status: FieldRef<"Shift", 'String'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly createdBy: FieldRef<"Shift", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }


  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }


  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }


  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }


  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }


  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }


  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }


  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
  }


  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }


  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }


  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
  }


  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShiftInclude<ExtArgs> | null
  }



  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    leaveType: string | null
    reason: string | null
    status: string | null
    createdAt: Date | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    leaveType: string | null
    reason: string | null
    status: string | null
    createdAt: Date | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    staffMemberId: number
    startDate: number
    endDate: number
    leaveType: number
    reason: number
    status: number
    createdAt: number
    requestedBy: number
    approvedBy: number
    approvedAt: number
    _all: number
  }


  export type LeaveMinAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    createdAt?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    createdAt?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    createdAt?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    staffMemberId: string
    startDate: Date
    endDate: Date
    leaveType: string
    reason: string | null
    status: string
    createdAt: Date
    requestedBy: string
    approvedBy: string | null
    approvedAt: Date | null
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
  }

  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }


  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      staffMember: Prisma.$StaffMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffMemberId: string
      startDate: Date
      endDate: Date
      leaveType: string
      reason: string | null
      status: string
      createdAt: Date
      requestedBy: string
      approvedBy: string | null
      approvedAt: Date | null
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }


  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaveFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leave that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaveFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaveFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
    **/
    create<T extends LeaveCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leaves.
     *     @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     *     @example
     *     // Create many Leaves
     *     const leave = await prisma.leave.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaveCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
    **/
    delete<T extends LeaveDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaveUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaveDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaveUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
    **/
    upsert<T extends LeaveUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>
    ): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    staffMember<T extends StaffMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffMemberDefaultArgs<ExtArgs>>): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Leave model
   */ 
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly staffMemberId: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly leaveType: FieldRef<"Leave", 'String'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly requestedBy: FieldRef<"Leave", 'String'>
    readonly approvedBy: FieldRef<"Leave", 'String'>
    readonly approvedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }


  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }


  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }


  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }


  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }


  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }


  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }


  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
  }


  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }


  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }


  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
  }


  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaveInclude<ExtArgs> | null
  }



  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    staffMemberId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    staffMemberId: number
    startDate: number
    endDate: number
    scheduleData: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    staffMemberId?: true
    startDate?: true
    endDate?: true
    scheduleData?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    staffMemberId: string
    startDate: Date
    endDate: Date
    scheduleData: JsonValue
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    scheduleData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    staffMemberId?: boolean
    startDate?: boolean
    endDate?: boolean
    scheduleData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffMember?: boolean | StaffMemberDefaultArgs<ExtArgs>
  }


  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      staffMember: Prisma.$StaffMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffMemberId: string
      startDate: Date
      endDate: Date
      scheduleData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }


  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScheduleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Schedule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScheduleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScheduleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
    **/
    create<T extends ScheduleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Schedules.
     *     @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     *     @example
     *     // Create many Schedules
     *     const schedule = await prisma.schedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScheduleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
    **/
    delete<T extends ScheduleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScheduleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScheduleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScheduleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
    **/
    upsert<T extends ScheduleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>
    ): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    staffMember<T extends StaffMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffMemberDefaultArgs<ExtArgs>>): Prisma__StaffMemberClient<$Result.GetResult<Prisma.$StaffMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly staffMemberId: FieldRef<"Schedule", 'String'>
    readonly startDate: FieldRef<"Schedule", 'DateTime'>
    readonly endDate: FieldRef<"Schedule", 'DateTime'>
    readonly scheduleData: FieldRef<"Schedule", 'Json'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
    readonly createdBy: FieldRef<"Schedule", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }


  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }


  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }


  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }


  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }


  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }


  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }


  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude<ExtArgs> | null
  }



  /**
   * Model StockItem
   */

  export type AggregateStockItem = {
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  export type StockItemAvgAggregateOutputType = {
    currentQuantity: number | null
    minQuantity: number | null
    maxQuantity: number | null
  }

  export type StockItemSumAggregateOutputType = {
    currentQuantity: number | null
    minQuantity: number | null
    maxQuantity: number | null
  }

  export type StockItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sku: string | null
    category: string | null
    subCategory: string | null
    currentQuantity: number | null
    minQuantity: number | null
    maxQuantity: number | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sku: string | null
    category: string | null
    subCategory: string | null
    currentQuantity: number | null
    minQuantity: number | null
    maxQuantity: number | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    sku: number
    category: number
    subCategory: number
    currentQuantity: number
    minQuantity: number
    maxQuantity: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockItemAvgAggregateInputType = {
    currentQuantity?: true
    minQuantity?: true
    maxQuantity?: true
  }

  export type StockItemSumAggregateInputType = {
    currentQuantity?: true
    minQuantity?: true
    maxQuantity?: true
  }

  export type StockItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    subCategory?: true
    currentQuantity?: true
    minQuantity?: true
    maxQuantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    subCategory?: true
    currentQuantity?: true
    minQuantity?: true
    maxQuantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    subCategory?: true
    currentQuantity?: true
    minQuantity?: true
    maxQuantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItem to aggregate.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockItems
    **/
    _count?: true | StockItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockItemMaxAggregateInputType
  }

  export type GetStockItemAggregateType<T extends StockItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockItem[P]>
      : GetScalarType<T[P], AggregateStockItem[P]>
  }




  export type StockItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockItemWhereInput
    orderBy?: StockItemOrderByWithAggregationInput | StockItemOrderByWithAggregationInput[]
    by: StockItemScalarFieldEnum[] | StockItemScalarFieldEnum
    having?: StockItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockItemCountAggregateInputType | true
    _avg?: StockItemAvgAggregateInputType
    _sum?: StockItemSumAggregateInputType
    _min?: StockItemMinAggregateInputType
    _max?: StockItemMaxAggregateInputType
  }

  export type StockItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    sku: string
    category: string
    subCategory: string | null
    currentQuantity: number
    minQuantity: number
    maxQuantity: number | null
    unit: string
    createdAt: Date
    updatedAt: Date
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  type GetStockItemGroupByPayload<T extends StockItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockItemGroupByOutputType[P]>
        }
      >
    >


  export type StockItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    subCategory?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    maxQuantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movements?: boolean | StockItem$movementsArgs<ExtArgs>
    alerts?: boolean | StockItem$alertsArgs<ExtArgs>
    _count?: boolean | StockItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    subCategory?: boolean
    currentQuantity?: boolean
    minQuantity?: boolean
    maxQuantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | StockItem$movementsArgs<ExtArgs>
    alerts?: boolean | StockItem$alertsArgs<ExtArgs>
    _count?: boolean | StockItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StockItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockItem"
    objects: {
      movements: Prisma.$StockMovementPayload<ExtArgs>[]
      alerts: Prisma.$StockAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      sku: string
      category: string
      subCategory: string | null
      currentQuantity: number
      minQuantity: number
      maxQuantity: number | null
      unit: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockItem"]>
    composites: {}
  }


  type StockItemGetPayload<S extends boolean | null | undefined | StockItemDefaultArgs> = $Result.GetResult<Prisma.$StockItemPayload, S>

  type StockItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockItemFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StockItemCountAggregateInputType | true
    }

  export interface StockItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockItem'], meta: { name: 'StockItem' } }
    /**
     * Find zero or one StockItem that matches the filter.
     * @param {StockItemFindUniqueArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemFindUniqueArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockItemFindUniqueOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemFindFirstArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockItems
     * const stockItems = await prisma.stockItem.findMany()
     * 
     * // Get first 10 StockItems
     * const stockItems = await prisma.stockItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockItem.
     * @param {StockItemCreateArgs} args - Arguments to create a StockItem.
     * @example
     * // Create one StockItem
     * const StockItem = await prisma.stockItem.create({
     *   data: {
     *     // ... data to create a StockItem
     *   }
     * })
     * 
    **/
    create<T extends StockItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemCreateArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockItems.
     *     @param {StockItemCreateManyArgs} args - Arguments to create many StockItems.
     *     @example
     *     // Create many StockItems
     *     const stockItem = await prisma.stockItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockItem.
     * @param {StockItemDeleteArgs} args - Arguments to delete one StockItem.
     * @example
     * // Delete one StockItem
     * const StockItem = await prisma.stockItem.delete({
     *   where: {
     *     // ... filter to delete one StockItem
     *   }
     * })
     * 
    **/
    delete<T extends StockItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemDeleteArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockItem.
     * @param {StockItemUpdateArgs} args - Arguments to update one StockItem.
     * @example
     * // Update one StockItem
     * const stockItem = await prisma.stockItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemUpdateArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockItems.
     * @param {StockItemDeleteManyArgs} args - Arguments to filter StockItems to delete.
     * @example
     * // Delete a few StockItems
     * const { count } = await prisma.stockItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockItem.
     * @param {StockItemUpsertArgs} args - Arguments to update or create a StockItem.
     * @example
     * // Update or create a StockItem
     * const stockItem = await prisma.stockItem.upsert({
     *   create: {
     *     // ... data to create a StockItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockItem we want to update
     *   }
     * })
    **/
    upsert<T extends StockItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockItemUpsertArgs<ExtArgs>>
    ): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemCountArgs} args - Arguments to filter StockItems to count.
     * @example
     * // Count the number of StockItems
     * const count = await prisma.stockItem.count({
     *   where: {
     *     // ... the filter for the StockItems we want to count
     *   }
     * })
    **/
    count<T extends StockItemCountArgs>(
      args?: Subset<T, StockItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockItemAggregateArgs>(args: Subset<T, StockItemAggregateArgs>): Prisma.PrismaPromise<GetStockItemAggregateType<T>>

    /**
     * Group by StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockItemGroupByArgs['orderBy'] }
        : { orderBy?: StockItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockItem model
   */
  readonly fields: StockItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    movements<T extends StockItem$movementsArgs<ExtArgs> = {}>(args?: Subset<T, StockItem$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findMany'> | Null>;

    alerts<T extends StockItem$alertsArgs<ExtArgs> = {}>(args?: Subset<T, StockItem$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockItem model
   */ 
  interface StockItemFieldRefs {
    readonly id: FieldRef<"StockItem", 'String'>
    readonly name: FieldRef<"StockItem", 'String'>
    readonly description: FieldRef<"StockItem", 'String'>
    readonly sku: FieldRef<"StockItem", 'String'>
    readonly category: FieldRef<"StockItem", 'String'>
    readonly subCategory: FieldRef<"StockItem", 'String'>
    readonly currentQuantity: FieldRef<"StockItem", 'Int'>
    readonly minQuantity: FieldRef<"StockItem", 'Int'>
    readonly maxQuantity: FieldRef<"StockItem", 'Int'>
    readonly unit: FieldRef<"StockItem", 'String'>
    readonly createdAt: FieldRef<"StockItem", 'DateTime'>
    readonly updatedAt: FieldRef<"StockItem", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockItem findUnique
   */
  export type StockItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem findUniqueOrThrow
   */
  export type StockItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem findFirst
   */
  export type StockItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }


  /**
   * StockItem findFirstOrThrow
   */
  export type StockItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }


  /**
   * StockItem findMany
   */
  export type StockItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItems to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }


  /**
   * StockItem create
   */
  export type StockItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StockItem.
     */
    data: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
  }


  /**
   * StockItem createMany
   */
  export type StockItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockItems.
     */
    data: StockItemCreateManyInput | StockItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockItem update
   */
  export type StockItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StockItem.
     */
    data: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
    /**
     * Choose, which StockItem to update.
     */
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem updateMany
   */
  export type StockItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockItems.
     */
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     */
    where?: StockItemWhereInput
  }


  /**
   * StockItem upsert
   */
  export type StockItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StockItem to update in case it exists.
     */
    where: StockItemWhereUniqueInput
    /**
     * In case the StockItem found by the `where` argument doesn't exist, create a new StockItem with this data.
     */
    create: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
    /**
     * In case the StockItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
  }


  /**
   * StockItem delete
   */
  export type StockItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter which StockItem to delete.
     */
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem deleteMany
   */
  export type StockItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItems to delete
     */
    where?: StockItemWhereInput
  }


  /**
   * StockItem.movements
   */
  export type StockItem$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }


  /**
   * StockItem.alerts
   */
  export type StockItem$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    where?: StockAlertWhereInput
    orderBy?: StockAlertOrderByWithRelationInput | StockAlertOrderByWithRelationInput[]
    cursor?: StockAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAlertScalarFieldEnum | StockAlertScalarFieldEnum[]
  }


  /**
   * StockItem without action
   */
  export type StockItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockItemInclude<ExtArgs> | null
  }



  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    stockItemId: string | null
    movementType: string | null
    quantity: number | null
    reference: string | null
    referenceType: string | null
    movementDate: Date | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    stockItemId: string | null
    movementType: string | null
    quantity: number | null
    reference: string | null
    referenceType: string | null
    movementDate: Date | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    stockItemId: number
    movementType: number
    quantity: number
    reference: number
    referenceType: number
    movementDate: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    stockItemId?: true
    movementType?: true
    quantity?: true
    reference?: true
    referenceType?: true
    movementDate?: true
    createdAt?: true
    createdBy?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    stockItemId?: true
    movementType?: true
    quantity?: true
    reference?: true
    referenceType?: true
    movementDate?: true
    createdAt?: true
    createdBy?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    stockItemId?: true
    movementType?: true
    quantity?: true
    reference?: true
    referenceType?: true
    movementDate?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    stockItemId: string
    movementType: string
    quantity: number
    reference: string | null
    referenceType: string | null
    movementDate: Date
    createdAt: Date
    createdBy: string
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockItemId?: boolean
    movementType?: boolean
    quantity?: boolean
    reference?: boolean
    referenceType?: boolean
    movementDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    stockItemId?: boolean
    movementType?: boolean
    quantity?: boolean
    reference?: boolean
    referenceType?: boolean
    movementDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }


  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      stockItem: Prisma.$StockItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stockItemId: string
      movementType: string
      quantity: number
      reference: string | null
      referenceType: string | null
      movementDate: Date
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }


  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockMovementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockMovementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockMovementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
    **/
    create<T extends StockMovementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockMovements.
     *     @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     *     @example
     *     // Create many StockMovements
     *     const stockMovement = await prisma.stockMovement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockMovementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
    **/
    delete<T extends StockMovementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockMovementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockMovementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockMovementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
    **/
    upsert<T extends StockMovementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>
    ): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stockItem<T extends StockItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockItemDefaultArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly stockItemId: FieldRef<"StockMovement", 'String'>
    readonly movementType: FieldRef<"StockMovement", 'String'>
    readonly quantity: FieldRef<"StockMovement", 'Int'>
    readonly reference: FieldRef<"StockMovement", 'String'>
    readonly referenceType: FieldRef<"StockMovement", 'String'>
    readonly movementDate: FieldRef<"StockMovement", 'DateTime'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
    readonly createdBy: FieldRef<"StockMovement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }


  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }


  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }


  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }


  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }


  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }


  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }


  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }


  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }


  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }


  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }


  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockMovementInclude<ExtArgs> | null
  }



  /**
   * Model StockAlert
   */

  export type AggregateStockAlert = {
    _count: StockAlertCountAggregateOutputType | null
    _min: StockAlertMinAggregateOutputType | null
    _max: StockAlertMaxAggregateOutputType | null
  }

  export type StockAlertMinAggregateOutputType = {
    id: string | null
    stockItemId: string | null
    alertType: string | null
    severity: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
  }

  export type StockAlertMaxAggregateOutputType = {
    id: string | null
    stockItemId: string | null
    alertType: string | null
    severity: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
  }

  export type StockAlertCountAggregateOutputType = {
    id: number
    stockItemId: number
    alertType: number
    severity: number
    message: number
    status: number
    createdAt: number
    acknowledgedAt: number
    acknowledgedBy: number
    _all: number
  }


  export type StockAlertMinAggregateInputType = {
    id?: true
    stockItemId?: true
    alertType?: true
    severity?: true
    message?: true
    status?: true
    createdAt?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
  }

  export type StockAlertMaxAggregateInputType = {
    id?: true
    stockItemId?: true
    alertType?: true
    severity?: true
    message?: true
    status?: true
    createdAt?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
  }

  export type StockAlertCountAggregateInputType = {
    id?: true
    stockItemId?: true
    alertType?: true
    severity?: true
    message?: true
    status?: true
    createdAt?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    _all?: true
  }

  export type StockAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAlert to aggregate.
     */
    where?: StockAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAlerts to fetch.
     */
    orderBy?: StockAlertOrderByWithRelationInput | StockAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockAlerts
    **/
    _count?: true | StockAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockAlertMaxAggregateInputType
  }

  export type GetStockAlertAggregateType<T extends StockAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateStockAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockAlert[P]>
      : GetScalarType<T[P], AggregateStockAlert[P]>
  }




  export type StockAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAlertWhereInput
    orderBy?: StockAlertOrderByWithAggregationInput | StockAlertOrderByWithAggregationInput[]
    by: StockAlertScalarFieldEnum[] | StockAlertScalarFieldEnum
    having?: StockAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockAlertCountAggregateInputType | true
    _min?: StockAlertMinAggregateInputType
    _max?: StockAlertMaxAggregateInputType
  }

  export type StockAlertGroupByOutputType = {
    id: string
    stockItemId: string
    alertType: string
    severity: string
    message: string
    status: string
    createdAt: Date
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    _count: StockAlertCountAggregateOutputType | null
    _min: StockAlertMinAggregateOutputType | null
    _max: StockAlertMaxAggregateOutputType | null
  }

  type GetStockAlertGroupByPayload<T extends StockAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockAlertGroupByOutputType[P]>
            : GetScalarType<T[P], StockAlertGroupByOutputType[P]>
        }
      >
    >


  export type StockAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockItemId?: boolean
    alertType?: boolean
    severity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAlert"]>

  export type StockAlertSelectScalar = {
    id?: boolean
    stockItemId?: boolean
    alertType?: boolean
    severity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
  }

  export type StockAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }


  export type $StockAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockAlert"
    objects: {
      stockItem: Prisma.$StockItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stockItemId: string
      alertType: string
      severity: string
      message: string
      status: string
      createdAt: Date
      acknowledgedAt: Date | null
      acknowledgedBy: string | null
    }, ExtArgs["result"]["stockAlert"]>
    composites: {}
  }


  type StockAlertGetPayload<S extends boolean | null | undefined | StockAlertDefaultArgs> = $Result.GetResult<Prisma.$StockAlertPayload, S>

  type StockAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockAlertFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StockAlertCountAggregateInputType | true
    }

  export interface StockAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockAlert'], meta: { name: 'StockAlert' } }
    /**
     * Find zero or one StockAlert that matches the filter.
     * @param {StockAlertFindUniqueArgs} args - Arguments to find a StockAlert
     * @example
     * // Get one StockAlert
     * const stockAlert = await prisma.stockAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockAlertFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertFindUniqueArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockAlert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockAlertFindUniqueOrThrowArgs} args - Arguments to find a StockAlert
     * @example
     * // Get one StockAlert
     * const stockAlert = await prisma.stockAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockAlertFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertFindFirstArgs} args - Arguments to find a StockAlert
     * @example
     * // Get one StockAlert
     * const stockAlert = await prisma.stockAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockAlertFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertFindFirstArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertFindFirstOrThrowArgs} args - Arguments to find a StockAlert
     * @example
     * // Get one StockAlert
     * const stockAlert = await prisma.stockAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockAlertFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockAlerts
     * const stockAlerts = await prisma.stockAlert.findMany()
     * 
     * // Get first 10 StockAlerts
     * const stockAlerts = await prisma.stockAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockAlertWithIdOnly = await prisma.stockAlert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockAlertFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockAlert.
     * @param {StockAlertCreateArgs} args - Arguments to create a StockAlert.
     * @example
     * // Create one StockAlert
     * const StockAlert = await prisma.stockAlert.create({
     *   data: {
     *     // ... data to create a StockAlert
     *   }
     * })
     * 
    **/
    create<T extends StockAlertCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertCreateArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockAlerts.
     *     @param {StockAlertCreateManyArgs} args - Arguments to create many StockAlerts.
     *     @example
     *     // Create many StockAlerts
     *     const stockAlert = await prisma.stockAlert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockAlertCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockAlert.
     * @param {StockAlertDeleteArgs} args - Arguments to delete one StockAlert.
     * @example
     * // Delete one StockAlert
     * const StockAlert = await prisma.stockAlert.delete({
     *   where: {
     *     // ... filter to delete one StockAlert
     *   }
     * })
     * 
    **/
    delete<T extends StockAlertDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertDeleteArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockAlert.
     * @param {StockAlertUpdateArgs} args - Arguments to update one StockAlert.
     * @example
     * // Update one StockAlert
     * const stockAlert = await prisma.stockAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockAlertUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertUpdateArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockAlerts.
     * @param {StockAlertDeleteManyArgs} args - Arguments to filter StockAlerts to delete.
     * @example
     * // Delete a few StockAlerts
     * const { count } = await prisma.stockAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockAlertDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockAlertDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockAlerts
     * const stockAlert = await prisma.stockAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockAlertUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockAlert.
     * @param {StockAlertUpsertArgs} args - Arguments to update or create a StockAlert.
     * @example
     * // Update or create a StockAlert
     * const stockAlert = await prisma.stockAlert.upsert({
     *   create: {
     *     // ... data to create a StockAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockAlert we want to update
     *   }
     * })
    **/
    upsert<T extends StockAlertUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockAlertUpsertArgs<ExtArgs>>
    ): Prisma__StockAlertClient<$Result.GetResult<Prisma.$StockAlertPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertCountArgs} args - Arguments to filter StockAlerts to count.
     * @example
     * // Count the number of StockAlerts
     * const count = await prisma.stockAlert.count({
     *   where: {
     *     // ... the filter for the StockAlerts we want to count
     *   }
     * })
    **/
    count<T extends StockAlertCountArgs>(
      args?: Subset<T, StockAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAlertAggregateArgs>(args: Subset<T, StockAlertAggregateArgs>): Prisma.PrismaPromise<GetStockAlertAggregateType<T>>

    /**
     * Group by StockAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockAlertGroupByArgs['orderBy'] }
        : { orderBy?: StockAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockAlert model
   */
  readonly fields: StockAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stockItem<T extends StockItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockItemDefaultArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockAlert model
   */ 
  interface StockAlertFieldRefs {
    readonly id: FieldRef<"StockAlert", 'String'>
    readonly stockItemId: FieldRef<"StockAlert", 'String'>
    readonly alertType: FieldRef<"StockAlert", 'String'>
    readonly severity: FieldRef<"StockAlert", 'String'>
    readonly message: FieldRef<"StockAlert", 'String'>
    readonly status: FieldRef<"StockAlert", 'String'>
    readonly createdAt: FieldRef<"StockAlert", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"StockAlert", 'DateTime'>
    readonly acknowledgedBy: FieldRef<"StockAlert", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StockAlert findUnique
   */
  export type StockAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter, which StockAlert to fetch.
     */
    where: StockAlertWhereUniqueInput
  }


  /**
   * StockAlert findUniqueOrThrow
   */
  export type StockAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter, which StockAlert to fetch.
     */
    where: StockAlertWhereUniqueInput
  }


  /**
   * StockAlert findFirst
   */
  export type StockAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter, which StockAlert to fetch.
     */
    where?: StockAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAlerts to fetch.
     */
    orderBy?: StockAlertOrderByWithRelationInput | StockAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAlerts.
     */
    cursor?: StockAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAlerts.
     */
    distinct?: StockAlertScalarFieldEnum | StockAlertScalarFieldEnum[]
  }


  /**
   * StockAlert findFirstOrThrow
   */
  export type StockAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter, which StockAlert to fetch.
     */
    where?: StockAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAlerts to fetch.
     */
    orderBy?: StockAlertOrderByWithRelationInput | StockAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAlerts.
     */
    cursor?: StockAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAlerts.
     */
    distinct?: StockAlertScalarFieldEnum | StockAlertScalarFieldEnum[]
  }


  /**
   * StockAlert findMany
   */
  export type StockAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter, which StockAlerts to fetch.
     */
    where?: StockAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAlerts to fetch.
     */
    orderBy?: StockAlertOrderByWithRelationInput | StockAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockAlerts.
     */
    cursor?: StockAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAlerts.
     */
    skip?: number
    distinct?: StockAlertScalarFieldEnum | StockAlertScalarFieldEnum[]
  }


  /**
   * StockAlert create
   */
  export type StockAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a StockAlert.
     */
    data: XOR<StockAlertCreateInput, StockAlertUncheckedCreateInput>
  }


  /**
   * StockAlert createMany
   */
  export type StockAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockAlerts.
     */
    data: StockAlertCreateManyInput | StockAlertCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockAlert update
   */
  export type StockAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a StockAlert.
     */
    data: XOR<StockAlertUpdateInput, StockAlertUncheckedUpdateInput>
    /**
     * Choose, which StockAlert to update.
     */
    where: StockAlertWhereUniqueInput
  }


  /**
   * StockAlert updateMany
   */
  export type StockAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockAlerts.
     */
    data: XOR<StockAlertUpdateManyMutationInput, StockAlertUncheckedUpdateManyInput>
    /**
     * Filter which StockAlerts to update
     */
    where?: StockAlertWhereInput
  }


  /**
   * StockAlert upsert
   */
  export type StockAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the StockAlert to update in case it exists.
     */
    where: StockAlertWhereUniqueInput
    /**
     * In case the StockAlert found by the `where` argument doesn't exist, create a new StockAlert with this data.
     */
    create: XOR<StockAlertCreateInput, StockAlertUncheckedCreateInput>
    /**
     * In case the StockAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockAlertUpdateInput, StockAlertUncheckedUpdateInput>
  }


  /**
   * StockAlert delete
   */
  export type StockAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
    /**
     * Filter which StockAlert to delete.
     */
    where: StockAlertWhereUniqueInput
  }


  /**
   * StockAlert deleteMany
   */
  export type StockAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAlerts to delete
     */
    where?: StockAlertWhereInput
  }


  /**
   * StockAlert without action
   */
  export type StockAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAlert
     */
    select?: StockAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockAlertInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PatientScalarFieldEnum: {
    id: 'id',
    insToken: 'insToken',
    insHash: 'insHash',
    firstName: 'firstName',
    lastName: 'lastName',
    birthDate: 'birthDate',
    birthPlace: 'birthPlace',
    email: 'email',
    phone: 'phone',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const SemanticNodeScalarFieldEnum: {
    id: 'id',
    nodeType: 'nodeType',
    snomedCtCode: 'snomedCtCode',
    cim10Code: 'cim10Code',
    cim11Code: 'cim11Code',
    label: 'label',
    description: 'description',
    embedding: 'embedding',
    value: 'value',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    confidence: 'confidence',
    patientId: 'patientId',
    consultationId: 'consultationId'
  };

  export type SemanticNodeScalarFieldEnum = (typeof SemanticNodeScalarFieldEnum)[keyof typeof SemanticNodeScalarFieldEnum]


  export const SemanticRelationScalarFieldEnum: {
    id: 'id',
    sourceNodeId: 'sourceNodeId',
    targetNodeId: 'targetNodeId',
    relationType: 'relationType',
    strength: 'strength',
    evidence: 'evidence',
    createdAt: 'createdAt',
    confidence: 'confidence'
  };

  export type SemanticRelationScalarFieldEnum = (typeof SemanticRelationScalarFieldEnum)[keyof typeof SemanticRelationScalarFieldEnum]


  export const ConsultationDraftScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    structuredData: 'structuredData'
  };

  export type ConsultationDraftScalarFieldEnum = (typeof ConsultationDraftScalarFieldEnum)[keyof typeof ConsultationDraftScalarFieldEnum]


  export const ConsultationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    consultationDate: 'consultationDate',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    rawTranscript: 'rawTranscript',
    rawText: 'rawText',
    draftData: 'draftData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    validatedAt: 'validatedAt',
    createdBy: 'createdBy'
  };

  export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


  export const BillingEventScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    ghmCode: 'ghmCode',
    actCode: 'actCode',
    actType: 'actType',
    status: 'status',
    evidenceNodeIds: 'evidenceNodeIds',
    createdAt: 'createdAt',
    transmittedAt: 'transmittedAt'
  };

  export type BillingEventScalarFieldEnum = (typeof BillingEventScalarFieldEnum)[keyof typeof BillingEventScalarFieldEnum]


  export const AllergyScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    substance: 'substance',
    snomedCtCode: 'snomedCtCode',
    severity: 'severity',
    createdAt: 'createdAt',
    source: 'source'
  };

  export type AllergyScalarFieldEnum = (typeof AllergyScalarFieldEnum)[keyof typeof AllergyScalarFieldEnum]


  export const MedicalDocumentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    documentType: 'documentType',
    title: 'title',
    content: 'content',
    rawContent: 'rawContent',
    documentDate: 'documentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    consultationId: 'consultationId'
  };

  export type MedicalDocumentScalarFieldEnum = (typeof MedicalDocumentScalarFieldEnum)[keyof typeof MedicalDocumentScalarFieldEnum]


  export const DocumentAttachmentScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    fileName: 'fileName',
    filePath: 'filePath',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy'
  };

  export type DocumentAttachmentScalarFieldEnum = (typeof DocumentAttachmentScalarFieldEnum)[keyof typeof DocumentAttachmentScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    medicationName: 'medicationName',
    atcCode: 'atcCode',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    status: 'status',
    safetyChecks: 'safetyChecks',
    outpassReason: 'outpassReason',
    documentId: 'documentId',
    createdAt: 'createdAt',
    prescribedBy: 'prescribedBy'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const MedicalReportScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    reportType: 'reportType',
    title: 'title',
    chiefComplaint: 'chiefComplaint',
    history: 'history',
    examination: 'examination',
    assessment: 'assessment',
    plan: 'plan',
    documentId: 'documentId',
    consultationId: 'consultationId',
    reportDate: 'reportDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type MedicalReportScalarFieldEnum = (typeof MedicalReportScalarFieldEnum)[keyof typeof MedicalReportScalarFieldEnum]


  export const LaboratoryResultScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    testName: 'testName',
    testCode: 'testCode',
    resultValue: 'resultValue',
    unit: 'unit',
    referenceRange: 'referenceRange',
    status: 'status',
    testDate: 'testDate',
    receivedAt: 'receivedAt',
    laboratoryName: 'laboratoryName',
    documentId: 'documentId'
  };

  export type LaboratoryResultScalarFieldEnum = (typeof LaboratoryResultScalarFieldEnum)[keyof typeof LaboratoryResultScalarFieldEnum]


  export const MedicalImageScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    studyInstanceUid: 'studyInstanceUid',
    seriesInstanceUid: 'seriesInstanceUid',
    sopInstanceUid: 'sopInstanceUid',
    modality: 'modality',
    bodyPart: 'bodyPart',
    studyDescription: 'studyDescription',
    seriesDescription: 'seriesDescription',
    filePath: 'filePath',
    fileSize: 'fileSize',
    documentId: 'documentId',
    acquisitionDate: 'acquisitionDate',
    createdAt: 'createdAt'
  };

  export type MedicalImageScalarFieldEnum = (typeof MedicalImageScalarFieldEnum)[keyof typeof MedicalImageScalarFieldEnum]


  export const FeedbackEventScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    originalValue: 'originalValue',
    correctedValue: 'correctedValue',
    correctionReason: 'correctionReason',
    createdAt: 'createdAt',
    correctedBy: 'correctedBy'
  };

  export type FeedbackEventScalarFieldEnum = (typeof FeedbackEventScalarFieldEnum)[keyof typeof FeedbackEventScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    doctorName: 'doctorName',
    appointmentDate: 'appointmentDate',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    appointmentType: 'appointmentType',
    title: 'title',
    description: 'description',
    status: 'status',
    location: 'location',
    consultationId: 'consultationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    cancelledAt: 'cancelledAt',
    cancelledBy: 'cancelledBy',
    cancellationReason: 'cancellationReason'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AppointmentReminderScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    reminderType: 'reminderType',
    reminderTime: 'reminderTime',
    status: 'status',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type AppointmentReminderScalarFieldEnum = (typeof AppointmentReminderScalarFieldEnum)[keyof typeof AppointmentReminderScalarFieldEnum]


  export const InternalMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recipientId: 'recipientId',
    threadId: 'threadId',
    subject: 'subject',
    content: 'content',
    messageType: 'messageType',
    status: 'status',
    createdAt: 'createdAt',
    readAt: 'readAt',
    archivedAt: 'archivedAt'
  };

  export type InternalMessageScalarFieldEnum = (typeof InternalMessageScalarFieldEnum)[keyof typeof InternalMessageScalarFieldEnum]


  export const MessageThreadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    threadType: 'threadType',
    description: 'description',
    participantIds: 'participantIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastMessageAt: 'lastMessageAt',
    createdBy: 'createdBy'
  };

  export type MessageThreadScalarFieldEnum = (typeof MessageThreadScalarFieldEnum)[keyof typeof MessageThreadScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    fileName: 'fileName',
    filePath: 'filePath',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    uploadedAt: 'uploadedAt'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const StaffMemberScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    role: 'role',
    speciality: 'speciality',
    qualifications: 'qualifications',
    status: 'status',
    hiredDate: 'hiredDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffMemberScalarFieldEnum = (typeof StaffMemberScalarFieldEnum)[keyof typeof StaffMemberScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    staffMemberId: 'staffMemberId',
    startDate: 'startDate',
    endDate: 'endDate',
    startTime: 'startTime',
    endTime: 'endTime',
    shiftType: 'shiftType',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    staffMemberId: 'staffMemberId',
    startDate: 'startDate',
    endDate: 'endDate',
    leaveType: 'leaveType',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    requestedBy: 'requestedBy',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    staffMemberId: 'staffMemberId',
    startDate: 'startDate',
    endDate: 'endDate',
    scheduleData: 'scheduleData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const StockItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    sku: 'sku',
    category: 'category',
    subCategory: 'subCategory',
    currentQuantity: 'currentQuantity',
    minQuantity: 'minQuantity',
    maxQuantity: 'maxQuantity',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockItemScalarFieldEnum = (typeof StockItemScalarFieldEnum)[keyof typeof StockItemScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    stockItemId: 'stockItemId',
    movementType: 'movementType',
    quantity: 'quantity',
    reference: 'reference',
    referenceType: 'referenceType',
    movementDate: 'movementDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const StockAlertScalarFieldEnum: {
    id: 'id',
    stockItemId: 'stockItemId',
    alertType: 'alertType',
    severity: 'severity',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgedBy: 'acknowledgedBy'
  };

  export type StockAlertScalarFieldEnum = (typeof StockAlertScalarFieldEnum)[keyof typeof StockAlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    insToken?: StringFilter<"Patient"> | string
    insHash?: StringFilter<"Patient"> | string
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    birthDate?: DateTimeFilter<"Patient"> | Date | string
    birthPlace?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    addressLine1?: StringNullableFilter<"Patient"> | string | null
    addressLine2?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    postalCode?: StringNullableFilter<"Patient"> | string | null
    country?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdBy?: StringFilter<"Patient"> | string
    consultations?: ConsultationListRelationFilter
    semanticNodes?: SemanticNodeListRelationFilter
    medicalDocuments?: MedicalDocumentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    medicalReports?: MedicalReportListRelationFilter
    laboratoryResults?: LaboratoryResultListRelationFilter
    medicalImages?: MedicalImageListRelationFilter
    appointments?: AppointmentListRelationFilter
    allergies?: AllergyListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    insToken?: SortOrder
    insHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultations?: ConsultationOrderByRelationAggregateInput
    semanticNodes?: SemanticNodeOrderByRelationAggregateInput
    medicalDocuments?: MedicalDocumentOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    medicalReports?: MedicalReportOrderByRelationAggregateInput
    laboratoryResults?: LaboratoryResultOrderByRelationAggregateInput
    medicalImages?: MedicalImageOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    allergies?: AllergyOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    insToken?: string
    insHash?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    birthDate?: DateTimeFilter<"Patient"> | Date | string
    birthPlace?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    addressLine1?: StringNullableFilter<"Patient"> | string | null
    addressLine2?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    postalCode?: StringNullableFilter<"Patient"> | string | null
    country?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdBy?: StringFilter<"Patient"> | string
    consultations?: ConsultationListRelationFilter
    semanticNodes?: SemanticNodeListRelationFilter
    medicalDocuments?: MedicalDocumentListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    medicalReports?: MedicalReportListRelationFilter
    laboratoryResults?: LaboratoryResultListRelationFilter
    medicalImages?: MedicalImageListRelationFilter
    appointments?: AppointmentListRelationFilter
    allergies?: AllergyListRelationFilter
  }, "id" | "insToken" | "insHash">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    insToken?: SortOrder
    insHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    insToken?: StringWithAggregatesFilter<"Patient"> | string
    insHash?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    birthDate?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    birthPlace?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    city?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    country?: StringWithAggregatesFilter<"Patient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Patient"> | string
  }

  export type SemanticNodeWhereInput = {
    AND?: SemanticNodeWhereInput | SemanticNodeWhereInput[]
    OR?: SemanticNodeWhereInput[]
    NOT?: SemanticNodeWhereInput | SemanticNodeWhereInput[]
    id?: StringFilter<"SemanticNode"> | string
    nodeType?: StringFilter<"SemanticNode"> | string
    snomedCtCode?: StringNullableFilter<"SemanticNode"> | string | null
    cim10Code?: StringNullableFilter<"SemanticNode"> | string | null
    cim11Code?: StringNullableFilter<"SemanticNode"> | string | null
    label?: StringFilter<"SemanticNode"> | string
    description?: StringNullableFilter<"SemanticNode"> | string | null
    embedding?: JsonNullableFilter<"SemanticNode">
    value?: JsonNullableFilter<"SemanticNode">
    unit?: StringNullableFilter<"SemanticNode"> | string | null
    createdAt?: DateTimeFilter<"SemanticNode"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticNode"> | Date | string
    confidence?: FloatNullableFilter<"SemanticNode"> | number | null
    patientId?: StringNullableFilter<"SemanticNode"> | string | null
    consultationId?: StringNullableFilter<"SemanticNode"> | string | null
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    sourceRelations?: SemanticRelationListRelationFilter
    targetRelations?: SemanticRelationListRelationFilter
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
  }

  export type SemanticNodeOrderByWithRelationInput = {
    id?: SortOrder
    nodeType?: SortOrder
    snomedCtCode?: SortOrderInput | SortOrder
    cim10Code?: SortOrderInput | SortOrder
    cim11Code?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confidence?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    sourceRelations?: SemanticRelationOrderByRelationAggregateInput
    targetRelations?: SemanticRelationOrderByRelationAggregateInput
    consultation?: ConsultationOrderByWithRelationInput
  }

  export type SemanticNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemanticNodeWhereInput | SemanticNodeWhereInput[]
    OR?: SemanticNodeWhereInput[]
    NOT?: SemanticNodeWhereInput | SemanticNodeWhereInput[]
    nodeType?: StringFilter<"SemanticNode"> | string
    snomedCtCode?: StringNullableFilter<"SemanticNode"> | string | null
    cim10Code?: StringNullableFilter<"SemanticNode"> | string | null
    cim11Code?: StringNullableFilter<"SemanticNode"> | string | null
    label?: StringFilter<"SemanticNode"> | string
    description?: StringNullableFilter<"SemanticNode"> | string | null
    embedding?: JsonNullableFilter<"SemanticNode">
    value?: JsonNullableFilter<"SemanticNode">
    unit?: StringNullableFilter<"SemanticNode"> | string | null
    createdAt?: DateTimeFilter<"SemanticNode"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticNode"> | Date | string
    confidence?: FloatNullableFilter<"SemanticNode"> | number | null
    patientId?: StringNullableFilter<"SemanticNode"> | string | null
    consultationId?: StringNullableFilter<"SemanticNode"> | string | null
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    sourceRelations?: SemanticRelationListRelationFilter
    targetRelations?: SemanticRelationListRelationFilter
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
  }, "id">

  export type SemanticNodeOrderByWithAggregationInput = {
    id?: SortOrder
    nodeType?: SortOrder
    snomedCtCode?: SortOrderInput | SortOrder
    cim10Code?: SortOrderInput | SortOrder
    cim11Code?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confidence?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    _count?: SemanticNodeCountOrderByAggregateInput
    _avg?: SemanticNodeAvgOrderByAggregateInput
    _max?: SemanticNodeMaxOrderByAggregateInput
    _min?: SemanticNodeMinOrderByAggregateInput
    _sum?: SemanticNodeSumOrderByAggregateInput
  }

  export type SemanticNodeScalarWhereWithAggregatesInput = {
    AND?: SemanticNodeScalarWhereWithAggregatesInput | SemanticNodeScalarWhereWithAggregatesInput[]
    OR?: SemanticNodeScalarWhereWithAggregatesInput[]
    NOT?: SemanticNodeScalarWhereWithAggregatesInput | SemanticNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SemanticNode"> | string
    nodeType?: StringWithAggregatesFilter<"SemanticNode"> | string
    snomedCtCode?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    cim10Code?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    cim11Code?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    label?: StringWithAggregatesFilter<"SemanticNode"> | string
    description?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    embedding?: JsonNullableWithAggregatesFilter<"SemanticNode">
    value?: JsonNullableWithAggregatesFilter<"SemanticNode">
    unit?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SemanticNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SemanticNode"> | Date | string
    confidence?: FloatNullableWithAggregatesFilter<"SemanticNode"> | number | null
    patientId?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
    consultationId?: StringNullableWithAggregatesFilter<"SemanticNode"> | string | null
  }

  export type SemanticRelationWhereInput = {
    AND?: SemanticRelationWhereInput | SemanticRelationWhereInput[]
    OR?: SemanticRelationWhereInput[]
    NOT?: SemanticRelationWhereInput | SemanticRelationWhereInput[]
    id?: StringFilter<"SemanticRelation"> | string
    sourceNodeId?: StringFilter<"SemanticRelation"> | string
    targetNodeId?: StringFilter<"SemanticRelation"> | string
    relationType?: StringFilter<"SemanticRelation"> | string
    strength?: FloatNullableFilter<"SemanticRelation"> | number | null
    evidence?: StringNullableFilter<"SemanticRelation"> | string | null
    createdAt?: DateTimeFilter<"SemanticRelation"> | Date | string
    confidence?: FloatNullableFilter<"SemanticRelation"> | number | null
    sourceNode?: XOR<SemanticNodeRelationFilter, SemanticNodeWhereInput>
    targetNode?: XOR<SemanticNodeRelationFilter, SemanticNodeWhereInput>
  }

  export type SemanticRelationOrderByWithRelationInput = {
    id?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    relationType?: SortOrder
    strength?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    confidence?: SortOrderInput | SortOrder
    sourceNode?: SemanticNodeOrderByWithRelationInput
    targetNode?: SemanticNodeOrderByWithRelationInput
  }

  export type SemanticRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceNodeId_targetNodeId_relationType?: SemanticRelationSourceNodeIdTargetNodeIdRelationTypeCompoundUniqueInput
    AND?: SemanticRelationWhereInput | SemanticRelationWhereInput[]
    OR?: SemanticRelationWhereInput[]
    NOT?: SemanticRelationWhereInput | SemanticRelationWhereInput[]
    sourceNodeId?: StringFilter<"SemanticRelation"> | string
    targetNodeId?: StringFilter<"SemanticRelation"> | string
    relationType?: StringFilter<"SemanticRelation"> | string
    strength?: FloatNullableFilter<"SemanticRelation"> | number | null
    evidence?: StringNullableFilter<"SemanticRelation"> | string | null
    createdAt?: DateTimeFilter<"SemanticRelation"> | Date | string
    confidence?: FloatNullableFilter<"SemanticRelation"> | number | null
    sourceNode?: XOR<SemanticNodeRelationFilter, SemanticNodeWhereInput>
    targetNode?: XOR<SemanticNodeRelationFilter, SemanticNodeWhereInput>
  }, "id" | "sourceNodeId_targetNodeId_relationType">

  export type SemanticRelationOrderByWithAggregationInput = {
    id?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    relationType?: SortOrder
    strength?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    confidence?: SortOrderInput | SortOrder
    _count?: SemanticRelationCountOrderByAggregateInput
    _avg?: SemanticRelationAvgOrderByAggregateInput
    _max?: SemanticRelationMaxOrderByAggregateInput
    _min?: SemanticRelationMinOrderByAggregateInput
    _sum?: SemanticRelationSumOrderByAggregateInput
  }

  export type SemanticRelationScalarWhereWithAggregatesInput = {
    AND?: SemanticRelationScalarWhereWithAggregatesInput | SemanticRelationScalarWhereWithAggregatesInput[]
    OR?: SemanticRelationScalarWhereWithAggregatesInput[]
    NOT?: SemanticRelationScalarWhereWithAggregatesInput | SemanticRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SemanticRelation"> | string
    sourceNodeId?: StringWithAggregatesFilter<"SemanticRelation"> | string
    targetNodeId?: StringWithAggregatesFilter<"SemanticRelation"> | string
    relationType?: StringWithAggregatesFilter<"SemanticRelation"> | string
    strength?: FloatNullableWithAggregatesFilter<"SemanticRelation"> | number | null
    evidence?: StringNullableWithAggregatesFilter<"SemanticRelation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SemanticRelation"> | Date | string
    confidence?: FloatNullableWithAggregatesFilter<"SemanticRelation"> | number | null
  }

  export type ConsultationDraftWhereInput = {
    AND?: ConsultationDraftWhereInput | ConsultationDraftWhereInput[]
    OR?: ConsultationDraftWhereInput[]
    NOT?: ConsultationDraftWhereInput | ConsultationDraftWhereInput[]
    id?: StringFilter<"ConsultationDraft"> | string
    patientId?: StringFilter<"ConsultationDraft"> | string
    status?: StringFilter<"ConsultationDraft"> | string
    createdAt?: DateTimeFilter<"ConsultationDraft"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationDraft"> | Date | string
    structuredData?: JsonFilter<"ConsultationDraft">
  }

  export type ConsultationDraftOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    structuredData?: SortOrder
  }

  export type ConsultationDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationDraftWhereInput | ConsultationDraftWhereInput[]
    OR?: ConsultationDraftWhereInput[]
    NOT?: ConsultationDraftWhereInput | ConsultationDraftWhereInput[]
    patientId?: StringFilter<"ConsultationDraft"> | string
    status?: StringFilter<"ConsultationDraft"> | string
    createdAt?: DateTimeFilter<"ConsultationDraft"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationDraft"> | Date | string
    structuredData?: JsonFilter<"ConsultationDraft">
  }, "id">

  export type ConsultationDraftOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    structuredData?: SortOrder
    _count?: ConsultationDraftCountOrderByAggregateInput
    _max?: ConsultationDraftMaxOrderByAggregateInput
    _min?: ConsultationDraftMinOrderByAggregateInput
  }

  export type ConsultationDraftScalarWhereWithAggregatesInput = {
    AND?: ConsultationDraftScalarWhereWithAggregatesInput | ConsultationDraftScalarWhereWithAggregatesInput[]
    OR?: ConsultationDraftScalarWhereWithAggregatesInput[]
    NOT?: ConsultationDraftScalarWhereWithAggregatesInput | ConsultationDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultationDraft"> | string
    patientId?: StringWithAggregatesFilter<"ConsultationDraft"> | string
    status?: StringWithAggregatesFilter<"ConsultationDraft"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConsultationDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConsultationDraft"> | Date | string
    structuredData?: JsonWithAggregatesFilter<"ConsultationDraft">
  }

  export type ConsultationWhereInput = {
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    id?: StringFilter<"Consultation"> | string
    patientId?: StringFilter<"Consultation"> | string
    consultationDate?: DateTimeFilter<"Consultation"> | Date | string
    startTime?: DateTimeFilter<"Consultation"> | Date | string
    endTime?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: StringFilter<"Consultation"> | string
    rawTranscript?: StringNullableFilter<"Consultation"> | string | null
    rawText?: StringNullableFilter<"Consultation"> | string | null
    draftData?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    createdBy?: StringFilter<"Consultation"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    semanticNodes?: SemanticNodeListRelationFilter
    medicalDocuments?: MedicalDocumentListRelationFilter
    medicalReports?: MedicalReportListRelationFilter
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    billingEvents?: BillingEventListRelationFilter
  }

  export type ConsultationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    rawTranscript?: SortOrderInput | SortOrder
    rawText?: SortOrderInput | SortOrder
    draftData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    patient?: PatientOrderByWithRelationInput
    semanticNodes?: SemanticNodeOrderByRelationAggregateInput
    medicalDocuments?: MedicalDocumentOrderByRelationAggregateInput
    medicalReports?: MedicalReportOrderByRelationAggregateInput
    appointment?: AppointmentOrderByWithRelationInput
    billingEvents?: BillingEventOrderByRelationAggregateInput
  }

  export type ConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    patientId?: StringFilter<"Consultation"> | string
    consultationDate?: DateTimeFilter<"Consultation"> | Date | string
    startTime?: DateTimeFilter<"Consultation"> | Date | string
    endTime?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: StringFilter<"Consultation"> | string
    rawTranscript?: StringNullableFilter<"Consultation"> | string | null
    rawText?: StringNullableFilter<"Consultation"> | string | null
    draftData?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    createdBy?: StringFilter<"Consultation"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    semanticNodes?: SemanticNodeListRelationFilter
    medicalDocuments?: MedicalDocumentListRelationFilter
    medicalReports?: MedicalReportListRelationFilter
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    billingEvents?: BillingEventListRelationFilter
  }, "id">

  export type ConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    rawTranscript?: SortOrderInput | SortOrder
    rawText?: SortOrderInput | SortOrder
    draftData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    _count?: ConsultationCountOrderByAggregateInput
    _max?: ConsultationMaxOrderByAggregateInput
    _min?: ConsultationMinOrderByAggregateInput
  }

  export type ConsultationScalarWhereWithAggregatesInput = {
    AND?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    OR?: ConsultationScalarWhereWithAggregatesInput[]
    NOT?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consultation"> | string
    patientId?: StringWithAggregatesFilter<"Consultation"> | string
    consultationDate?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Consultation"> | Date | string | null
    status?: StringWithAggregatesFilter<"Consultation"> | string
    rawTranscript?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    rawText?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    draftData?: JsonWithAggregatesFilter<"Consultation">
    createdAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"Consultation"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"Consultation"> | string
  }

  export type BillingEventWhereInput = {
    AND?: BillingEventWhereInput | BillingEventWhereInput[]
    OR?: BillingEventWhereInput[]
    NOT?: BillingEventWhereInput | BillingEventWhereInput[]
    id?: StringFilter<"BillingEvent"> | string
    consultationId?: StringFilter<"BillingEvent"> | string
    ghmCode?: StringNullableFilter<"BillingEvent"> | string | null
    actCode?: StringNullableFilter<"BillingEvent"> | string | null
    actType?: StringFilter<"BillingEvent"> | string
    status?: StringFilter<"BillingEvent"> | string
    evidenceNodeIds?: StringNullableListFilter<"BillingEvent">
    createdAt?: DateTimeFilter<"BillingEvent"> | Date | string
    transmittedAt?: DateTimeNullableFilter<"BillingEvent"> | Date | string | null
    consultation?: XOR<ConsultationRelationFilter, ConsultationWhereInput>
  }

  export type BillingEventOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    ghmCode?: SortOrderInput | SortOrder
    actCode?: SortOrderInput | SortOrder
    actType?: SortOrder
    status?: SortOrder
    evidenceNodeIds?: SortOrder
    createdAt?: SortOrder
    transmittedAt?: SortOrderInput | SortOrder
    consultation?: ConsultationOrderByWithRelationInput
  }

  export type BillingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingEventWhereInput | BillingEventWhereInput[]
    OR?: BillingEventWhereInput[]
    NOT?: BillingEventWhereInput | BillingEventWhereInput[]
    consultationId?: StringFilter<"BillingEvent"> | string
    ghmCode?: StringNullableFilter<"BillingEvent"> | string | null
    actCode?: StringNullableFilter<"BillingEvent"> | string | null
    actType?: StringFilter<"BillingEvent"> | string
    status?: StringFilter<"BillingEvent"> | string
    evidenceNodeIds?: StringNullableListFilter<"BillingEvent">
    createdAt?: DateTimeFilter<"BillingEvent"> | Date | string
    transmittedAt?: DateTimeNullableFilter<"BillingEvent"> | Date | string | null
    consultation?: XOR<ConsultationRelationFilter, ConsultationWhereInput>
  }, "id">

  export type BillingEventOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    ghmCode?: SortOrderInput | SortOrder
    actCode?: SortOrderInput | SortOrder
    actType?: SortOrder
    status?: SortOrder
    evidenceNodeIds?: SortOrder
    createdAt?: SortOrder
    transmittedAt?: SortOrderInput | SortOrder
    _count?: BillingEventCountOrderByAggregateInput
    _max?: BillingEventMaxOrderByAggregateInput
    _min?: BillingEventMinOrderByAggregateInput
  }

  export type BillingEventScalarWhereWithAggregatesInput = {
    AND?: BillingEventScalarWhereWithAggregatesInput | BillingEventScalarWhereWithAggregatesInput[]
    OR?: BillingEventScalarWhereWithAggregatesInput[]
    NOT?: BillingEventScalarWhereWithAggregatesInput | BillingEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingEvent"> | string
    consultationId?: StringWithAggregatesFilter<"BillingEvent"> | string
    ghmCode?: StringNullableWithAggregatesFilter<"BillingEvent"> | string | null
    actCode?: StringNullableWithAggregatesFilter<"BillingEvent"> | string | null
    actType?: StringWithAggregatesFilter<"BillingEvent"> | string
    status?: StringWithAggregatesFilter<"BillingEvent"> | string
    evidenceNodeIds?: StringNullableListFilter<"BillingEvent">
    createdAt?: DateTimeWithAggregatesFilter<"BillingEvent"> | Date | string
    transmittedAt?: DateTimeNullableWithAggregatesFilter<"BillingEvent"> | Date | string | null
  }

  export type AllergyWhereInput = {
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    id?: StringFilter<"Allergy"> | string
    patientId?: StringFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    snomedCtCode?: StringNullableFilter<"Allergy"> | string | null
    severity?: StringFilter<"Allergy"> | string
    createdAt?: DateTimeFilter<"Allergy"> | Date | string
    source?: StringNullableFilter<"Allergy"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type AllergyOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    snomedCtCode?: SortOrderInput | SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    source?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AllergyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllergyWhereInput | AllergyWhereInput[]
    OR?: AllergyWhereInput[]
    NOT?: AllergyWhereInput | AllergyWhereInput[]
    patientId?: StringFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    snomedCtCode?: StringNullableFilter<"Allergy"> | string | null
    severity?: StringFilter<"Allergy"> | string
    createdAt?: DateTimeFilter<"Allergy"> | Date | string
    source?: StringNullableFilter<"Allergy"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type AllergyOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    snomedCtCode?: SortOrderInput | SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    source?: SortOrderInput | SortOrder
    _count?: AllergyCountOrderByAggregateInput
    _max?: AllergyMaxOrderByAggregateInput
    _min?: AllergyMinOrderByAggregateInput
  }

  export type AllergyScalarWhereWithAggregatesInput = {
    AND?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    OR?: AllergyScalarWhereWithAggregatesInput[]
    NOT?: AllergyScalarWhereWithAggregatesInput | AllergyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allergy"> | string
    patientId?: StringWithAggregatesFilter<"Allergy"> | string
    substance?: StringWithAggregatesFilter<"Allergy"> | string
    snomedCtCode?: StringNullableWithAggregatesFilter<"Allergy"> | string | null
    severity?: StringWithAggregatesFilter<"Allergy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Allergy"> | Date | string
    source?: StringNullableWithAggregatesFilter<"Allergy"> | string | null
  }

  export type MedicalDocumentWhereInput = {
    AND?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    OR?: MedicalDocumentWhereInput[]
    NOT?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    id?: StringFilter<"MedicalDocument"> | string
    patientId?: StringFilter<"MedicalDocument"> | string
    documentType?: StringFilter<"MedicalDocument"> | string
    title?: StringFilter<"MedicalDocument"> | string
    content?: JsonFilter<"MedicalDocument">
    rawContent?: StringNullableFilter<"MedicalDocument"> | string | null
    documentDate?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdBy?: StringFilter<"MedicalDocument"> | string
    consultationId?: StringNullableFilter<"MedicalDocument"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    medicalReport?: XOR<MedicalReportNullableRelationFilter, MedicalReportWhereInput> | null
    laboratoryResult?: XOR<LaboratoryResultNullableRelationFilter, LaboratoryResultWhereInput> | null
    medicalImage?: XOR<MedicalImageNullableRelationFilter, MedicalImageWhereInput> | null
    attachments?: DocumentAttachmentListRelationFilter
  }

  export type MedicalDocumentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    rawContent?: SortOrderInput | SortOrder
    documentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    medicalReport?: MedicalReportOrderByWithRelationInput
    laboratoryResult?: LaboratoryResultOrderByWithRelationInput
    medicalImage?: MedicalImageOrderByWithRelationInput
    attachments?: DocumentAttachmentOrderByRelationAggregateInput
  }

  export type MedicalDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    OR?: MedicalDocumentWhereInput[]
    NOT?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    patientId?: StringFilter<"MedicalDocument"> | string
    documentType?: StringFilter<"MedicalDocument"> | string
    title?: StringFilter<"MedicalDocument"> | string
    content?: JsonFilter<"MedicalDocument">
    rawContent?: StringNullableFilter<"MedicalDocument"> | string | null
    documentDate?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdBy?: StringFilter<"MedicalDocument"> | string
    consultationId?: StringNullableFilter<"MedicalDocument"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    medicalReport?: XOR<MedicalReportNullableRelationFilter, MedicalReportWhereInput> | null
    laboratoryResult?: XOR<LaboratoryResultNullableRelationFilter, LaboratoryResultWhereInput> | null
    medicalImage?: XOR<MedicalImageNullableRelationFilter, MedicalImageWhereInput> | null
    attachments?: DocumentAttachmentListRelationFilter
  }, "id">

  export type MedicalDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    rawContent?: SortOrderInput | SortOrder
    documentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    _count?: MedicalDocumentCountOrderByAggregateInput
    _max?: MedicalDocumentMaxOrderByAggregateInput
    _min?: MedicalDocumentMinOrderByAggregateInput
  }

  export type MedicalDocumentScalarWhereWithAggregatesInput = {
    AND?: MedicalDocumentScalarWhereWithAggregatesInput | MedicalDocumentScalarWhereWithAggregatesInput[]
    OR?: MedicalDocumentScalarWhereWithAggregatesInput[]
    NOT?: MedicalDocumentScalarWhereWithAggregatesInput | MedicalDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalDocument"> | string
    patientId?: StringWithAggregatesFilter<"MedicalDocument"> | string
    documentType?: StringWithAggregatesFilter<"MedicalDocument"> | string
    title?: StringWithAggregatesFilter<"MedicalDocument"> | string
    content?: JsonWithAggregatesFilter<"MedicalDocument">
    rawContent?: StringNullableWithAggregatesFilter<"MedicalDocument"> | string | null
    documentDate?: DateTimeWithAggregatesFilter<"MedicalDocument"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalDocument"> | Date | string
    createdBy?: StringWithAggregatesFilter<"MedicalDocument"> | string
    consultationId?: StringNullableWithAggregatesFilter<"MedicalDocument"> | string | null
  }

  export type DocumentAttachmentWhereInput = {
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    id?: StringFilter<"DocumentAttachment"> | string
    documentId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    mimeType?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    uploadedBy?: StringFilter<"DocumentAttachment"> | string
    document?: XOR<MedicalDocumentRelationFilter, MedicalDocumentWhereInput>
  }

  export type DocumentAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    document?: MedicalDocumentOrderByWithRelationInput
  }

  export type DocumentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    documentId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    mimeType?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    uploadedBy?: StringFilter<"DocumentAttachment"> | string
    document?: XOR<MedicalDocumentRelationFilter, MedicalDocumentWhereInput>
  }, "id">

  export type DocumentAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    _count?: DocumentAttachmentCountOrderByAggregateInput
    _avg?: DocumentAttachmentAvgOrderByAggregateInput
    _max?: DocumentAttachmentMaxOrderByAggregateInput
    _min?: DocumentAttachmentMinOrderByAggregateInput
    _sum?: DocumentAttachmentSumOrderByAggregateInput
  }

  export type DocumentAttachmentScalarWhereWithAggregatesInput = {
    AND?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    OR?: DocumentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    documentId?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileName?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    filePath?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    mimeType?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"DocumentAttachment"> | Date | string
    uploadedBy?: StringWithAggregatesFilter<"DocumentAttachment"> | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    medicationName?: StringFilter<"Prescription"> | string
    atcCode?: StringNullableFilter<"Prescription"> | string | null
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
    duration?: StringNullableFilter<"Prescription"> | string | null
    status?: StringFilter<"Prescription"> | string
    safetyChecks?: JsonNullableFilter<"Prescription">
    outpassReason?: StringNullableFilter<"Prescription"> | string | null
    documentId?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    prescribedBy?: StringFilter<"Prescription"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationName?: SortOrder
    atcCode?: SortOrderInput | SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    safetyChecks?: SortOrderInput | SortOrder
    outpassReason?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prescribedBy?: SortOrder
    patient?: PatientOrderByWithRelationInput
    document?: MedicalDocumentOrderByWithRelationInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    patientId?: StringFilter<"Prescription"> | string
    medicationName?: StringFilter<"Prescription"> | string
    atcCode?: StringNullableFilter<"Prescription"> | string | null
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
    duration?: StringNullableFilter<"Prescription"> | string | null
    status?: StringFilter<"Prescription"> | string
    safetyChecks?: JsonNullableFilter<"Prescription">
    outpassReason?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    prescribedBy?: StringFilter<"Prescription"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }, "id" | "documentId">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationName?: SortOrder
    atcCode?: SortOrderInput | SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    safetyChecks?: SortOrderInput | SortOrder
    outpassReason?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prescribedBy?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    patientId?: StringWithAggregatesFilter<"Prescription"> | string
    medicationName?: StringWithAggregatesFilter<"Prescription"> | string
    atcCode?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    dosage?: StringWithAggregatesFilter<"Prescription"> | string
    frequency?: StringWithAggregatesFilter<"Prescription"> | string
    duration?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    status?: StringWithAggregatesFilter<"Prescription"> | string
    safetyChecks?: JsonNullableWithAggregatesFilter<"Prescription">
    outpassReason?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    prescribedBy?: StringWithAggregatesFilter<"Prescription"> | string
  }

  export type MedicalReportWhereInput = {
    AND?: MedicalReportWhereInput | MedicalReportWhereInput[]
    OR?: MedicalReportWhereInput[]
    NOT?: MedicalReportWhereInput | MedicalReportWhereInput[]
    id?: StringFilter<"MedicalReport"> | string
    patientId?: StringFilter<"MedicalReport"> | string
    reportType?: StringFilter<"MedicalReport"> | string
    title?: StringFilter<"MedicalReport"> | string
    chiefComplaint?: StringNullableFilter<"MedicalReport"> | string | null
    history?: StringNullableFilter<"MedicalReport"> | string | null
    examination?: StringNullableFilter<"MedicalReport"> | string | null
    assessment?: StringNullableFilter<"MedicalReport"> | string | null
    plan?: StringNullableFilter<"MedicalReport"> | string | null
    documentId?: StringNullableFilter<"MedicalReport"> | string | null
    consultationId?: StringNullableFilter<"MedicalReport"> | string | null
    reportDate?: DateTimeFilter<"MedicalReport"> | Date | string
    createdAt?: DateTimeFilter<"MedicalReport"> | Date | string
    createdBy?: StringFilter<"MedicalReport"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
  }

  export type MedicalReportOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    examination?: SortOrderInput | SortOrder
    assessment?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    patient?: PatientOrderByWithRelationInput
    document?: MedicalDocumentOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
  }

  export type MedicalReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: MedicalReportWhereInput | MedicalReportWhereInput[]
    OR?: MedicalReportWhereInput[]
    NOT?: MedicalReportWhereInput | MedicalReportWhereInput[]
    patientId?: StringFilter<"MedicalReport"> | string
    reportType?: StringFilter<"MedicalReport"> | string
    title?: StringFilter<"MedicalReport"> | string
    chiefComplaint?: StringNullableFilter<"MedicalReport"> | string | null
    history?: StringNullableFilter<"MedicalReport"> | string | null
    examination?: StringNullableFilter<"MedicalReport"> | string | null
    assessment?: StringNullableFilter<"MedicalReport"> | string | null
    plan?: StringNullableFilter<"MedicalReport"> | string | null
    consultationId?: StringNullableFilter<"MedicalReport"> | string | null
    reportDate?: DateTimeFilter<"MedicalReport"> | Date | string
    createdAt?: DateTimeFilter<"MedicalReport"> | Date | string
    createdBy?: StringFilter<"MedicalReport"> | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
  }, "id" | "documentId">

  export type MedicalReportOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    examination?: SortOrderInput | SortOrder
    assessment?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    reportDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: MedicalReportCountOrderByAggregateInput
    _max?: MedicalReportMaxOrderByAggregateInput
    _min?: MedicalReportMinOrderByAggregateInput
  }

  export type MedicalReportScalarWhereWithAggregatesInput = {
    AND?: MedicalReportScalarWhereWithAggregatesInput | MedicalReportScalarWhereWithAggregatesInput[]
    OR?: MedicalReportScalarWhereWithAggregatesInput[]
    NOT?: MedicalReportScalarWhereWithAggregatesInput | MedicalReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalReport"> | string
    patientId?: StringWithAggregatesFilter<"MedicalReport"> | string
    reportType?: StringWithAggregatesFilter<"MedicalReport"> | string
    title?: StringWithAggregatesFilter<"MedicalReport"> | string
    chiefComplaint?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    history?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    examination?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    assessment?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    plan?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    consultationId?: StringNullableWithAggregatesFilter<"MedicalReport"> | string | null
    reportDate?: DateTimeWithAggregatesFilter<"MedicalReport"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalReport"> | Date | string
    createdBy?: StringWithAggregatesFilter<"MedicalReport"> | string
  }

  export type LaboratoryResultWhereInput = {
    AND?: LaboratoryResultWhereInput | LaboratoryResultWhereInput[]
    OR?: LaboratoryResultWhereInput[]
    NOT?: LaboratoryResultWhereInput | LaboratoryResultWhereInput[]
    id?: StringFilter<"LaboratoryResult"> | string
    patientId?: StringFilter<"LaboratoryResult"> | string
    testName?: StringFilter<"LaboratoryResult"> | string
    testCode?: StringNullableFilter<"LaboratoryResult"> | string | null
    resultValue?: StringFilter<"LaboratoryResult"> | string
    unit?: StringNullableFilter<"LaboratoryResult"> | string | null
    referenceRange?: StringNullableFilter<"LaboratoryResult"> | string | null
    status?: StringFilter<"LaboratoryResult"> | string
    testDate?: DateTimeFilter<"LaboratoryResult"> | Date | string
    receivedAt?: DateTimeFilter<"LaboratoryResult"> | Date | string
    laboratoryName?: StringNullableFilter<"LaboratoryResult"> | string | null
    documentId?: StringNullableFilter<"LaboratoryResult"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }

  export type LaboratoryResultOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    testCode?: SortOrderInput | SortOrder
    resultValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    referenceRange?: SortOrderInput | SortOrder
    status?: SortOrder
    testDate?: SortOrder
    receivedAt?: SortOrder
    laboratoryName?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    document?: MedicalDocumentOrderByWithRelationInput
  }

  export type LaboratoryResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: LaboratoryResultWhereInput | LaboratoryResultWhereInput[]
    OR?: LaboratoryResultWhereInput[]
    NOT?: LaboratoryResultWhereInput | LaboratoryResultWhereInput[]
    patientId?: StringFilter<"LaboratoryResult"> | string
    testName?: StringFilter<"LaboratoryResult"> | string
    testCode?: StringNullableFilter<"LaboratoryResult"> | string | null
    resultValue?: StringFilter<"LaboratoryResult"> | string
    unit?: StringNullableFilter<"LaboratoryResult"> | string | null
    referenceRange?: StringNullableFilter<"LaboratoryResult"> | string | null
    status?: StringFilter<"LaboratoryResult"> | string
    testDate?: DateTimeFilter<"LaboratoryResult"> | Date | string
    receivedAt?: DateTimeFilter<"LaboratoryResult"> | Date | string
    laboratoryName?: StringNullableFilter<"LaboratoryResult"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }, "id" | "documentId">

  export type LaboratoryResultOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    testCode?: SortOrderInput | SortOrder
    resultValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    referenceRange?: SortOrderInput | SortOrder
    status?: SortOrder
    testDate?: SortOrder
    receivedAt?: SortOrder
    laboratoryName?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: LaboratoryResultCountOrderByAggregateInput
    _max?: LaboratoryResultMaxOrderByAggregateInput
    _min?: LaboratoryResultMinOrderByAggregateInput
  }

  export type LaboratoryResultScalarWhereWithAggregatesInput = {
    AND?: LaboratoryResultScalarWhereWithAggregatesInput | LaboratoryResultScalarWhereWithAggregatesInput[]
    OR?: LaboratoryResultScalarWhereWithAggregatesInput[]
    NOT?: LaboratoryResultScalarWhereWithAggregatesInput | LaboratoryResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaboratoryResult"> | string
    patientId?: StringWithAggregatesFilter<"LaboratoryResult"> | string
    testName?: StringWithAggregatesFilter<"LaboratoryResult"> | string
    testCode?: StringNullableWithAggregatesFilter<"LaboratoryResult"> | string | null
    resultValue?: StringWithAggregatesFilter<"LaboratoryResult"> | string
    unit?: StringNullableWithAggregatesFilter<"LaboratoryResult"> | string | null
    referenceRange?: StringNullableWithAggregatesFilter<"LaboratoryResult"> | string | null
    status?: StringWithAggregatesFilter<"LaboratoryResult"> | string
    testDate?: DateTimeWithAggregatesFilter<"LaboratoryResult"> | Date | string
    receivedAt?: DateTimeWithAggregatesFilter<"LaboratoryResult"> | Date | string
    laboratoryName?: StringNullableWithAggregatesFilter<"LaboratoryResult"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"LaboratoryResult"> | string | null
  }

  export type MedicalImageWhereInput = {
    AND?: MedicalImageWhereInput | MedicalImageWhereInput[]
    OR?: MedicalImageWhereInput[]
    NOT?: MedicalImageWhereInput | MedicalImageWhereInput[]
    id?: StringFilter<"MedicalImage"> | string
    patientId?: StringFilter<"MedicalImage"> | string
    studyInstanceUid?: StringFilter<"MedicalImage"> | string
    seriesInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    sopInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    modality?: StringFilter<"MedicalImage"> | string
    bodyPart?: StringNullableFilter<"MedicalImage"> | string | null
    studyDescription?: StringNullableFilter<"MedicalImage"> | string | null
    seriesDescription?: StringNullableFilter<"MedicalImage"> | string | null
    filePath?: StringFilter<"MedicalImage"> | string
    fileSize?: IntFilter<"MedicalImage"> | number
    documentId?: StringNullableFilter<"MedicalImage"> | string | null
    acquisitionDate?: DateTimeFilter<"MedicalImage"> | Date | string
    createdAt?: DateTimeFilter<"MedicalImage"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }

  export type MedicalImageOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    studyInstanceUid?: SortOrder
    seriesInstanceUid?: SortOrderInput | SortOrder
    sopInstanceUid?: SortOrderInput | SortOrder
    modality?: SortOrder
    bodyPart?: SortOrderInput | SortOrder
    studyDescription?: SortOrderInput | SortOrder
    seriesDescription?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    documentId?: SortOrderInput | SortOrder
    acquisitionDate?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    document?: MedicalDocumentOrderByWithRelationInput
  }

  export type MedicalImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: MedicalImageWhereInput | MedicalImageWhereInput[]
    OR?: MedicalImageWhereInput[]
    NOT?: MedicalImageWhereInput | MedicalImageWhereInput[]
    patientId?: StringFilter<"MedicalImage"> | string
    studyInstanceUid?: StringFilter<"MedicalImage"> | string
    seriesInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    sopInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    modality?: StringFilter<"MedicalImage"> | string
    bodyPart?: StringNullableFilter<"MedicalImage"> | string | null
    studyDescription?: StringNullableFilter<"MedicalImage"> | string | null
    seriesDescription?: StringNullableFilter<"MedicalImage"> | string | null
    filePath?: StringFilter<"MedicalImage"> | string
    fileSize?: IntFilter<"MedicalImage"> | number
    acquisitionDate?: DateTimeFilter<"MedicalImage"> | Date | string
    createdAt?: DateTimeFilter<"MedicalImage"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    document?: XOR<MedicalDocumentNullableRelationFilter, MedicalDocumentWhereInput> | null
  }, "id" | "documentId">

  export type MedicalImageOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    studyInstanceUid?: SortOrder
    seriesInstanceUid?: SortOrderInput | SortOrder
    sopInstanceUid?: SortOrderInput | SortOrder
    modality?: SortOrder
    bodyPart?: SortOrderInput | SortOrder
    studyDescription?: SortOrderInput | SortOrder
    seriesDescription?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    documentId?: SortOrderInput | SortOrder
    acquisitionDate?: SortOrder
    createdAt?: SortOrder
    _count?: MedicalImageCountOrderByAggregateInput
    _avg?: MedicalImageAvgOrderByAggregateInput
    _max?: MedicalImageMaxOrderByAggregateInput
    _min?: MedicalImageMinOrderByAggregateInput
    _sum?: MedicalImageSumOrderByAggregateInput
  }

  export type MedicalImageScalarWhereWithAggregatesInput = {
    AND?: MedicalImageScalarWhereWithAggregatesInput | MedicalImageScalarWhereWithAggregatesInput[]
    OR?: MedicalImageScalarWhereWithAggregatesInput[]
    NOT?: MedicalImageScalarWhereWithAggregatesInput | MedicalImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalImage"> | string
    patientId?: StringWithAggregatesFilter<"MedicalImage"> | string
    studyInstanceUid?: StringWithAggregatesFilter<"MedicalImage"> | string
    seriesInstanceUid?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    sopInstanceUid?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    modality?: StringWithAggregatesFilter<"MedicalImage"> | string
    bodyPart?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    studyDescription?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    seriesDescription?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    filePath?: StringWithAggregatesFilter<"MedicalImage"> | string
    fileSize?: IntWithAggregatesFilter<"MedicalImage"> | number
    documentId?: StringNullableWithAggregatesFilter<"MedicalImage"> | string | null
    acquisitionDate?: DateTimeWithAggregatesFilter<"MedicalImage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalImage"> | Date | string
  }

  export type FeedbackEventWhereInput = {
    AND?: FeedbackEventWhereInput | FeedbackEventWhereInput[]
    OR?: FeedbackEventWhereInput[]
    NOT?: FeedbackEventWhereInput | FeedbackEventWhereInput[]
    id?: StringFilter<"FeedbackEvent"> | string
    entityType?: StringFilter<"FeedbackEvent"> | string
    entityId?: StringFilter<"FeedbackEvent"> | string
    originalValue?: JsonFilter<"FeedbackEvent">
    correctedValue?: JsonFilter<"FeedbackEvent">
    correctionReason?: StringNullableFilter<"FeedbackEvent"> | string | null
    createdAt?: DateTimeFilter<"FeedbackEvent"> | Date | string
    correctedBy?: StringFilter<"FeedbackEvent"> | string
  }

  export type FeedbackEventOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    originalValue?: SortOrder
    correctedValue?: SortOrder
    correctionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    correctedBy?: SortOrder
  }

  export type FeedbackEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackEventWhereInput | FeedbackEventWhereInput[]
    OR?: FeedbackEventWhereInput[]
    NOT?: FeedbackEventWhereInput | FeedbackEventWhereInput[]
    entityType?: StringFilter<"FeedbackEvent"> | string
    entityId?: StringFilter<"FeedbackEvent"> | string
    originalValue?: JsonFilter<"FeedbackEvent">
    correctedValue?: JsonFilter<"FeedbackEvent">
    correctionReason?: StringNullableFilter<"FeedbackEvent"> | string | null
    createdAt?: DateTimeFilter<"FeedbackEvent"> | Date | string
    correctedBy?: StringFilter<"FeedbackEvent"> | string
  }, "id">

  export type FeedbackEventOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    originalValue?: SortOrder
    correctedValue?: SortOrder
    correctionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    correctedBy?: SortOrder
    _count?: FeedbackEventCountOrderByAggregateInput
    _max?: FeedbackEventMaxOrderByAggregateInput
    _min?: FeedbackEventMinOrderByAggregateInput
  }

  export type FeedbackEventScalarWhereWithAggregatesInput = {
    AND?: FeedbackEventScalarWhereWithAggregatesInput | FeedbackEventScalarWhereWithAggregatesInput[]
    OR?: FeedbackEventScalarWhereWithAggregatesInput[]
    NOT?: FeedbackEventScalarWhereWithAggregatesInput | FeedbackEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedbackEvent"> | string
    entityType?: StringWithAggregatesFilter<"FeedbackEvent"> | string
    entityId?: StringWithAggregatesFilter<"FeedbackEvent"> | string
    originalValue?: JsonWithAggregatesFilter<"FeedbackEvent">
    correctedValue?: JsonWithAggregatesFilter<"FeedbackEvent">
    correctionReason?: StringNullableWithAggregatesFilter<"FeedbackEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeedbackEvent"> | Date | string
    correctedBy?: StringWithAggregatesFilter<"FeedbackEvent"> | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringNullableFilter<"Appointment"> | string | null
    doctorName?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    title?: StringNullableFilter<"Appointment"> | string | null
    description?: StringNullableFilter<"Appointment"> | string | null
    status?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    consultationId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringFilter<"Appointment"> | string
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
    reminders?: AppointmentReminderListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    appointmentType?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
    reminders?: AppointmentReminderOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consultationId?: string
    doctorId_startTime_endTime?: AppointmentDoctorIdStartTimeEndTimeCompoundUniqueInput
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringNullableFilter<"Appointment"> | string | null
    doctorName?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    title?: StringNullableFilter<"Appointment"> | string | null
    description?: StringNullableFilter<"Appointment"> | string | null
    status?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringFilter<"Appointment"> | string
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableRelationFilter, ConsultationWhereInput> | null
    reminders?: AppointmentReminderListRelationFilter
  }, "id" | "consultationId" | "doctorId_startTime_endTime">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    appointmentType?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    consultationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    doctorId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    doctorName?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    duration?: IntWithAggregatesFilter<"Appointment"> | number
    appointmentType?: StringWithAggregatesFilter<"Appointment"> | string
    title?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    description?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: StringWithAggregatesFilter<"Appointment"> | string
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    consultationId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Appointment"> | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type AppointmentReminderWhereInput = {
    AND?: AppointmentReminderWhereInput | AppointmentReminderWhereInput[]
    OR?: AppointmentReminderWhereInput[]
    NOT?: AppointmentReminderWhereInput | AppointmentReminderWhereInput[]
    id?: StringFilter<"AppointmentReminder"> | string
    appointmentId?: StringFilter<"AppointmentReminder"> | string
    reminderType?: StringFilter<"AppointmentReminder"> | string
    reminderTime?: DateTimeFilter<"AppointmentReminder"> | Date | string
    status?: StringFilter<"AppointmentReminder"> | string
    sentAt?: DateTimeNullableFilter<"AppointmentReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"AppointmentReminder"> | Date | string
    appointment?: XOR<AppointmentRelationFilter, AppointmentWhereInput>
  }

  export type AppointmentReminderOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reminderType?: SortOrder
    reminderTime?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type AppointmentReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentReminderWhereInput | AppointmentReminderWhereInput[]
    OR?: AppointmentReminderWhereInput[]
    NOT?: AppointmentReminderWhereInput | AppointmentReminderWhereInput[]
    appointmentId?: StringFilter<"AppointmentReminder"> | string
    reminderType?: StringFilter<"AppointmentReminder"> | string
    reminderTime?: DateTimeFilter<"AppointmentReminder"> | Date | string
    status?: StringFilter<"AppointmentReminder"> | string
    sentAt?: DateTimeNullableFilter<"AppointmentReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"AppointmentReminder"> | Date | string
    appointment?: XOR<AppointmentRelationFilter, AppointmentWhereInput>
  }, "id">

  export type AppointmentReminderOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reminderType?: SortOrder
    reminderTime?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AppointmentReminderCountOrderByAggregateInput
    _max?: AppointmentReminderMaxOrderByAggregateInput
    _min?: AppointmentReminderMinOrderByAggregateInput
  }

  export type AppointmentReminderScalarWhereWithAggregatesInput = {
    AND?: AppointmentReminderScalarWhereWithAggregatesInput | AppointmentReminderScalarWhereWithAggregatesInput[]
    OR?: AppointmentReminderScalarWhereWithAggregatesInput[]
    NOT?: AppointmentReminderScalarWhereWithAggregatesInput | AppointmentReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppointmentReminder"> | string
    appointmentId?: StringWithAggregatesFilter<"AppointmentReminder"> | string
    reminderType?: StringWithAggregatesFilter<"AppointmentReminder"> | string
    reminderTime?: DateTimeWithAggregatesFilter<"AppointmentReminder"> | Date | string
    status?: StringWithAggregatesFilter<"AppointmentReminder"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"AppointmentReminder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AppointmentReminder"> | Date | string
  }

  export type InternalMessageWhereInput = {
    AND?: InternalMessageWhereInput | InternalMessageWhereInput[]
    OR?: InternalMessageWhereInput[]
    NOT?: InternalMessageWhereInput | InternalMessageWhereInput[]
    id?: StringFilter<"InternalMessage"> | string
    senderId?: StringFilter<"InternalMessage"> | string
    recipientId?: StringNullableFilter<"InternalMessage"> | string | null
    threadId?: StringNullableFilter<"InternalMessage"> | string | null
    subject?: StringNullableFilter<"InternalMessage"> | string | null
    content?: StringFilter<"InternalMessage"> | string
    messageType?: StringFilter<"InternalMessage"> | string
    status?: StringFilter<"InternalMessage"> | string
    createdAt?: DateTimeFilter<"InternalMessage"> | Date | string
    readAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
    thread?: XOR<MessageThreadNullableRelationFilter, MessageThreadWhereInput> | null
    attachments?: MessageAttachmentListRelationFilter
  }

  export type InternalMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type InternalMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InternalMessageWhereInput | InternalMessageWhereInput[]
    OR?: InternalMessageWhereInput[]
    NOT?: InternalMessageWhereInput | InternalMessageWhereInput[]
    senderId?: StringFilter<"InternalMessage"> | string
    recipientId?: StringNullableFilter<"InternalMessage"> | string | null
    threadId?: StringNullableFilter<"InternalMessage"> | string | null
    subject?: StringNullableFilter<"InternalMessage"> | string | null
    content?: StringFilter<"InternalMessage"> | string
    messageType?: StringFilter<"InternalMessage"> | string
    status?: StringFilter<"InternalMessage"> | string
    createdAt?: DateTimeFilter<"InternalMessage"> | Date | string
    readAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
    thread?: XOR<MessageThreadNullableRelationFilter, MessageThreadWhereInput> | null
    attachments?: MessageAttachmentListRelationFilter
  }, "id">

  export type InternalMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    _count?: InternalMessageCountOrderByAggregateInput
    _max?: InternalMessageMaxOrderByAggregateInput
    _min?: InternalMessageMinOrderByAggregateInput
  }

  export type InternalMessageScalarWhereWithAggregatesInput = {
    AND?: InternalMessageScalarWhereWithAggregatesInput | InternalMessageScalarWhereWithAggregatesInput[]
    OR?: InternalMessageScalarWhereWithAggregatesInput[]
    NOT?: InternalMessageScalarWhereWithAggregatesInput | InternalMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternalMessage"> | string
    senderId?: StringWithAggregatesFilter<"InternalMessage"> | string
    recipientId?: StringNullableWithAggregatesFilter<"InternalMessage"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"InternalMessage"> | string | null
    subject?: StringNullableWithAggregatesFilter<"InternalMessage"> | string | null
    content?: StringWithAggregatesFilter<"InternalMessage"> | string
    messageType?: StringWithAggregatesFilter<"InternalMessage"> | string
    status?: StringWithAggregatesFilter<"InternalMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InternalMessage"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"InternalMessage"> | Date | string | null
    archivedAt?: DateTimeNullableWithAggregatesFilter<"InternalMessage"> | Date | string | null
  }

  export type MessageThreadWhereInput = {
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    id?: StringFilter<"MessageThread"> | string
    name?: StringNullableFilter<"MessageThread"> | string | null
    threadType?: StringFilter<"MessageThread"> | string
    description?: StringNullableFilter<"MessageThread"> | string | null
    participantIds?: StringNullableListFilter<"MessageThread">
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeFilter<"MessageThread"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"MessageThread"> | Date | string | null
    createdBy?: StringFilter<"MessageThread"> | string
    messages?: InternalMessageListRelationFilter
  }

  export type MessageThreadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    threadType?: SortOrder
    description?: SortOrderInput | SortOrder
    participantIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    messages?: InternalMessageOrderByRelationAggregateInput
  }

  export type MessageThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    name?: StringNullableFilter<"MessageThread"> | string | null
    threadType?: StringFilter<"MessageThread"> | string
    description?: StringNullableFilter<"MessageThread"> | string | null
    participantIds?: StringNullableListFilter<"MessageThread">
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeFilter<"MessageThread"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"MessageThread"> | Date | string | null
    createdBy?: StringFilter<"MessageThread"> | string
    messages?: InternalMessageListRelationFilter
  }, "id">

  export type MessageThreadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    threadType?: SortOrder
    description?: SortOrderInput | SortOrder
    participantIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    _count?: MessageThreadCountOrderByAggregateInput
    _max?: MessageThreadMaxOrderByAggregateInput
    _min?: MessageThreadMinOrderByAggregateInput
  }

  export type MessageThreadScalarWhereWithAggregatesInput = {
    AND?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    OR?: MessageThreadScalarWhereWithAggregatesInput[]
    NOT?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageThread"> | string
    name?: StringNullableWithAggregatesFilter<"MessageThread"> | string | null
    threadType?: StringWithAggregatesFilter<"MessageThread"> | string
    description?: StringNullableWithAggregatesFilter<"MessageThread"> | string | null
    participantIds?: StringNullableListFilter<"MessageThread">
    createdAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"MessageThread"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"MessageThread"> | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    filePath?: StringFilter<"MessageAttachment"> | string
    mimeType?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<InternalMessageRelationFilter, InternalMessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    message?: InternalMessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    filePath?: StringFilter<"MessageAttachment"> | string
    mimeType?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<InternalMessageRelationFilter, InternalMessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileName?: StringWithAggregatesFilter<"MessageAttachment"> | string
    filePath?: StringWithAggregatesFilter<"MessageAttachment"> | string
    mimeType?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"MessageAttachment"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
  }

  export type StaffMemberWhereInput = {
    AND?: StaffMemberWhereInput | StaffMemberWhereInput[]
    OR?: StaffMemberWhereInput[]
    NOT?: StaffMemberWhereInput | StaffMemberWhereInput[]
    id?: StringFilter<"StaffMember"> | string
    firstName?: StringFilter<"StaffMember"> | string
    lastName?: StringFilter<"StaffMember"> | string
    email?: StringFilter<"StaffMember"> | string
    phone?: StringNullableFilter<"StaffMember"> | string | null
    role?: StringFilter<"StaffMember"> | string
    speciality?: StringNullableFilter<"StaffMember"> | string | null
    qualifications?: StringNullableListFilter<"StaffMember">
    status?: StringFilter<"StaffMember"> | string
    hiredDate?: DateTimeNullableFilter<"StaffMember"> | Date | string | null
    createdAt?: DateTimeFilter<"StaffMember"> | Date | string
    updatedAt?: DateTimeFilter<"StaffMember"> | Date | string
    shifts?: ShiftListRelationFilter
    leaves?: LeaveListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type StaffMemberOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    speciality?: SortOrderInput | SortOrder
    qualifications?: SortOrder
    status?: SortOrder
    hiredDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shifts?: ShiftOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type StaffMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: StaffMemberWhereInput | StaffMemberWhereInput[]
    OR?: StaffMemberWhereInput[]
    NOT?: StaffMemberWhereInput | StaffMemberWhereInput[]
    firstName?: StringFilter<"StaffMember"> | string
    lastName?: StringFilter<"StaffMember"> | string
    phone?: StringNullableFilter<"StaffMember"> | string | null
    role?: StringFilter<"StaffMember"> | string
    speciality?: StringNullableFilter<"StaffMember"> | string | null
    qualifications?: StringNullableListFilter<"StaffMember">
    status?: StringFilter<"StaffMember"> | string
    hiredDate?: DateTimeNullableFilter<"StaffMember"> | Date | string | null
    createdAt?: DateTimeFilter<"StaffMember"> | Date | string
    updatedAt?: DateTimeFilter<"StaffMember"> | Date | string
    shifts?: ShiftListRelationFilter
    leaves?: LeaveListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id" | "email">

  export type StaffMemberOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    speciality?: SortOrderInput | SortOrder
    qualifications?: SortOrder
    status?: SortOrder
    hiredDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffMemberCountOrderByAggregateInput
    _max?: StaffMemberMaxOrderByAggregateInput
    _min?: StaffMemberMinOrderByAggregateInput
  }

  export type StaffMemberScalarWhereWithAggregatesInput = {
    AND?: StaffMemberScalarWhereWithAggregatesInput | StaffMemberScalarWhereWithAggregatesInput[]
    OR?: StaffMemberScalarWhereWithAggregatesInput[]
    NOT?: StaffMemberScalarWhereWithAggregatesInput | StaffMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffMember"> | string
    firstName?: StringWithAggregatesFilter<"StaffMember"> | string
    lastName?: StringWithAggregatesFilter<"StaffMember"> | string
    email?: StringWithAggregatesFilter<"StaffMember"> | string
    phone?: StringNullableWithAggregatesFilter<"StaffMember"> | string | null
    role?: StringWithAggregatesFilter<"StaffMember"> | string
    speciality?: StringNullableWithAggregatesFilter<"StaffMember"> | string | null
    qualifications?: StringNullableListFilter<"StaffMember">
    status?: StringWithAggregatesFilter<"StaffMember"> | string
    hiredDate?: DateTimeNullableWithAggregatesFilter<"StaffMember"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffMember"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    staffMemberId?: StringFilter<"Shift"> | string
    startDate?: DateTimeFilter<"Shift"> | Date | string
    endDate?: DateTimeFilter<"Shift"> | Date | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    shiftType?: StringFilter<"Shift"> | string
    location?: StringNullableFilter<"Shift"> | string | null
    status?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    createdBy?: StringFilter<"Shift"> | string
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    shiftType?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    staffMember?: StaffMemberOrderByWithRelationInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    staffMemberId?: StringFilter<"Shift"> | string
    startDate?: DateTimeFilter<"Shift"> | Date | string
    endDate?: DateTimeFilter<"Shift"> | Date | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    shiftType?: StringFilter<"Shift"> | string
    location?: StringNullableFilter<"Shift"> | string | null
    status?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    createdBy?: StringFilter<"Shift"> | string
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    shiftType?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    staffMemberId?: StringWithAggregatesFilter<"Shift"> | string
    startDate?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    shiftType?: StringWithAggregatesFilter<"Shift"> | string
    location?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    status?: StringWithAggregatesFilter<"Shift"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Shift"> | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: StringFilter<"Leave"> | string
    staffMemberId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: StringFilter<"Leave"> | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    requestedBy?: StringFilter<"Leave"> | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    staffMember?: StaffMemberOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    staffMemberId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: StringFilter<"Leave"> | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    requestedBy?: StringFilter<"Leave"> | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leave"> | string
    staffMemberId?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    leaveType?: StringWithAggregatesFilter<"Leave"> | string
    reason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    status?: StringWithAggregatesFilter<"Leave"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    requestedBy?: StringWithAggregatesFilter<"Leave"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Leave"> | Date | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    staffMemberId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    scheduleData?: JsonFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    scheduleData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    staffMember?: StaffMemberOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    staffMemberId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    scheduleData?: JsonFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
    staffMember?: XOR<StaffMemberRelationFilter, StaffMemberWhereInput>
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    scheduleData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    staffMemberId?: StringWithAggregatesFilter<"Schedule"> | string
    startDate?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    scheduleData?: JsonWithAggregatesFilter<"Schedule">
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Schedule"> | string
  }

  export type StockItemWhereInput = {
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    id?: StringFilter<"StockItem"> | string
    name?: StringFilter<"StockItem"> | string
    description?: StringNullableFilter<"StockItem"> | string | null
    sku?: StringFilter<"StockItem"> | string
    category?: StringFilter<"StockItem"> | string
    subCategory?: StringNullableFilter<"StockItem"> | string | null
    currentQuantity?: IntFilter<"StockItem"> | number
    minQuantity?: IntFilter<"StockItem"> | number
    maxQuantity?: IntNullableFilter<"StockItem"> | number | null
    unit?: StringFilter<"StockItem"> | string
    createdAt?: DateTimeFilter<"StockItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockItem"> | Date | string
    movements?: StockMovementListRelationFilter
    alerts?: StockAlertListRelationFilter
  }

  export type StockItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrderInput | SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movements?: StockMovementOrderByRelationAggregateInput
    alerts?: StockAlertOrderByRelationAggregateInput
  }

  export type StockItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    name?: StringFilter<"StockItem"> | string
    description?: StringNullableFilter<"StockItem"> | string | null
    category?: StringFilter<"StockItem"> | string
    subCategory?: StringNullableFilter<"StockItem"> | string | null
    currentQuantity?: IntFilter<"StockItem"> | number
    minQuantity?: IntFilter<"StockItem"> | number
    maxQuantity?: IntNullableFilter<"StockItem"> | number | null
    unit?: StringFilter<"StockItem"> | string
    createdAt?: DateTimeFilter<"StockItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockItem"> | Date | string
    movements?: StockMovementListRelationFilter
    alerts?: StockAlertListRelationFilter
  }, "id" | "sku">

  export type StockItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrderInput | SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockItemCountOrderByAggregateInput
    _avg?: StockItemAvgOrderByAggregateInput
    _max?: StockItemMaxOrderByAggregateInput
    _min?: StockItemMinOrderByAggregateInput
    _sum?: StockItemSumOrderByAggregateInput
  }

  export type StockItemScalarWhereWithAggregatesInput = {
    AND?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    OR?: StockItemScalarWhereWithAggregatesInput[]
    NOT?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockItem"> | string
    name?: StringWithAggregatesFilter<"StockItem"> | string
    description?: StringNullableWithAggregatesFilter<"StockItem"> | string | null
    sku?: StringWithAggregatesFilter<"StockItem"> | string
    category?: StringWithAggregatesFilter<"StockItem"> | string
    subCategory?: StringNullableWithAggregatesFilter<"StockItem"> | string | null
    currentQuantity?: IntWithAggregatesFilter<"StockItem"> | number
    minQuantity?: IntWithAggregatesFilter<"StockItem"> | number
    maxQuantity?: IntNullableWithAggregatesFilter<"StockItem"> | number | null
    unit?: StringWithAggregatesFilter<"StockItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockItem"> | Date | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    stockItemId?: StringFilter<"StockMovement"> | string
    movementType?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reference?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    createdBy?: StringFilter<"StockMovement"> | string
    stockItem?: XOR<StockItemRelationFilter, StockItemWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    stockItem?: StockItemOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    stockItemId?: StringFilter<"StockMovement"> | string
    movementType?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reference?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    createdBy?: StringFilter<"StockMovement"> | string
    stockItem?: XOR<StockItemRelationFilter, StockItemWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    stockItemId?: StringWithAggregatesFilter<"StockMovement"> | string
    movementType?: StringWithAggregatesFilter<"StockMovement"> | string
    quantity?: IntWithAggregatesFilter<"StockMovement"> | number
    reference?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    referenceType?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    movementDate?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
    createdBy?: StringWithAggregatesFilter<"StockMovement"> | string
  }

  export type StockAlertWhereInput = {
    AND?: StockAlertWhereInput | StockAlertWhereInput[]
    OR?: StockAlertWhereInput[]
    NOT?: StockAlertWhereInput | StockAlertWhereInput[]
    id?: StringFilter<"StockAlert"> | string
    stockItemId?: StringFilter<"StockAlert"> | string
    alertType?: StringFilter<"StockAlert"> | string
    severity?: StringFilter<"StockAlert"> | string
    message?: StringFilter<"StockAlert"> | string
    status?: StringFilter<"StockAlert"> | string
    createdAt?: DateTimeFilter<"StockAlert"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"StockAlert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"StockAlert"> | string | null
    stockItem?: XOR<StockItemRelationFilter, StockItemWhereInput>
  }

  export type StockAlertOrderByWithRelationInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    stockItem?: StockItemOrderByWithRelationInput
  }

  export type StockAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockAlertWhereInput | StockAlertWhereInput[]
    OR?: StockAlertWhereInput[]
    NOT?: StockAlertWhereInput | StockAlertWhereInput[]
    stockItemId?: StringFilter<"StockAlert"> | string
    alertType?: StringFilter<"StockAlert"> | string
    severity?: StringFilter<"StockAlert"> | string
    message?: StringFilter<"StockAlert"> | string
    status?: StringFilter<"StockAlert"> | string
    createdAt?: DateTimeFilter<"StockAlert"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"StockAlert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"StockAlert"> | string | null
    stockItem?: XOR<StockItemRelationFilter, StockItemWhereInput>
  }, "id">

  export type StockAlertOrderByWithAggregationInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    _count?: StockAlertCountOrderByAggregateInput
    _max?: StockAlertMaxOrderByAggregateInput
    _min?: StockAlertMinOrderByAggregateInput
  }

  export type StockAlertScalarWhereWithAggregatesInput = {
    AND?: StockAlertScalarWhereWithAggregatesInput | StockAlertScalarWhereWithAggregatesInput[]
    OR?: StockAlertScalarWhereWithAggregatesInput[]
    NOT?: StockAlertScalarWhereWithAggregatesInput | StockAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockAlert"> | string
    stockItemId?: StringWithAggregatesFilter<"StockAlert"> | string
    alertType?: StringWithAggregatesFilter<"StockAlert"> | string
    severity?: StringWithAggregatesFilter<"StockAlert"> | string
    message?: StringWithAggregatesFilter<"StockAlert"> | string
    status?: StringWithAggregatesFilter<"StockAlert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockAlert"> | Date | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"StockAlert"> | Date | string | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"StockAlert"> | string | null
  }

  export type PatientCreateInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SemanticNodeCreateInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patient?: PatientCreateNestedOneWithoutSemanticNodesInput
    sourceRelations?: SemanticRelationCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationCreateNestedManyWithoutTargetNodeInput
    consultation?: ConsultationCreateNestedOneWithoutSemanticNodesInput
  }

  export type SemanticNodeUncheckedCreateInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
    consultationId?: string | null
    sourceRelations?: SemanticRelationUncheckedCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type SemanticNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patient?: PatientUpdateOneWithoutSemanticNodesNestedInput
    sourceRelations?: SemanticRelationUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUpdateManyWithoutTargetNodeNestedInput
    consultation?: ConsultationUpdateOneWithoutSemanticNodesNestedInput
  }

  export type SemanticNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceRelations?: SemanticRelationUncheckedUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type SemanticNodeCreateManyInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
    consultationId?: string | null
  }

  export type SemanticNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SemanticRelationCreateInput = {
    id?: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
    sourceNode: SemanticNodeCreateNestedOneWithoutSourceRelationsInput
    targetNode: SemanticNodeCreateNestedOneWithoutTargetRelationsInput
  }

  export type SemanticRelationUncheckedCreateInput = {
    id?: string
    sourceNodeId: string
    targetNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceNode?: SemanticNodeUpdateOneRequiredWithoutSourceRelationsNestedInput
    targetNode?: SemanticNodeUpdateOneRequiredWithoutTargetRelationsNestedInput
  }

  export type SemanticRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticRelationCreateManyInput = {
    id?: string
    sourceNodeId: string
    targetNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ConsultationDraftCreateInput = {
    id?: string
    patientId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    structuredData: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftUncheckedCreateInput = {
    id?: string
    patientId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    structuredData: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredData?: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredData?: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftCreateManyInput = {
    id?: string
    patientId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    structuredData: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredData?: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredData?: JsonNullValueInput | InputJsonValue
  }

  export type ConsultationCreateInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationCreateManyInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
  }

  export type ConsultationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ConsultationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type BillingEventCreateInput = {
    id?: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
    consultation: ConsultationCreateNestedOneWithoutBillingEventsInput
  }

  export type BillingEventUncheckedCreateInput = {
    id?: string
    consultationId: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
  }

  export type BillingEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation?: ConsultationUpdateOneRequiredWithoutBillingEventsNestedInput
  }

  export type BillingEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BillingEventCreateManyInput = {
    id?: string
    consultationId: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
  }

  export type BillingEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BillingEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllergyCreateInput = {
    id?: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
    patient: PatientCreateNestedOneWithoutAllergiesInput
  }

  export type AllergyUncheckedCreateInput = {
    id?: string
    patientId: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
  }

  export type AllergyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type AllergyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyCreateManyInput = {
    id?: string
    patientId: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
  }

  export type AllergyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalDocumentCreateInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentCreateManyInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
  }

  export type MedicalDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentAttachmentCreateInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
    document: MedicalDocumentCreateNestedOneWithoutAttachmentsInput
  }

  export type DocumentAttachmentUncheckedCreateInput = {
    id?: string
    documentId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    document?: MedicalDocumentUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAttachmentCreateManyInput = {
    id?: string
    documentId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionCreateInput = {
    id?: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    createdAt?: Date | string
    prescribedBy: string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    document?: MedicalDocumentCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    patientId: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    documentId?: string | null
    createdAt?: Date | string
    prescribedBy: string
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    document?: MedicalDocumentUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    patientId: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    documentId?: string | null
    createdAt?: Date | string
    prescribedBy: string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportCreateInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalReportsInput
    document?: MedicalDocumentCreateNestedOneWithoutMedicalReportInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalReportsInput
  }

  export type MedicalReportUncheckedCreateInput = {
    id?: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    consultationId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type MedicalReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalReportsNestedInput
    document?: MedicalDocumentUpdateOneWithoutMedicalReportNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalReportsNestedInput
  }

  export type MedicalReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportCreateManyInput = {
    id?: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    consultationId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type MedicalReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryResultCreateInput = {
    id?: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    patient: PatientCreateNestedOneWithoutLaboratoryResultsInput
    document?: MedicalDocumentCreateNestedOneWithoutLaboratoryResultInput
  }

  export type LaboratoryResultUncheckedCreateInput = {
    id?: string
    patientId: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    documentId?: string | null
  }

  export type LaboratoryResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLaboratoryResultsNestedInput
    document?: MedicalDocumentUpdateOneWithoutLaboratoryResultNestedInput
  }

  export type LaboratoryResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaboratoryResultCreateManyInput = {
    id?: string
    patientId: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    documentId?: string | null
  }

  export type LaboratoryResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaboratoryResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalImageCreateInput = {
    id?: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    acquisitionDate: Date | string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutMedicalImagesInput
    document?: MedicalDocumentCreateNestedOneWithoutMedicalImageInput
  }

  export type MedicalImageUncheckedCreateInput = {
    id?: string
    patientId: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    documentId?: string | null
    acquisitionDate: Date | string
    createdAt?: Date | string
  }

  export type MedicalImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicalImagesNestedInput
    document?: MedicalDocumentUpdateOneWithoutMedicalImageNestedInput
  }

  export type MedicalImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalImageCreateManyInput = {
    id?: string
    patientId: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    documentId?: string | null
    acquisitionDate: Date | string
    createdAt?: Date | string
  }

  export type MedicalImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackEventCreateInput = {
    id?: string
    entityType: string
    entityId: string
    originalValue: JsonNullValueInput | InputJsonValue
    correctedValue: JsonNullValueInput | InputJsonValue
    correctionReason?: string | null
    createdAt?: Date | string
    correctedBy: string
  }

  export type FeedbackEventUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    originalValue: JsonNullValueInput | InputJsonValue
    correctedValue: JsonNullValueInput | InputJsonValue
    correctionReason?: string | null
    createdAt?: Date | string
    correctedBy: string
  }

  export type FeedbackEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    originalValue?: JsonNullValueInput | InputJsonValue
    correctedValue?: JsonNullValueInput | InputJsonValue
    correctionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correctedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    originalValue?: JsonNullValueInput | InputJsonValue
    correctedValue?: JsonNullValueInput | InputJsonValue
    correctionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correctedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackEventCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    originalValue: JsonNullValueInput | InputJsonValue
    correctedValue: JsonNullValueInput | InputJsonValue
    correctionReason?: string | null
    createdAt?: Date | string
    correctedBy: string
  }

  export type FeedbackEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    originalValue?: JsonNullValueInput | InputJsonValue
    correctedValue?: JsonNullValueInput | InputJsonValue
    correctionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correctedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    originalValue?: JsonNullValueInput | InputJsonValue
    correctedValue?: JsonNullValueInput | InputJsonValue
    correctionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correctedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentCreateInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    consultation?: ConsultationCreateNestedOneWithoutAppointmentInput
    reminders?: AppointmentReminderCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    consultationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    reminders?: AppointmentReminderUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    consultation?: ConsultationUpdateOneWithoutAppointmentNestedInput
    reminders?: AppointmentReminderUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: AppointmentReminderUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    consultationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentReminderCreateInput = {
    id?: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutRemindersInput
  }

  export type AppointmentReminderUncheckedCreateInput = {
    id?: string
    appointmentId: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type AppointmentReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentReminderCreateManyInput = {
    id?: string
    appointmentId: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalMessageCreateInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    thread?: MessageThreadCreateNestedOneWithoutMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type InternalMessageUncheckedCreateInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    threadId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InternalMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: MessageThreadUpdateOneWithoutMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type InternalMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InternalMessageCreateManyInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    threadId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type InternalMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InternalMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageThreadCreateInput = {
    id?: string
    name?: string | null
    threadType?: string
    description?: string | null
    participantIds?: MessageThreadCreateparticipantIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    createdBy: string
    messages?: InternalMessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateInput = {
    id?: string
    name?: string | null
    threadType?: string
    description?: string | null
    participantIds?: MessageThreadCreateparticipantIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    createdBy: string
    messages?: InternalMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    messages?: InternalMessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    messages?: InternalMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadCreateManyInput = {
    id?: string
    name?: string | null
    threadType?: string
    description?: string | null
    participantIds?: MessageThreadCreateparticipantIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    createdBy: string
  }

  export type MessageThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MessageThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    message: InternalMessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: InternalMessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffMemberCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutStaffMemberInput
    leaves?: LeaveCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutStaffMemberInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutStaffMemberNestedInput
    leaves?: LeaveUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutStaffMemberNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
    staffMember: StaffMemberCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    staffMember?: StaffMemberUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftCreateManyInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    staffMember: StaffMemberCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffMember?: StaffMemberUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveCreateManyInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    staffMember: StaffMemberCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    staffMember?: StaffMemberUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    staffMemberId: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffMemberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: StockMovementCreateNestedManyWithoutStockItemInput
    alerts?: StockAlertCreateNestedManyWithoutStockItemInput
  }

  export type StockItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: StockMovementUncheckedCreateNestedManyWithoutStockItemInput
    alerts?: StockAlertUncheckedCreateNestedManyWithoutStockItemInput
  }

  export type StockItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: StockMovementUpdateManyWithoutStockItemNestedInput
    alerts?: StockAlertUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: StockMovementUncheckedUpdateManyWithoutStockItemNestedInput
    alerts?: StockAlertUncheckedUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateInput = {
    id?: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
    stockItem: StockItemCreateNestedOneWithoutMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    stockItemId: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    stockItem?: StockItemUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockItemId?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    stockItemId: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockItemId?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockAlertCreateInput = {
    id?: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    stockItem: StockItemCreateNestedOneWithoutAlertsInput
  }

  export type StockAlertUncheckedCreateInput = {
    id?: string
    stockItemId: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
  }

  export type StockAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stockItem?: StockItemUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type StockAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockItemId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockAlertCreateManyInput = {
    id?: string
    stockItemId: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
  }

  export type StockAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockItemId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ConsultationListRelationFilter = {
    every?: ConsultationWhereInput
    some?: ConsultationWhereInput
    none?: ConsultationWhereInput
  }

  export type SemanticNodeListRelationFilter = {
    every?: SemanticNodeWhereInput
    some?: SemanticNodeWhereInput
    none?: SemanticNodeWhereInput
  }

  export type MedicalDocumentListRelationFilter = {
    every?: MedicalDocumentWhereInput
    some?: MedicalDocumentWhereInput
    none?: MedicalDocumentWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type MedicalReportListRelationFilter = {
    every?: MedicalReportWhereInput
    some?: MedicalReportWhereInput
    none?: MedicalReportWhereInput
  }

  export type LaboratoryResultListRelationFilter = {
    every?: LaboratoryResultWhereInput
    some?: LaboratoryResultWhereInput
    none?: LaboratoryResultWhereInput
  }

  export type MedicalImageListRelationFilter = {
    every?: MedicalImageWhereInput
    some?: MedicalImageWhereInput
    none?: MedicalImageWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type AllergyListRelationFilter = {
    every?: AllergyWhereInput
    some?: AllergyWhereInput
    none?: AllergyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemanticNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaboratoryResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllergyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    insToken?: SortOrder
    insHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    insToken?: SortOrder
    insHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    insToken?: SortOrder
    insHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PatientNullableRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type SemanticRelationListRelationFilter = {
    every?: SemanticRelationWhereInput
    some?: SemanticRelationWhereInput
    none?: SemanticRelationWhereInput
  }

  export type ConsultationNullableRelationFilter = {
    is?: ConsultationWhereInput | null
    isNot?: ConsultationWhereInput | null
  }

  export type SemanticRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemanticNodeCountOrderByAggregateInput = {
    id?: SortOrder
    nodeType?: SortOrder
    snomedCtCode?: SortOrder
    cim10Code?: SortOrder
    cim11Code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    embedding?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confidence?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type SemanticNodeAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type SemanticNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeType?: SortOrder
    snomedCtCode?: SortOrder
    cim10Code?: SortOrder
    cim11Code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confidence?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type SemanticNodeMinOrderByAggregateInput = {
    id?: SortOrder
    nodeType?: SortOrder
    snomedCtCode?: SortOrder
    cim10Code?: SortOrder
    cim11Code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confidence?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type SemanticNodeSumOrderByAggregateInput = {
    confidence?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SemanticNodeRelationFilter = {
    is?: SemanticNodeWhereInput
    isNot?: SemanticNodeWhereInput
  }

  export type SemanticRelationSourceNodeIdTargetNodeIdRelationTypeCompoundUniqueInput = {
    sourceNodeId: string
    targetNodeId: string
    relationType: string
  }

  export type SemanticRelationCountOrderByAggregateInput = {
    id?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    relationType?: SortOrder
    strength?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    confidence?: SortOrder
  }

  export type SemanticRelationAvgOrderByAggregateInput = {
    strength?: SortOrder
    confidence?: SortOrder
  }

  export type SemanticRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    relationType?: SortOrder
    strength?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    confidence?: SortOrder
  }

  export type SemanticRelationMinOrderByAggregateInput = {
    id?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    relationType?: SortOrder
    strength?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    confidence?: SortOrder
  }

  export type SemanticRelationSumOrderByAggregateInput = {
    strength?: SortOrder
    confidence?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConsultationDraftCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    structuredData?: SortOrder
  }

  export type ConsultationDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationDraftMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AppointmentNullableRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type BillingEventListRelationFilter = {
    every?: BillingEventWhereInput
    some?: BillingEventWhereInput
    none?: BillingEventWhereInput
  }

  export type BillingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    rawTranscript?: SortOrder
    rawText?: SortOrder
    draftData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    rawTranscript?: SortOrder
    rawText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    rawTranscript?: SortOrder
    rawText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    validatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ConsultationRelationFilter = {
    is?: ConsultationWhereInput
    isNot?: ConsultationWhereInput
  }

  export type BillingEventCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    ghmCode?: SortOrder
    actCode?: SortOrder
    actType?: SortOrder
    status?: SortOrder
    evidenceNodeIds?: SortOrder
    createdAt?: SortOrder
    transmittedAt?: SortOrder
  }

  export type BillingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    ghmCode?: SortOrder
    actCode?: SortOrder
    actType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    transmittedAt?: SortOrder
  }

  export type BillingEventMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    ghmCode?: SortOrder
    actCode?: SortOrder
    actType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    transmittedAt?: SortOrder
  }

  export type AllergyCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    snomedCtCode?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type AllergyMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    snomedCtCode?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type AllergyMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    substance?: SortOrder
    snomedCtCode?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type PrescriptionNullableRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type MedicalReportNullableRelationFilter = {
    is?: MedicalReportWhereInput | null
    isNot?: MedicalReportWhereInput | null
  }

  export type LaboratoryResultNullableRelationFilter = {
    is?: LaboratoryResultWhereInput | null
    isNot?: LaboratoryResultWhereInput | null
  }

  export type MedicalImageNullableRelationFilter = {
    is?: MedicalImageWhereInput | null
    isNot?: MedicalImageWhereInput | null
  }

  export type DocumentAttachmentListRelationFilter = {
    every?: DocumentAttachmentWhereInput
    some?: DocumentAttachmentWhereInput
    none?: DocumentAttachmentWhereInput
  }

  export type DocumentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    rawContent?: SortOrder
    documentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultationId?: SortOrder
  }

  export type MedicalDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    rawContent?: SortOrder
    documentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultationId?: SortOrder
  }

  export type MedicalDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    rawContent?: SortOrder
    documentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    consultationId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MedicalDocumentRelationFilter = {
    is?: MedicalDocumentWhereInput
    isNot?: MedicalDocumentWhereInput
  }

  export type DocumentAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MedicalDocumentNullableRelationFilter = {
    is?: MedicalDocumentWhereInput | null
    isNot?: MedicalDocumentWhereInput | null
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationName?: SortOrder
    atcCode?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    safetyChecks?: SortOrder
    outpassReason?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    prescribedBy?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationName?: SortOrder
    atcCode?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    outpassReason?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    prescribedBy?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationName?: SortOrder
    atcCode?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    outpassReason?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    prescribedBy?: SortOrder
  }

  export type MedicalReportCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    chiefComplaint?: SortOrder
    history?: SortOrder
    examination?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    documentId?: SortOrder
    consultationId?: SortOrder
    reportDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type MedicalReportMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    chiefComplaint?: SortOrder
    history?: SortOrder
    examination?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    documentId?: SortOrder
    consultationId?: SortOrder
    reportDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type MedicalReportMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    chiefComplaint?: SortOrder
    history?: SortOrder
    examination?: SortOrder
    assessment?: SortOrder
    plan?: SortOrder
    documentId?: SortOrder
    consultationId?: SortOrder
    reportDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type LaboratoryResultCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    testCode?: SortOrder
    resultValue?: SortOrder
    unit?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    testDate?: SortOrder
    receivedAt?: SortOrder
    laboratoryName?: SortOrder
    documentId?: SortOrder
  }

  export type LaboratoryResultMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    testCode?: SortOrder
    resultValue?: SortOrder
    unit?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    testDate?: SortOrder
    receivedAt?: SortOrder
    laboratoryName?: SortOrder
    documentId?: SortOrder
  }

  export type LaboratoryResultMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    testCode?: SortOrder
    resultValue?: SortOrder
    unit?: SortOrder
    referenceRange?: SortOrder
    status?: SortOrder
    testDate?: SortOrder
    receivedAt?: SortOrder
    laboratoryName?: SortOrder
    documentId?: SortOrder
  }

  export type MedicalImageCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    studyInstanceUid?: SortOrder
    seriesInstanceUid?: SortOrder
    sopInstanceUid?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    studyDescription?: SortOrder
    seriesDescription?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    documentId?: SortOrder
    acquisitionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalImageAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MedicalImageMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    studyInstanceUid?: SortOrder
    seriesInstanceUid?: SortOrder
    sopInstanceUid?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    studyDescription?: SortOrder
    seriesDescription?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    documentId?: SortOrder
    acquisitionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalImageMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    studyInstanceUid?: SortOrder
    seriesInstanceUid?: SortOrder
    sopInstanceUid?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    studyDescription?: SortOrder
    seriesDescription?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    documentId?: SortOrder
    acquisitionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalImageSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type FeedbackEventCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    originalValue?: SortOrder
    correctedValue?: SortOrder
    correctionReason?: SortOrder
    createdAt?: SortOrder
    correctedBy?: SortOrder
  }

  export type FeedbackEventMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correctionReason?: SortOrder
    createdAt?: SortOrder
    correctedBy?: SortOrder
  }

  export type FeedbackEventMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correctionReason?: SortOrder
    createdAt?: SortOrder
    correctedBy?: SortOrder
  }

  export type AppointmentReminderListRelationFilter = {
    every?: AppointmentReminderWhereInput
    some?: AppointmentReminderWhereInput
    none?: AppointmentReminderWhereInput
  }

  export type AppointmentReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentDoctorIdStartTimeEndTimeCompoundUniqueInput = {
    doctorId: string
    startTime: Date | string
    endTime: Date | string
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    appointmentType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancellationReason?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    appointmentType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancellationReason?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    appointmentType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancellationReason?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AppointmentRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type AppointmentReminderCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reminderType?: SortOrder
    reminderTime?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reminderType?: SortOrder
    reminderTime?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentReminderMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    reminderType?: SortOrder
    reminderTime?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadNullableRelationFilter = {
    is?: MessageThreadWhereInput | null
    isNot?: MessageThreadWhereInput | null
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternalMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type InternalMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type InternalMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type InternalMessageListRelationFilter = {
    every?: InternalMessageWhereInput
    some?: InternalMessageWhereInput
    none?: InternalMessageWhereInput
  }

  export type InternalMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageThreadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    threadType?: SortOrder
    description?: SortOrder
    participantIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    createdBy?: SortOrder
  }

  export type MessageThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    threadType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    createdBy?: SortOrder
  }

  export type MessageThreadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    threadType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    createdBy?: SortOrder
  }

  export type InternalMessageRelationFilter = {
    is?: InternalMessageWhereInput
    isNot?: InternalMessageWhereInput
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffMemberCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    speciality?: SortOrder
    qualifications?: SortOrder
    status?: SortOrder
    hiredDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    speciality?: SortOrder
    status?: SortOrder
    hiredDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMemberMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    speciality?: SortOrder
    status?: SortOrder
    hiredDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMemberRelationFilter = {
    is?: StaffMemberWhereInput
    isNot?: StaffMemberWhereInput
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    shiftType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    shiftType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    shiftType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    scheduleData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    staffMemberId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type StockAlertListRelationFilter = {
    every?: StockAlertWhereInput
    some?: StockAlertWhereInput
    none?: StockAlertWhereInput
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockItemAvgOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
  }

  export type StockItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockItemSumOrderByAggregateInput = {
    currentQuantity?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StockItemRelationFilter = {
    is?: StockItemWhereInput
    isNot?: StockItemWhereInput
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    movementDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockAlertCountOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
  }

  export type StockAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
  }

  export type StockAlertMinOrderByAggregateInput = {
    id?: SortOrder
    stockItemId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
  }

  export type ConsultationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type SemanticNodeCreateNestedManyWithoutPatientInput = {
    create?: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput> | SemanticNodeCreateWithoutPatientInput[] | SemanticNodeUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutPatientInput | SemanticNodeCreateOrConnectWithoutPatientInput[]
    createMany?: SemanticNodeCreateManyPatientInputEnvelope
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
  }

  export type MedicalDocumentCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput> | MedicalDocumentCreateWithoutPatientInput[] | MedicalDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPatientInput | MedicalDocumentCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalDocumentCreateManyPatientInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type MedicalReportCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput> | MedicalReportCreateWithoutPatientInput[] | MedicalReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutPatientInput | MedicalReportCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalReportCreateManyPatientInputEnvelope
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
  }

  export type LaboratoryResultCreateNestedManyWithoutPatientInput = {
    create?: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput> | LaboratoryResultCreateWithoutPatientInput[] | LaboratoryResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutPatientInput | LaboratoryResultCreateOrConnectWithoutPatientInput[]
    createMany?: LaboratoryResultCreateManyPatientInputEnvelope
    connect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
  }

  export type MedicalImageCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput> | MedicalImageCreateWithoutPatientInput[] | MedicalImageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalImageCreateOrConnectWithoutPatientInput | MedicalImageCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalImageCreateManyPatientInputEnvelope
    connect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AllergyCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type SemanticNodeUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput> | SemanticNodeCreateWithoutPatientInput[] | SemanticNodeUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutPatientInput | SemanticNodeCreateOrConnectWithoutPatientInput[]
    createMany?: SemanticNodeCreateManyPatientInputEnvelope
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
  }

  export type MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput> | MedicalDocumentCreateWithoutPatientInput[] | MedicalDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPatientInput | MedicalDocumentCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalDocumentCreateManyPatientInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type MedicalReportUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput> | MedicalReportCreateWithoutPatientInput[] | MedicalReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutPatientInput | MedicalReportCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalReportCreateManyPatientInputEnvelope
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
  }

  export type LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput> | LaboratoryResultCreateWithoutPatientInput[] | LaboratoryResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutPatientInput | LaboratoryResultCreateOrConnectWithoutPatientInput[]
    createMany?: LaboratoryResultCreateManyPatientInputEnvelope
    connect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
  }

  export type MedicalImageUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput> | MedicalImageCreateWithoutPatientInput[] | MedicalImageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalImageCreateOrConnectWithoutPatientInput | MedicalImageCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalImageCreateManyPatientInputEnvelope
    connect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AllergyUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ConsultationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type SemanticNodeUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput> | SemanticNodeCreateWithoutPatientInput[] | SemanticNodeUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutPatientInput | SemanticNodeCreateOrConnectWithoutPatientInput[]
    upsert?: SemanticNodeUpsertWithWhereUniqueWithoutPatientInput | SemanticNodeUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SemanticNodeCreateManyPatientInputEnvelope
    set?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    disconnect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    delete?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    update?: SemanticNodeUpdateWithWhereUniqueWithoutPatientInput | SemanticNodeUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SemanticNodeUpdateManyWithWhereWithoutPatientInput | SemanticNodeUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
  }

  export type MedicalDocumentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput> | MedicalDocumentCreateWithoutPatientInput[] | MedicalDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPatientInput | MedicalDocumentCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutPatientInput | MedicalDocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalDocumentCreateManyPatientInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutPatientInput | MedicalDocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutPatientInput | MedicalDocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type MedicalReportUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput> | MedicalReportCreateWithoutPatientInput[] | MedicalReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutPatientInput | MedicalReportCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalReportUpsertWithWhereUniqueWithoutPatientInput | MedicalReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalReportCreateManyPatientInputEnvelope
    set?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    disconnect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    delete?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    update?: MedicalReportUpdateWithWhereUniqueWithoutPatientInput | MedicalReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalReportUpdateManyWithWhereWithoutPatientInput | MedicalReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
  }

  export type LaboratoryResultUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput> | LaboratoryResultCreateWithoutPatientInput[] | LaboratoryResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutPatientInput | LaboratoryResultCreateOrConnectWithoutPatientInput[]
    upsert?: LaboratoryResultUpsertWithWhereUniqueWithoutPatientInput | LaboratoryResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LaboratoryResultCreateManyPatientInputEnvelope
    set?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    disconnect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    delete?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    connect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    update?: LaboratoryResultUpdateWithWhereUniqueWithoutPatientInput | LaboratoryResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LaboratoryResultUpdateManyWithWhereWithoutPatientInput | LaboratoryResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LaboratoryResultScalarWhereInput | LaboratoryResultScalarWhereInput[]
  }

  export type MedicalImageUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput> | MedicalImageCreateWithoutPatientInput[] | MedicalImageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalImageCreateOrConnectWithoutPatientInput | MedicalImageCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalImageUpsertWithWhereUniqueWithoutPatientInput | MedicalImageUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalImageCreateManyPatientInputEnvelope
    set?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    disconnect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    delete?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    connect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    update?: MedicalImageUpdateWithWhereUniqueWithoutPatientInput | MedicalImageUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalImageUpdateManyWithWhereWithoutPatientInput | MedicalImageUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalImageScalarWhereInput | MedicalImageScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AllergyUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput> | SemanticNodeCreateWithoutPatientInput[] | SemanticNodeUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutPatientInput | SemanticNodeCreateOrConnectWithoutPatientInput[]
    upsert?: SemanticNodeUpsertWithWhereUniqueWithoutPatientInput | SemanticNodeUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SemanticNodeCreateManyPatientInputEnvelope
    set?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    disconnect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    delete?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    update?: SemanticNodeUpdateWithWhereUniqueWithoutPatientInput | SemanticNodeUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SemanticNodeUpdateManyWithWhereWithoutPatientInput | SemanticNodeUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput> | MedicalDocumentCreateWithoutPatientInput[] | MedicalDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPatientInput | MedicalDocumentCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutPatientInput | MedicalDocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalDocumentCreateManyPatientInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutPatientInput | MedicalDocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutPatientInput | MedicalDocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type MedicalReportUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput> | MedicalReportCreateWithoutPatientInput[] | MedicalReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutPatientInput | MedicalReportCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalReportUpsertWithWhereUniqueWithoutPatientInput | MedicalReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalReportCreateManyPatientInputEnvelope
    set?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    disconnect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    delete?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    update?: MedicalReportUpdateWithWhereUniqueWithoutPatientInput | MedicalReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalReportUpdateManyWithWhereWithoutPatientInput | MedicalReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
  }

  export type LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput> | LaboratoryResultCreateWithoutPatientInput[] | LaboratoryResultUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutPatientInput | LaboratoryResultCreateOrConnectWithoutPatientInput[]
    upsert?: LaboratoryResultUpsertWithWhereUniqueWithoutPatientInput | LaboratoryResultUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LaboratoryResultCreateManyPatientInputEnvelope
    set?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    disconnect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    delete?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    connect?: LaboratoryResultWhereUniqueInput | LaboratoryResultWhereUniqueInput[]
    update?: LaboratoryResultUpdateWithWhereUniqueWithoutPatientInput | LaboratoryResultUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LaboratoryResultUpdateManyWithWhereWithoutPatientInput | LaboratoryResultUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LaboratoryResultScalarWhereInput | LaboratoryResultScalarWhereInput[]
  }

  export type MedicalImageUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput> | MedicalImageCreateWithoutPatientInput[] | MedicalImageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalImageCreateOrConnectWithoutPatientInput | MedicalImageCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalImageUpsertWithWhereUniqueWithoutPatientInput | MedicalImageUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalImageCreateManyPatientInputEnvelope
    set?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    disconnect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    delete?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    connect?: MedicalImageWhereUniqueInput | MedicalImageWhereUniqueInput[]
    update?: MedicalImageUpdateWithWhereUniqueWithoutPatientInput | MedicalImageUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalImageUpdateManyWithWhereWithoutPatientInput | MedicalImageUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalImageScalarWhereInput | MedicalImageScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AllergyUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput> | AllergyCreateWithoutPatientInput[] | AllergyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyCreateOrConnectWithoutPatientInput | AllergyCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyUpsertWithWhereUniqueWithoutPatientInput | AllergyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyCreateManyPatientInputEnvelope
    set?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    disconnect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    delete?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    connect?: AllergyWhereUniqueInput | AllergyWhereUniqueInput[]
    update?: AllergyUpdateWithWhereUniqueWithoutPatientInput | AllergyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyUpdateManyWithWhereWithoutPatientInput | AllergyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutSemanticNodesInput = {
    create?: XOR<PatientCreateWithoutSemanticNodesInput, PatientUncheckedCreateWithoutSemanticNodesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSemanticNodesInput
    connect?: PatientWhereUniqueInput
  }

  export type SemanticRelationCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput> | SemanticRelationCreateWithoutSourceNodeInput[] | SemanticRelationUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutSourceNodeInput | SemanticRelationCreateOrConnectWithoutSourceNodeInput[]
    createMany?: SemanticRelationCreateManySourceNodeInputEnvelope
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
  }

  export type SemanticRelationCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput> | SemanticRelationCreateWithoutTargetNodeInput[] | SemanticRelationUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutTargetNodeInput | SemanticRelationCreateOrConnectWithoutTargetNodeInput[]
    createMany?: SemanticRelationCreateManyTargetNodeInputEnvelope
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
  }

  export type ConsultationCreateNestedOneWithoutSemanticNodesInput = {
    create?: XOR<ConsultationCreateWithoutSemanticNodesInput, ConsultationUncheckedCreateWithoutSemanticNodesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutSemanticNodesInput
    connect?: ConsultationWhereUniqueInput
  }

  export type SemanticRelationUncheckedCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput> | SemanticRelationCreateWithoutSourceNodeInput[] | SemanticRelationUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutSourceNodeInput | SemanticRelationCreateOrConnectWithoutSourceNodeInput[]
    createMany?: SemanticRelationCreateManySourceNodeInputEnvelope
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
  }

  export type SemanticRelationUncheckedCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput> | SemanticRelationCreateWithoutTargetNodeInput[] | SemanticRelationUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutTargetNodeInput | SemanticRelationCreateOrConnectWithoutTargetNodeInput[]
    createMany?: SemanticRelationCreateManyTargetNodeInputEnvelope
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneWithoutSemanticNodesNestedInput = {
    create?: XOR<PatientCreateWithoutSemanticNodesInput, PatientUncheckedCreateWithoutSemanticNodesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSemanticNodesInput
    upsert?: PatientUpsertWithoutSemanticNodesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutSemanticNodesInput, PatientUpdateWithoutSemanticNodesInput>, PatientUncheckedUpdateWithoutSemanticNodesInput>
  }

  export type SemanticRelationUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput> | SemanticRelationCreateWithoutSourceNodeInput[] | SemanticRelationUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutSourceNodeInput | SemanticRelationCreateOrConnectWithoutSourceNodeInput[]
    upsert?: SemanticRelationUpsertWithWhereUniqueWithoutSourceNodeInput | SemanticRelationUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: SemanticRelationCreateManySourceNodeInputEnvelope
    set?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    disconnect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    delete?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    update?: SemanticRelationUpdateWithWhereUniqueWithoutSourceNodeInput | SemanticRelationUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: SemanticRelationUpdateManyWithWhereWithoutSourceNodeInput | SemanticRelationUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
  }

  export type SemanticRelationUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput> | SemanticRelationCreateWithoutTargetNodeInput[] | SemanticRelationUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutTargetNodeInput | SemanticRelationCreateOrConnectWithoutTargetNodeInput[]
    upsert?: SemanticRelationUpsertWithWhereUniqueWithoutTargetNodeInput | SemanticRelationUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: SemanticRelationCreateManyTargetNodeInputEnvelope
    set?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    disconnect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    delete?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    update?: SemanticRelationUpdateWithWhereUniqueWithoutTargetNodeInput | SemanticRelationUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: SemanticRelationUpdateManyWithWhereWithoutTargetNodeInput | SemanticRelationUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
  }

  export type ConsultationUpdateOneWithoutSemanticNodesNestedInput = {
    create?: XOR<ConsultationCreateWithoutSemanticNodesInput, ConsultationUncheckedCreateWithoutSemanticNodesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutSemanticNodesInput
    upsert?: ConsultationUpsertWithoutSemanticNodesInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutSemanticNodesInput, ConsultationUpdateWithoutSemanticNodesInput>, ConsultationUncheckedUpdateWithoutSemanticNodesInput>
  }

  export type SemanticRelationUncheckedUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput> | SemanticRelationCreateWithoutSourceNodeInput[] | SemanticRelationUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutSourceNodeInput | SemanticRelationCreateOrConnectWithoutSourceNodeInput[]
    upsert?: SemanticRelationUpsertWithWhereUniqueWithoutSourceNodeInput | SemanticRelationUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: SemanticRelationCreateManySourceNodeInputEnvelope
    set?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    disconnect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    delete?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    update?: SemanticRelationUpdateWithWhereUniqueWithoutSourceNodeInput | SemanticRelationUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: SemanticRelationUpdateManyWithWhereWithoutSourceNodeInput | SemanticRelationUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
  }

  export type SemanticRelationUncheckedUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput> | SemanticRelationCreateWithoutTargetNodeInput[] | SemanticRelationUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: SemanticRelationCreateOrConnectWithoutTargetNodeInput | SemanticRelationCreateOrConnectWithoutTargetNodeInput[]
    upsert?: SemanticRelationUpsertWithWhereUniqueWithoutTargetNodeInput | SemanticRelationUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: SemanticRelationCreateManyTargetNodeInputEnvelope
    set?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    disconnect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    delete?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    connect?: SemanticRelationWhereUniqueInput | SemanticRelationWhereUniqueInput[]
    update?: SemanticRelationUpdateWithWhereUniqueWithoutTargetNodeInput | SemanticRelationUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: SemanticRelationUpdateManyWithWhereWithoutTargetNodeInput | SemanticRelationUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
  }

  export type SemanticNodeCreateNestedOneWithoutSourceRelationsInput = {
    create?: XOR<SemanticNodeCreateWithoutSourceRelationsInput, SemanticNodeUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutSourceRelationsInput
    connect?: SemanticNodeWhereUniqueInput
  }

  export type SemanticNodeCreateNestedOneWithoutTargetRelationsInput = {
    create?: XOR<SemanticNodeCreateWithoutTargetRelationsInput, SemanticNodeUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutTargetRelationsInput
    connect?: SemanticNodeWhereUniqueInput
  }

  export type SemanticNodeUpdateOneRequiredWithoutSourceRelationsNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutSourceRelationsInput, SemanticNodeUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutSourceRelationsInput
    upsert?: SemanticNodeUpsertWithoutSourceRelationsInput
    connect?: SemanticNodeWhereUniqueInput
    update?: XOR<XOR<SemanticNodeUpdateToOneWithWhereWithoutSourceRelationsInput, SemanticNodeUpdateWithoutSourceRelationsInput>, SemanticNodeUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type SemanticNodeUpdateOneRequiredWithoutTargetRelationsNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutTargetRelationsInput, SemanticNodeUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutTargetRelationsInput
    upsert?: SemanticNodeUpsertWithoutTargetRelationsInput
    connect?: SemanticNodeWhereUniqueInput
    update?: XOR<XOR<SemanticNodeUpdateToOneWithWhereWithoutTargetRelationsInput, SemanticNodeUpdateWithoutTargetRelationsInput>, SemanticNodeUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type PatientCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
  }

  export type SemanticNodeCreateNestedManyWithoutConsultationInput = {
    create?: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput> | SemanticNodeCreateWithoutConsultationInput[] | SemanticNodeUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutConsultationInput | SemanticNodeCreateOrConnectWithoutConsultationInput[]
    createMany?: SemanticNodeCreateManyConsultationInputEnvelope
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
  }

  export type MedicalDocumentCreateNestedManyWithoutConsultationInput = {
    create?: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput> | MedicalDocumentCreateWithoutConsultationInput[] | MedicalDocumentUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutConsultationInput | MedicalDocumentCreateOrConnectWithoutConsultationInput[]
    createMany?: MedicalDocumentCreateManyConsultationInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type MedicalReportCreateNestedManyWithoutConsultationInput = {
    create?: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput> | MedicalReportCreateWithoutConsultationInput[] | MedicalReportUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutConsultationInput | MedicalReportCreateOrConnectWithoutConsultationInput[]
    createMany?: MedicalReportCreateManyConsultationInputEnvelope
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
  }

  export type AppointmentCreateNestedOneWithoutConsultationInput = {
    create?: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsultationInput
    connect?: AppointmentWhereUniqueInput
  }

  export type BillingEventCreateNestedManyWithoutConsultationInput = {
    create?: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput> | BillingEventCreateWithoutConsultationInput[] | BillingEventUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BillingEventCreateOrConnectWithoutConsultationInput | BillingEventCreateOrConnectWithoutConsultationInput[]
    createMany?: BillingEventCreateManyConsultationInputEnvelope
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
  }

  export type SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput> | SemanticNodeCreateWithoutConsultationInput[] | SemanticNodeUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutConsultationInput | SemanticNodeCreateOrConnectWithoutConsultationInput[]
    createMany?: SemanticNodeCreateManyConsultationInputEnvelope
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
  }

  export type MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput> | MedicalDocumentCreateWithoutConsultationInput[] | MedicalDocumentUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutConsultationInput | MedicalDocumentCreateOrConnectWithoutConsultationInput[]
    createMany?: MedicalDocumentCreateManyConsultationInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type MedicalReportUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput> | MedicalReportCreateWithoutConsultationInput[] | MedicalReportUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutConsultationInput | MedicalReportCreateOrConnectWithoutConsultationInput[]
    createMany?: MedicalReportCreateManyConsultationInputEnvelope
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedOneWithoutConsultationInput = {
    create?: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsultationInput
    connect?: AppointmentWhereUniqueInput
  }

  export type BillingEventUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput> | BillingEventCreateWithoutConsultationInput[] | BillingEventUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BillingEventCreateOrConnectWithoutConsultationInput | BillingEventCreateOrConnectWithoutConsultationInput[]
    createMany?: BillingEventCreateManyConsultationInputEnvelope
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PatientUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    upsert?: PatientUpsertWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsultationsInput, PatientUpdateWithoutConsultationsInput>, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type SemanticNodeUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput> | SemanticNodeCreateWithoutConsultationInput[] | SemanticNodeUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutConsultationInput | SemanticNodeCreateOrConnectWithoutConsultationInput[]
    upsert?: SemanticNodeUpsertWithWhereUniqueWithoutConsultationInput | SemanticNodeUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: SemanticNodeCreateManyConsultationInputEnvelope
    set?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    disconnect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    delete?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    update?: SemanticNodeUpdateWithWhereUniqueWithoutConsultationInput | SemanticNodeUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: SemanticNodeUpdateManyWithWhereWithoutConsultationInput | SemanticNodeUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
  }

  export type MedicalDocumentUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput> | MedicalDocumentCreateWithoutConsultationInput[] | MedicalDocumentUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutConsultationInput | MedicalDocumentCreateOrConnectWithoutConsultationInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutConsultationInput | MedicalDocumentUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: MedicalDocumentCreateManyConsultationInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutConsultationInput | MedicalDocumentUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutConsultationInput | MedicalDocumentUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type MedicalReportUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput> | MedicalReportCreateWithoutConsultationInput[] | MedicalReportUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutConsultationInput | MedicalReportCreateOrConnectWithoutConsultationInput[]
    upsert?: MedicalReportUpsertWithWhereUniqueWithoutConsultationInput | MedicalReportUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: MedicalReportCreateManyConsultationInputEnvelope
    set?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    disconnect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    delete?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    update?: MedicalReportUpdateWithWhereUniqueWithoutConsultationInput | MedicalReportUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: MedicalReportUpdateManyWithWhereWithoutConsultationInput | MedicalReportUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
  }

  export type AppointmentUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsultationInput
    upsert?: AppointmentUpsertWithoutConsultationInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutConsultationInput, AppointmentUpdateWithoutConsultationInput>, AppointmentUncheckedUpdateWithoutConsultationInput>
  }

  export type BillingEventUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput> | BillingEventCreateWithoutConsultationInput[] | BillingEventUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BillingEventCreateOrConnectWithoutConsultationInput | BillingEventCreateOrConnectWithoutConsultationInput[]
    upsert?: BillingEventUpsertWithWhereUniqueWithoutConsultationInput | BillingEventUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: BillingEventCreateManyConsultationInputEnvelope
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    update?: BillingEventUpdateWithWhereUniqueWithoutConsultationInput | BillingEventUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: BillingEventUpdateManyWithWhereWithoutConsultationInput | BillingEventUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[]
  }

  export type SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput> | SemanticNodeCreateWithoutConsultationInput[] | SemanticNodeUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: SemanticNodeCreateOrConnectWithoutConsultationInput | SemanticNodeCreateOrConnectWithoutConsultationInput[]
    upsert?: SemanticNodeUpsertWithWhereUniqueWithoutConsultationInput | SemanticNodeUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: SemanticNodeCreateManyConsultationInputEnvelope
    set?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    disconnect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    delete?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    connect?: SemanticNodeWhereUniqueInput | SemanticNodeWhereUniqueInput[]
    update?: SemanticNodeUpdateWithWhereUniqueWithoutConsultationInput | SemanticNodeUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: SemanticNodeUpdateManyWithWhereWithoutConsultationInput | SemanticNodeUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput> | MedicalDocumentCreateWithoutConsultationInput[] | MedicalDocumentUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutConsultationInput | MedicalDocumentCreateOrConnectWithoutConsultationInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutConsultationInput | MedicalDocumentUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: MedicalDocumentCreateManyConsultationInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutConsultationInput | MedicalDocumentUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutConsultationInput | MedicalDocumentUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput> | MedicalReportCreateWithoutConsultationInput[] | MedicalReportUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: MedicalReportCreateOrConnectWithoutConsultationInput | MedicalReportCreateOrConnectWithoutConsultationInput[]
    upsert?: MedicalReportUpsertWithWhereUniqueWithoutConsultationInput | MedicalReportUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: MedicalReportCreateManyConsultationInputEnvelope
    set?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    disconnect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    delete?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    connect?: MedicalReportWhereUniqueInput | MedicalReportWhereUniqueInput[]
    update?: MedicalReportUpdateWithWhereUniqueWithoutConsultationInput | MedicalReportUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: MedicalReportUpdateManyWithWhereWithoutConsultationInput | MedicalReportUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutConsultationInput
    upsert?: AppointmentUpsertWithoutConsultationInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutConsultationInput, AppointmentUpdateWithoutConsultationInput>, AppointmentUncheckedUpdateWithoutConsultationInput>
  }

  export type BillingEventUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput> | BillingEventCreateWithoutConsultationInput[] | BillingEventUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BillingEventCreateOrConnectWithoutConsultationInput | BillingEventCreateOrConnectWithoutConsultationInput[]
    upsert?: BillingEventUpsertWithWhereUniqueWithoutConsultationInput | BillingEventUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: BillingEventCreateManyConsultationInputEnvelope
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[]
    update?: BillingEventUpdateWithWhereUniqueWithoutConsultationInput | BillingEventUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: BillingEventUpdateManyWithWhereWithoutConsultationInput | BillingEventUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[]
  }

  export type BillingEventCreateevidenceNodeIdsInput = {
    set: string[]
  }

  export type ConsultationCreateNestedOneWithoutBillingEventsInput = {
    create?: XOR<ConsultationCreateWithoutBillingEventsInput, ConsultationUncheckedCreateWithoutBillingEventsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBillingEventsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type BillingEventUpdateevidenceNodeIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConsultationUpdateOneRequiredWithoutBillingEventsNestedInput = {
    create?: XOR<ConsultationCreateWithoutBillingEventsInput, ConsultationUncheckedCreateWithoutBillingEventsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBillingEventsInput
    upsert?: ConsultationUpsertWithoutBillingEventsInput
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutBillingEventsInput, ConsultationUpdateWithoutBillingEventsInput>, ConsultationUncheckedUpdateWithoutBillingEventsInput>
  }

  export type PatientCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    upsert?: PatientUpsertWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAllergiesInput, PatientUpdateWithoutAllergiesInput>, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientCreateNestedOneWithoutMedicalDocumentsInput = {
    create?: XOR<PatientCreateWithoutMedicalDocumentsInput, PatientUncheckedCreateWithoutMedicalDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalDocumentsInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutMedicalDocumentsInput = {
    create?: XOR<ConsultationCreateWithoutMedicalDocumentsInput, ConsultationUncheckedCreateWithoutMedicalDocumentsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedicalDocumentsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutDocumentInput = {
    create?: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDocumentInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MedicalReportCreateNestedOneWithoutDocumentInput = {
    create?: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalReportCreateOrConnectWithoutDocumentInput
    connect?: MedicalReportWhereUniqueInput
  }

  export type LaboratoryResultCreateNestedOneWithoutDocumentInput = {
    create?: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutDocumentInput
    connect?: LaboratoryResultWhereUniqueInput
  }

  export type MedicalImageCreateNestedOneWithoutDocumentInput = {
    create?: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalImageCreateOrConnectWithoutDocumentInput
    connect?: MedicalImageWhereUniqueInput
  }

  export type DocumentAttachmentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDocumentInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MedicalReportUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalReportCreateOrConnectWithoutDocumentInput
    connect?: MedicalReportWhereUniqueInput
  }

  export type LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutDocumentInput
    connect?: LaboratoryResultWhereUniqueInput
  }

  export type MedicalImageUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalImageCreateOrConnectWithoutDocumentInput
    connect?: MedicalImageWhereUniqueInput
  }

  export type DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalDocumentsInput, PatientUncheckedCreateWithoutMedicalDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalDocumentsInput
    upsert?: PatientUpsertWithoutMedicalDocumentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalDocumentsInput, PatientUpdateWithoutMedicalDocumentsInput>, PatientUncheckedUpdateWithoutMedicalDocumentsInput>
  }

  export type ConsultationUpdateOneWithoutMedicalDocumentsNestedInput = {
    create?: XOR<ConsultationCreateWithoutMedicalDocumentsInput, ConsultationUncheckedCreateWithoutMedicalDocumentsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedicalDocumentsInput
    upsert?: ConsultationUpsertWithoutMedicalDocumentsInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutMedicalDocumentsInput, ConsultationUpdateWithoutMedicalDocumentsInput>, ConsultationUncheckedUpdateWithoutMedicalDocumentsInput>
  }

  export type PrescriptionUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDocumentInput
    upsert?: PrescriptionUpsertWithoutDocumentInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutDocumentInput, PrescriptionUpdateWithoutDocumentInput>, PrescriptionUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalReportUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalReportCreateOrConnectWithoutDocumentInput
    upsert?: MedicalReportUpsertWithoutDocumentInput
    disconnect?: MedicalReportWhereInput | boolean
    delete?: MedicalReportWhereInput | boolean
    connect?: MedicalReportWhereUniqueInput
    update?: XOR<XOR<MedicalReportUpdateToOneWithWhereWithoutDocumentInput, MedicalReportUpdateWithoutDocumentInput>, MedicalReportUncheckedUpdateWithoutDocumentInput>
  }

  export type LaboratoryResultUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutDocumentInput
    upsert?: LaboratoryResultUpsertWithoutDocumentInput
    disconnect?: LaboratoryResultWhereInput | boolean
    delete?: LaboratoryResultWhereInput | boolean
    connect?: LaboratoryResultWhereUniqueInput
    update?: XOR<XOR<LaboratoryResultUpdateToOneWithWhereWithoutDocumentInput, LaboratoryResultUpdateWithoutDocumentInput>, LaboratoryResultUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalImageUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalImageCreateOrConnectWithoutDocumentInput
    upsert?: MedicalImageUpsertWithoutDocumentInput
    disconnect?: MedicalImageWhereInput | boolean
    delete?: MedicalImageWhereInput | boolean
    connect?: MedicalImageWhereUniqueInput
    update?: XOR<XOR<MedicalImageUpdateToOneWithWhereWithoutDocumentInput, MedicalImageUpdateWithoutDocumentInput>, MedicalImageUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAttachmentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDocumentInput
    upsert?: PrescriptionUpsertWithoutDocumentInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutDocumentInput, PrescriptionUpdateWithoutDocumentInput>, PrescriptionUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalReportCreateOrConnectWithoutDocumentInput
    upsert?: MedicalReportUpsertWithoutDocumentInput
    disconnect?: MedicalReportWhereInput | boolean
    delete?: MedicalReportWhereInput | boolean
    connect?: MedicalReportWhereUniqueInput
    update?: XOR<XOR<MedicalReportUpdateToOneWithWhereWithoutDocumentInput, MedicalReportUpdateWithoutDocumentInput>, MedicalReportUncheckedUpdateWithoutDocumentInput>
  }

  export type LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LaboratoryResultCreateOrConnectWithoutDocumentInput
    upsert?: LaboratoryResultUpsertWithoutDocumentInput
    disconnect?: LaboratoryResultWhereInput | boolean
    delete?: LaboratoryResultWhereInput | boolean
    connect?: LaboratoryResultWhereUniqueInput
    update?: XOR<XOR<LaboratoryResultUpdateToOneWithWhereWithoutDocumentInput, LaboratoryResultUpdateWithoutDocumentInput>, LaboratoryResultUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: MedicalImageCreateOrConnectWithoutDocumentInput
    upsert?: MedicalImageUpsertWithoutDocumentInput
    disconnect?: MedicalImageWhereInput | boolean
    delete?: MedicalImageWhereInput | boolean
    connect?: MedicalImageWhereUniqueInput
    update?: XOR<XOR<MedicalImageUpdateToOneWithWhereWithoutDocumentInput, MedicalImageUpdateWithoutDocumentInput>, MedicalImageUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type MedicalDocumentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MedicalDocumentCreateWithoutAttachmentsInput, MedicalDocumentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutAttachmentsInput
    connect?: MedicalDocumentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MedicalDocumentUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutAttachmentsInput, MedicalDocumentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutAttachmentsInput
    upsert?: MedicalDocumentUpsertWithoutAttachmentsInput
    connect?: MedicalDocumentWhereUniqueInput
    update?: XOR<XOR<MedicalDocumentUpdateToOneWithWhereWithoutAttachmentsInput, MedicalDocumentUpdateWithoutAttachmentsInput>, MedicalDocumentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicalDocumentCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<MedicalDocumentCreateWithoutPrescriptionInput, MedicalDocumentUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPrescriptionInput
    connect?: MedicalDocumentWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type MedicalDocumentUpdateOneWithoutPrescriptionNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutPrescriptionInput, MedicalDocumentUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutPrescriptionInput
    upsert?: MedicalDocumentUpsertWithoutPrescriptionInput
    disconnect?: MedicalDocumentWhereInput | boolean
    delete?: MedicalDocumentWhereInput | boolean
    connect?: MedicalDocumentWhereUniqueInput
    update?: XOR<XOR<MedicalDocumentUpdateToOneWithWhereWithoutPrescriptionInput, MedicalDocumentUpdateWithoutPrescriptionInput>, MedicalDocumentUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PatientCreateNestedOneWithoutMedicalReportsInput = {
    create?: XOR<PatientCreateWithoutMedicalReportsInput, PatientUncheckedCreateWithoutMedicalReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalReportsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicalDocumentCreateNestedOneWithoutMedicalReportInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalReportInput, MedicalDocumentUncheckedCreateWithoutMedicalReportInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalReportInput
    connect?: MedicalDocumentWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutMedicalReportsInput = {
    create?: XOR<ConsultationCreateWithoutMedicalReportsInput, ConsultationUncheckedCreateWithoutMedicalReportsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedicalReportsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicalReportsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalReportsInput, PatientUncheckedCreateWithoutMedicalReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalReportsInput
    upsert?: PatientUpsertWithoutMedicalReportsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalReportsInput, PatientUpdateWithoutMedicalReportsInput>, PatientUncheckedUpdateWithoutMedicalReportsInput>
  }

  export type MedicalDocumentUpdateOneWithoutMedicalReportNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalReportInput, MedicalDocumentUncheckedCreateWithoutMedicalReportInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalReportInput
    upsert?: MedicalDocumentUpsertWithoutMedicalReportInput
    disconnect?: MedicalDocumentWhereInput | boolean
    delete?: MedicalDocumentWhereInput | boolean
    connect?: MedicalDocumentWhereUniqueInput
    update?: XOR<XOR<MedicalDocumentUpdateToOneWithWhereWithoutMedicalReportInput, MedicalDocumentUpdateWithoutMedicalReportInput>, MedicalDocumentUncheckedUpdateWithoutMedicalReportInput>
  }

  export type ConsultationUpdateOneWithoutMedicalReportsNestedInput = {
    create?: XOR<ConsultationCreateWithoutMedicalReportsInput, ConsultationUncheckedCreateWithoutMedicalReportsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedicalReportsInput
    upsert?: ConsultationUpsertWithoutMedicalReportsInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutMedicalReportsInput, ConsultationUpdateWithoutMedicalReportsInput>, ConsultationUncheckedUpdateWithoutMedicalReportsInput>
  }

  export type PatientCreateNestedOneWithoutLaboratoryResultsInput = {
    create?: XOR<PatientCreateWithoutLaboratoryResultsInput, PatientUncheckedCreateWithoutLaboratoryResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLaboratoryResultsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicalDocumentCreateNestedOneWithoutLaboratoryResultInput = {
    create?: XOR<MedicalDocumentCreateWithoutLaboratoryResultInput, MedicalDocumentUncheckedCreateWithoutLaboratoryResultInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutLaboratoryResultInput
    connect?: MedicalDocumentWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutLaboratoryResultsNestedInput = {
    create?: XOR<PatientCreateWithoutLaboratoryResultsInput, PatientUncheckedCreateWithoutLaboratoryResultsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLaboratoryResultsInput
    upsert?: PatientUpsertWithoutLaboratoryResultsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLaboratoryResultsInput, PatientUpdateWithoutLaboratoryResultsInput>, PatientUncheckedUpdateWithoutLaboratoryResultsInput>
  }

  export type MedicalDocumentUpdateOneWithoutLaboratoryResultNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutLaboratoryResultInput, MedicalDocumentUncheckedCreateWithoutLaboratoryResultInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutLaboratoryResultInput
    upsert?: MedicalDocumentUpsertWithoutLaboratoryResultInput
    disconnect?: MedicalDocumentWhereInput | boolean
    delete?: MedicalDocumentWhereInput | boolean
    connect?: MedicalDocumentWhereUniqueInput
    update?: XOR<XOR<MedicalDocumentUpdateToOneWithWhereWithoutLaboratoryResultInput, MedicalDocumentUpdateWithoutLaboratoryResultInput>, MedicalDocumentUncheckedUpdateWithoutLaboratoryResultInput>
  }

  export type PatientCreateNestedOneWithoutMedicalImagesInput = {
    create?: XOR<PatientCreateWithoutMedicalImagesInput, PatientUncheckedCreateWithoutMedicalImagesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalImagesInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicalDocumentCreateNestedOneWithoutMedicalImageInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalImageInput, MedicalDocumentUncheckedCreateWithoutMedicalImageInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalImageInput
    connect?: MedicalDocumentWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicalImagesNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalImagesInput, PatientUncheckedCreateWithoutMedicalImagesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalImagesInput
    upsert?: PatientUpsertWithoutMedicalImagesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalImagesInput, PatientUpdateWithoutMedicalImagesInput>, PatientUncheckedUpdateWithoutMedicalImagesInput>
  }

  export type MedicalDocumentUpdateOneWithoutMedicalImageNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalImageInput, MedicalDocumentUncheckedCreateWithoutMedicalImageInput>
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalImageInput
    upsert?: MedicalDocumentUpsertWithoutMedicalImageInput
    disconnect?: MedicalDocumentWhereInput | boolean
    delete?: MedicalDocumentWhereInput | boolean
    connect?: MedicalDocumentWhereUniqueInput
    update?: XOR<XOR<MedicalDocumentUpdateToOneWithWhereWithoutMedicalImageInput, MedicalDocumentUpdateWithoutMedicalImageInput>, MedicalDocumentUncheckedUpdateWithoutMedicalImageInput>
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<ConsultationCreateWithoutAppointmentInput, ConsultationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutAppointmentInput
    connect?: ConsultationWhereUniqueInput
  }

  export type AppointmentReminderCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput> | AppointmentReminderCreateWithoutAppointmentInput[] | AppointmentReminderUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentReminderCreateOrConnectWithoutAppointmentInput | AppointmentReminderCreateOrConnectWithoutAppointmentInput[]
    createMany?: AppointmentReminderCreateManyAppointmentInputEnvelope
    connect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
  }

  export type AppointmentReminderUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput> | AppointmentReminderCreateWithoutAppointmentInput[] | AppointmentReminderUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentReminderCreateOrConnectWithoutAppointmentInput | AppointmentReminderCreateOrConnectWithoutAppointmentInput[]
    createMany?: AppointmentReminderCreateManyAppointmentInputEnvelope
    connect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ConsultationUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<ConsultationCreateWithoutAppointmentInput, ConsultationUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutAppointmentInput
    upsert?: ConsultationUpsertWithoutAppointmentInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutAppointmentInput, ConsultationUpdateWithoutAppointmentInput>, ConsultationUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentReminderUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput> | AppointmentReminderCreateWithoutAppointmentInput[] | AppointmentReminderUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentReminderCreateOrConnectWithoutAppointmentInput | AppointmentReminderCreateOrConnectWithoutAppointmentInput[]
    upsert?: AppointmentReminderUpsertWithWhereUniqueWithoutAppointmentInput | AppointmentReminderUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AppointmentReminderCreateManyAppointmentInputEnvelope
    set?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    disconnect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    delete?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    connect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    update?: AppointmentReminderUpdateWithWhereUniqueWithoutAppointmentInput | AppointmentReminderUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AppointmentReminderUpdateManyWithWhereWithoutAppointmentInput | AppointmentReminderUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AppointmentReminderScalarWhereInput | AppointmentReminderScalarWhereInput[]
  }

  export type AppointmentReminderUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput> | AppointmentReminderCreateWithoutAppointmentInput[] | AppointmentReminderUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentReminderCreateOrConnectWithoutAppointmentInput | AppointmentReminderCreateOrConnectWithoutAppointmentInput[]
    upsert?: AppointmentReminderUpsertWithWhereUniqueWithoutAppointmentInput | AppointmentReminderUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AppointmentReminderCreateManyAppointmentInputEnvelope
    set?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    disconnect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    delete?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    connect?: AppointmentReminderWhereUniqueInput | AppointmentReminderWhereUniqueInput[]
    update?: AppointmentReminderUpdateWithWhereUniqueWithoutAppointmentInput | AppointmentReminderUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AppointmentReminderUpdateManyWithWhereWithoutAppointmentInput | AppointmentReminderUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AppointmentReminderScalarWhereInput | AppointmentReminderScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutRemindersInput = {
    create?: XOR<AppointmentCreateWithoutRemindersInput, AppointmentUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRemindersInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<AppointmentCreateWithoutRemindersInput, AppointmentUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutRemindersInput
    upsert?: AppointmentUpsertWithoutRemindersInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutRemindersInput, AppointmentUpdateWithoutRemindersInput>, AppointmentUncheckedUpdateWithoutRemindersInput>
  }

  export type MessageThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageThreadUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    upsert?: MessageThreadUpsertWithoutMessagesInput
    disconnect?: MessageThreadWhereInput | boolean
    delete?: MessageThreadWhereInput | boolean
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutMessagesInput, MessageThreadUpdateWithoutMessagesInput>, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageThreadCreateparticipantIdsInput = {
    set: string[]
  }

  export type InternalMessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput> | InternalMessageCreateWithoutThreadInput[] | InternalMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: InternalMessageCreateOrConnectWithoutThreadInput | InternalMessageCreateOrConnectWithoutThreadInput[]
    createMany?: InternalMessageCreateManyThreadInputEnvelope
    connect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
  }

  export type InternalMessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput> | InternalMessageCreateWithoutThreadInput[] | InternalMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: InternalMessageCreateOrConnectWithoutThreadInput | InternalMessageCreateOrConnectWithoutThreadInput[]
    createMany?: InternalMessageCreateManyThreadInputEnvelope
    connect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
  }

  export type MessageThreadUpdateparticipantIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InternalMessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput> | InternalMessageCreateWithoutThreadInput[] | InternalMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: InternalMessageCreateOrConnectWithoutThreadInput | InternalMessageCreateOrConnectWithoutThreadInput[]
    upsert?: InternalMessageUpsertWithWhereUniqueWithoutThreadInput | InternalMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: InternalMessageCreateManyThreadInputEnvelope
    set?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    disconnect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    delete?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    connect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    update?: InternalMessageUpdateWithWhereUniqueWithoutThreadInput | InternalMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: InternalMessageUpdateManyWithWhereWithoutThreadInput | InternalMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: InternalMessageScalarWhereInput | InternalMessageScalarWhereInput[]
  }

  export type InternalMessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput> | InternalMessageCreateWithoutThreadInput[] | InternalMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: InternalMessageCreateOrConnectWithoutThreadInput | InternalMessageCreateOrConnectWithoutThreadInput[]
    upsert?: InternalMessageUpsertWithWhereUniqueWithoutThreadInput | InternalMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: InternalMessageCreateManyThreadInputEnvelope
    set?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    disconnect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    delete?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    connect?: InternalMessageWhereUniqueInput | InternalMessageWhereUniqueInput[]
    update?: InternalMessageUpdateWithWhereUniqueWithoutThreadInput | InternalMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: InternalMessageUpdateManyWithWhereWithoutThreadInput | InternalMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: InternalMessageScalarWhereInput | InternalMessageScalarWhereInput[]
  }

  export type InternalMessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<InternalMessageCreateWithoutAttachmentsInput, InternalMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: InternalMessageCreateOrConnectWithoutAttachmentsInput
    connect?: InternalMessageWhereUniqueInput
  }

  export type InternalMessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<InternalMessageCreateWithoutAttachmentsInput, InternalMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: InternalMessageCreateOrConnectWithoutAttachmentsInput
    upsert?: InternalMessageUpsertWithoutAttachmentsInput
    connect?: InternalMessageWhereUniqueInput
    update?: XOR<XOR<InternalMessageUpdateToOneWithWhereWithoutAttachmentsInput, InternalMessageUpdateWithoutAttachmentsInput>, InternalMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type StaffMemberCreatequalificationsInput = {
    set: string[]
  }

  export type ShiftCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput> | ShiftCreateWithoutStaffMemberInput[] | ShiftUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutStaffMemberInput | ShiftCreateOrConnectWithoutStaffMemberInput[]
    createMany?: ShiftCreateManyStaffMemberInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput> | LeaveCreateWithoutStaffMemberInput[] | LeaveUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutStaffMemberInput | LeaveCreateOrConnectWithoutStaffMemberInput[]
    createMany?: LeaveCreateManyStaffMemberInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput> | ScheduleCreateWithoutStaffMemberInput[] | ScheduleUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutStaffMemberInput | ScheduleCreateOrConnectWithoutStaffMemberInput[]
    createMany?: ScheduleCreateManyStaffMemberInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput> | ShiftCreateWithoutStaffMemberInput[] | ShiftUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutStaffMemberInput | ShiftCreateOrConnectWithoutStaffMemberInput[]
    createMany?: ShiftCreateManyStaffMemberInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput> | LeaveCreateWithoutStaffMemberInput[] | LeaveUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutStaffMemberInput | LeaveCreateOrConnectWithoutStaffMemberInput[]
    createMany?: LeaveCreateManyStaffMemberInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutStaffMemberInput = {
    create?: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput> | ScheduleCreateWithoutStaffMemberInput[] | ScheduleUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutStaffMemberInput | ScheduleCreateOrConnectWithoutStaffMemberInput[]
    createMany?: ScheduleCreateManyStaffMemberInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type StaffMemberUpdatequalificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShiftUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput> | ShiftCreateWithoutStaffMemberInput[] | ShiftUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutStaffMemberInput | ShiftCreateOrConnectWithoutStaffMemberInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutStaffMemberInput | ShiftUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: ShiftCreateManyStaffMemberInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutStaffMemberInput | ShiftUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutStaffMemberInput | ShiftUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput> | LeaveCreateWithoutStaffMemberInput[] | LeaveUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutStaffMemberInput | LeaveCreateOrConnectWithoutStaffMemberInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutStaffMemberInput | LeaveUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: LeaveCreateManyStaffMemberInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutStaffMemberInput | LeaveUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutStaffMemberInput | LeaveUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput> | ScheduleCreateWithoutStaffMemberInput[] | ScheduleUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutStaffMemberInput | ScheduleCreateOrConnectWithoutStaffMemberInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutStaffMemberInput | ScheduleUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: ScheduleCreateManyStaffMemberInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutStaffMemberInput | ScheduleUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutStaffMemberInput | ScheduleUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput> | ShiftCreateWithoutStaffMemberInput[] | ShiftUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutStaffMemberInput | ShiftCreateOrConnectWithoutStaffMemberInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutStaffMemberInput | ShiftUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: ShiftCreateManyStaffMemberInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutStaffMemberInput | ShiftUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutStaffMemberInput | ShiftUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput> | LeaveCreateWithoutStaffMemberInput[] | LeaveUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutStaffMemberInput | LeaveCreateOrConnectWithoutStaffMemberInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutStaffMemberInput | LeaveUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: LeaveCreateManyStaffMemberInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutStaffMemberInput | LeaveUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutStaffMemberInput | LeaveUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutStaffMemberNestedInput = {
    create?: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput> | ScheduleCreateWithoutStaffMemberInput[] | ScheduleUncheckedCreateWithoutStaffMemberInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutStaffMemberInput | ScheduleCreateOrConnectWithoutStaffMemberInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutStaffMemberInput | ScheduleUpsertWithWhereUniqueWithoutStaffMemberInput[]
    createMany?: ScheduleCreateManyStaffMemberInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutStaffMemberInput | ScheduleUpdateWithWhereUniqueWithoutStaffMemberInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutStaffMemberInput | ScheduleUpdateManyWithWhereWithoutStaffMemberInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type StaffMemberCreateNestedOneWithoutShiftsInput = {
    create?: XOR<StaffMemberCreateWithoutShiftsInput, StaffMemberUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutShiftsInput
    connect?: StaffMemberWhereUniqueInput
  }

  export type StaffMemberUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<StaffMemberCreateWithoutShiftsInput, StaffMemberUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutShiftsInput
    upsert?: StaffMemberUpsertWithoutShiftsInput
    connect?: StaffMemberWhereUniqueInput
    update?: XOR<XOR<StaffMemberUpdateToOneWithWhereWithoutShiftsInput, StaffMemberUpdateWithoutShiftsInput>, StaffMemberUncheckedUpdateWithoutShiftsInput>
  }

  export type StaffMemberCreateNestedOneWithoutLeavesInput = {
    create?: XOR<StaffMemberCreateWithoutLeavesInput, StaffMemberUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutLeavesInput
    connect?: StaffMemberWhereUniqueInput
  }

  export type StaffMemberUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<StaffMemberCreateWithoutLeavesInput, StaffMemberUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutLeavesInput
    upsert?: StaffMemberUpsertWithoutLeavesInput
    connect?: StaffMemberWhereUniqueInput
    update?: XOR<XOR<StaffMemberUpdateToOneWithWhereWithoutLeavesInput, StaffMemberUpdateWithoutLeavesInput>, StaffMemberUncheckedUpdateWithoutLeavesInput>
  }

  export type StaffMemberCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<StaffMemberCreateWithoutSchedulesInput, StaffMemberUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutSchedulesInput
    connect?: StaffMemberWhereUniqueInput
  }

  export type StaffMemberUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<StaffMemberCreateWithoutSchedulesInput, StaffMemberUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: StaffMemberCreateOrConnectWithoutSchedulesInput
    upsert?: StaffMemberUpsertWithoutSchedulesInput
    connect?: StaffMemberWhereUniqueInput
    update?: XOR<XOR<StaffMemberUpdateToOneWithWhereWithoutSchedulesInput, StaffMemberUpdateWithoutSchedulesInput>, StaffMemberUncheckedUpdateWithoutSchedulesInput>
  }

  export type StockMovementCreateNestedManyWithoutStockItemInput = {
    create?: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput> | StockMovementCreateWithoutStockItemInput[] | StockMovementUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStockItemInput | StockMovementCreateOrConnectWithoutStockItemInput[]
    createMany?: StockMovementCreateManyStockItemInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockAlertCreateNestedManyWithoutStockItemInput = {
    create?: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput> | StockAlertCreateWithoutStockItemInput[] | StockAlertUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockAlertCreateOrConnectWithoutStockItemInput | StockAlertCreateOrConnectWithoutStockItemInput[]
    createMany?: StockAlertCreateManyStockItemInputEnvelope
    connect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutStockItemInput = {
    create?: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput> | StockMovementCreateWithoutStockItemInput[] | StockMovementUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStockItemInput | StockMovementCreateOrConnectWithoutStockItemInput[]
    createMany?: StockMovementCreateManyStockItemInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StockAlertUncheckedCreateNestedManyWithoutStockItemInput = {
    create?: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput> | StockAlertCreateWithoutStockItemInput[] | StockAlertUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockAlertCreateOrConnectWithoutStockItemInput | StockAlertCreateOrConnectWithoutStockItemInput[]
    createMany?: StockAlertCreateManyStockItemInputEnvelope
    connect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StockMovementUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput> | StockMovementCreateWithoutStockItemInput[] | StockMovementUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStockItemInput | StockMovementCreateOrConnectWithoutStockItemInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutStockItemInput | StockMovementUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: StockMovementCreateManyStockItemInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutStockItemInput | StockMovementUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutStockItemInput | StockMovementUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockAlertUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput> | StockAlertCreateWithoutStockItemInput[] | StockAlertUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockAlertCreateOrConnectWithoutStockItemInput | StockAlertCreateOrConnectWithoutStockItemInput[]
    upsert?: StockAlertUpsertWithWhereUniqueWithoutStockItemInput | StockAlertUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: StockAlertCreateManyStockItemInputEnvelope
    set?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    disconnect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    delete?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    connect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    update?: StockAlertUpdateWithWhereUniqueWithoutStockItemInput | StockAlertUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: StockAlertUpdateManyWithWhereWithoutStockItemInput | StockAlertUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: StockAlertScalarWhereInput | StockAlertScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput> | StockMovementCreateWithoutStockItemInput[] | StockMovementUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStockItemInput | StockMovementCreateOrConnectWithoutStockItemInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutStockItemInput | StockMovementUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: StockMovementCreateManyStockItemInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutStockItemInput | StockMovementUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutStockItemInput | StockMovementUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StockAlertUncheckedUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput> | StockAlertCreateWithoutStockItemInput[] | StockAlertUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: StockAlertCreateOrConnectWithoutStockItemInput | StockAlertCreateOrConnectWithoutStockItemInput[]
    upsert?: StockAlertUpsertWithWhereUniqueWithoutStockItemInput | StockAlertUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: StockAlertCreateManyStockItemInputEnvelope
    set?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    disconnect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    delete?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    connect?: StockAlertWhereUniqueInput | StockAlertWhereUniqueInput[]
    update?: StockAlertUpdateWithWhereUniqueWithoutStockItemInput | StockAlertUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: StockAlertUpdateManyWithWhereWithoutStockItemInput | StockAlertUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: StockAlertScalarWhereInput | StockAlertScalarWhereInput[]
  }

  export type StockItemCreateNestedOneWithoutMovementsInput = {
    create?: XOR<StockItemCreateWithoutMovementsInput, StockItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutMovementsInput
    connect?: StockItemWhereUniqueInput
  }

  export type StockItemUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<StockItemCreateWithoutMovementsInput, StockItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutMovementsInput
    upsert?: StockItemUpsertWithoutMovementsInput
    connect?: StockItemWhereUniqueInput
    update?: XOR<XOR<StockItemUpdateToOneWithWhereWithoutMovementsInput, StockItemUpdateWithoutMovementsInput>, StockItemUncheckedUpdateWithoutMovementsInput>
  }

  export type StockItemCreateNestedOneWithoutAlertsInput = {
    create?: XOR<StockItemCreateWithoutAlertsInput, StockItemUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutAlertsInput
    connect?: StockItemWhereUniqueInput
  }

  export type StockItemUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<StockItemCreateWithoutAlertsInput, StockItemUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutAlertsInput
    upsert?: StockItemUpsertWithoutAlertsInput
    connect?: StockItemWhereUniqueInput
    update?: XOR<XOR<StockItemUpdateToOneWithWhereWithoutAlertsInput, StockItemUpdateWithoutAlertsInput>, StockItemUncheckedUpdateWithoutAlertsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ConsultationCreateWithoutPatientInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutPatientInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationCreateManyPatientInputEnvelope = {
    data: ConsultationCreateManyPatientInput | ConsultationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type SemanticNodeCreateWithoutPatientInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    sourceRelations?: SemanticRelationCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationCreateNestedManyWithoutTargetNodeInput
    consultation?: ConsultationCreateNestedOneWithoutSemanticNodesInput
  }

  export type SemanticNodeUncheckedCreateWithoutPatientInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    consultationId?: string | null
    sourceRelations?: SemanticRelationUncheckedCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type SemanticNodeCreateOrConnectWithoutPatientInput = {
    where: SemanticNodeWhereUniqueInput
    create: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput>
  }

  export type SemanticNodeCreateManyPatientInputEnvelope = {
    data: SemanticNodeCreateManyPatientInput | SemanticNodeCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalDocumentCreateWithoutPatientInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutPatientInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutPatientInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput>
  }

  export type MedicalDocumentCreateManyPatientInputEnvelope = {
    data: MedicalDocumentCreateManyPatientInput | MedicalDocumentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    createdAt?: Date | string
    prescribedBy: string
    document?: MedicalDocumentCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    documentId?: string | null
    createdAt?: Date | string
    prescribedBy: string
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalReportCreateWithoutPatientInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
    document?: MedicalDocumentCreateNestedOneWithoutMedicalReportInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalReportsInput
  }

  export type MedicalReportUncheckedCreateWithoutPatientInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    consultationId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type MedicalReportCreateOrConnectWithoutPatientInput = {
    where: MedicalReportWhereUniqueInput
    create: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput>
  }

  export type MedicalReportCreateManyPatientInputEnvelope = {
    data: MedicalReportCreateManyPatientInput | MedicalReportCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LaboratoryResultCreateWithoutPatientInput = {
    id?: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    document?: MedicalDocumentCreateNestedOneWithoutLaboratoryResultInput
  }

  export type LaboratoryResultUncheckedCreateWithoutPatientInput = {
    id?: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    documentId?: string | null
  }

  export type LaboratoryResultCreateOrConnectWithoutPatientInput = {
    where: LaboratoryResultWhereUniqueInput
    create: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput>
  }

  export type LaboratoryResultCreateManyPatientInputEnvelope = {
    data: LaboratoryResultCreateManyPatientInput | LaboratoryResultCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalImageCreateWithoutPatientInput = {
    id?: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    acquisitionDate: Date | string
    createdAt?: Date | string
    document?: MedicalDocumentCreateNestedOneWithoutMedicalImageInput
  }

  export type MedicalImageUncheckedCreateWithoutPatientInput = {
    id?: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    documentId?: string | null
    acquisitionDate: Date | string
    createdAt?: Date | string
  }

  export type MedicalImageCreateOrConnectWithoutPatientInput = {
    where: MedicalImageWhereUniqueInput
    create: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput>
  }

  export type MedicalImageCreateManyPatientInputEnvelope = {
    data: MedicalImageCreateManyPatientInput | MedicalImageCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    consultation?: ConsultationCreateNestedOneWithoutAppointmentInput
    reminders?: AppointmentReminderCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    consultationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    reminders?: AppointmentReminderUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AllergyCreateWithoutPatientInput = {
    id?: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
  }

  export type AllergyUncheckedCreateWithoutPatientInput = {
    id?: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
  }

  export type AllergyCreateOrConnectWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyCreateManyPatientInputEnvelope = {
    data: AllergyCreateManyPatientInput | AllergyCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutPatientInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsultationScalarWhereInput = {
    AND?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    OR?: ConsultationScalarWhereInput[]
    NOT?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    id?: StringFilter<"Consultation"> | string
    patientId?: StringFilter<"Consultation"> | string
    consultationDate?: DateTimeFilter<"Consultation"> | Date | string
    startTime?: DateTimeFilter<"Consultation"> | Date | string
    endTime?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: StringFilter<"Consultation"> | string
    rawTranscript?: StringNullableFilter<"Consultation"> | string | null
    rawText?: StringNullableFilter<"Consultation"> | string | null
    draftData?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    validatedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    createdBy?: StringFilter<"Consultation"> | string
  }

  export type SemanticNodeUpsertWithWhereUniqueWithoutPatientInput = {
    where: SemanticNodeWhereUniqueInput
    update: XOR<SemanticNodeUpdateWithoutPatientInput, SemanticNodeUncheckedUpdateWithoutPatientInput>
    create: XOR<SemanticNodeCreateWithoutPatientInput, SemanticNodeUncheckedCreateWithoutPatientInput>
  }

  export type SemanticNodeUpdateWithWhereUniqueWithoutPatientInput = {
    where: SemanticNodeWhereUniqueInput
    data: XOR<SemanticNodeUpdateWithoutPatientInput, SemanticNodeUncheckedUpdateWithoutPatientInput>
  }

  export type SemanticNodeUpdateManyWithWhereWithoutPatientInput = {
    where: SemanticNodeScalarWhereInput
    data: XOR<SemanticNodeUpdateManyMutationInput, SemanticNodeUncheckedUpdateManyWithoutPatientInput>
  }

  export type SemanticNodeScalarWhereInput = {
    AND?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
    OR?: SemanticNodeScalarWhereInput[]
    NOT?: SemanticNodeScalarWhereInput | SemanticNodeScalarWhereInput[]
    id?: StringFilter<"SemanticNode"> | string
    nodeType?: StringFilter<"SemanticNode"> | string
    snomedCtCode?: StringNullableFilter<"SemanticNode"> | string | null
    cim10Code?: StringNullableFilter<"SemanticNode"> | string | null
    cim11Code?: StringNullableFilter<"SemanticNode"> | string | null
    label?: StringFilter<"SemanticNode"> | string
    description?: StringNullableFilter<"SemanticNode"> | string | null
    embedding?: JsonNullableFilter<"SemanticNode">
    value?: JsonNullableFilter<"SemanticNode">
    unit?: StringNullableFilter<"SemanticNode"> | string | null
    createdAt?: DateTimeFilter<"SemanticNode"> | Date | string
    updatedAt?: DateTimeFilter<"SemanticNode"> | Date | string
    confidence?: FloatNullableFilter<"SemanticNode"> | number | null
    patientId?: StringNullableFilter<"SemanticNode"> | string | null
    consultationId?: StringNullableFilter<"SemanticNode"> | string | null
  }

  export type MedicalDocumentUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalDocumentWhereUniqueInput
    update: XOR<MedicalDocumentUpdateWithoutPatientInput, MedicalDocumentUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalDocumentCreateWithoutPatientInput, MedicalDocumentUncheckedCreateWithoutPatientInput>
  }

  export type MedicalDocumentUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalDocumentWhereUniqueInput
    data: XOR<MedicalDocumentUpdateWithoutPatientInput, MedicalDocumentUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalDocumentUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalDocumentScalarWhereInput
    data: XOR<MedicalDocumentUpdateManyMutationInput, MedicalDocumentUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalDocumentScalarWhereInput = {
    AND?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
    OR?: MedicalDocumentScalarWhereInput[]
    NOT?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
    id?: StringFilter<"MedicalDocument"> | string
    patientId?: StringFilter<"MedicalDocument"> | string
    documentType?: StringFilter<"MedicalDocument"> | string
    title?: StringFilter<"MedicalDocument"> | string
    content?: JsonFilter<"MedicalDocument">
    rawContent?: StringNullableFilter<"MedicalDocument"> | string | null
    documentDate?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    createdBy?: StringFilter<"MedicalDocument"> | string
    consultationId?: StringNullableFilter<"MedicalDocument"> | string | null
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    medicationName?: StringFilter<"Prescription"> | string
    atcCode?: StringNullableFilter<"Prescription"> | string | null
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
    duration?: StringNullableFilter<"Prescription"> | string | null
    status?: StringFilter<"Prescription"> | string
    safetyChecks?: JsonNullableFilter<"Prescription">
    outpassReason?: StringNullableFilter<"Prescription"> | string | null
    documentId?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    prescribedBy?: StringFilter<"Prescription"> | string
  }

  export type MedicalReportUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalReportWhereUniqueInput
    update: XOR<MedicalReportUpdateWithoutPatientInput, MedicalReportUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalReportCreateWithoutPatientInput, MedicalReportUncheckedCreateWithoutPatientInput>
  }

  export type MedicalReportUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalReportWhereUniqueInput
    data: XOR<MedicalReportUpdateWithoutPatientInput, MedicalReportUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalReportUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalReportScalarWhereInput
    data: XOR<MedicalReportUpdateManyMutationInput, MedicalReportUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalReportScalarWhereInput = {
    AND?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
    OR?: MedicalReportScalarWhereInput[]
    NOT?: MedicalReportScalarWhereInput | MedicalReportScalarWhereInput[]
    id?: StringFilter<"MedicalReport"> | string
    patientId?: StringFilter<"MedicalReport"> | string
    reportType?: StringFilter<"MedicalReport"> | string
    title?: StringFilter<"MedicalReport"> | string
    chiefComplaint?: StringNullableFilter<"MedicalReport"> | string | null
    history?: StringNullableFilter<"MedicalReport"> | string | null
    examination?: StringNullableFilter<"MedicalReport"> | string | null
    assessment?: StringNullableFilter<"MedicalReport"> | string | null
    plan?: StringNullableFilter<"MedicalReport"> | string | null
    documentId?: StringNullableFilter<"MedicalReport"> | string | null
    consultationId?: StringNullableFilter<"MedicalReport"> | string | null
    reportDate?: DateTimeFilter<"MedicalReport"> | Date | string
    createdAt?: DateTimeFilter<"MedicalReport"> | Date | string
    createdBy?: StringFilter<"MedicalReport"> | string
  }

  export type LaboratoryResultUpsertWithWhereUniqueWithoutPatientInput = {
    where: LaboratoryResultWhereUniqueInput
    update: XOR<LaboratoryResultUpdateWithoutPatientInput, LaboratoryResultUncheckedUpdateWithoutPatientInput>
    create: XOR<LaboratoryResultCreateWithoutPatientInput, LaboratoryResultUncheckedCreateWithoutPatientInput>
  }

  export type LaboratoryResultUpdateWithWhereUniqueWithoutPatientInput = {
    where: LaboratoryResultWhereUniqueInput
    data: XOR<LaboratoryResultUpdateWithoutPatientInput, LaboratoryResultUncheckedUpdateWithoutPatientInput>
  }

  export type LaboratoryResultUpdateManyWithWhereWithoutPatientInput = {
    where: LaboratoryResultScalarWhereInput
    data: XOR<LaboratoryResultUpdateManyMutationInput, LaboratoryResultUncheckedUpdateManyWithoutPatientInput>
  }

  export type LaboratoryResultScalarWhereInput = {
    AND?: LaboratoryResultScalarWhereInput | LaboratoryResultScalarWhereInput[]
    OR?: LaboratoryResultScalarWhereInput[]
    NOT?: LaboratoryResultScalarWhereInput | LaboratoryResultScalarWhereInput[]
    id?: StringFilter<"LaboratoryResult"> | string
    patientId?: StringFilter<"LaboratoryResult"> | string
    testName?: StringFilter<"LaboratoryResult"> | string
    testCode?: StringNullableFilter<"LaboratoryResult"> | string | null
    resultValue?: StringFilter<"LaboratoryResult"> | string
    unit?: StringNullableFilter<"LaboratoryResult"> | string | null
    referenceRange?: StringNullableFilter<"LaboratoryResult"> | string | null
    status?: StringFilter<"LaboratoryResult"> | string
    testDate?: DateTimeFilter<"LaboratoryResult"> | Date | string
    receivedAt?: DateTimeFilter<"LaboratoryResult"> | Date | string
    laboratoryName?: StringNullableFilter<"LaboratoryResult"> | string | null
    documentId?: StringNullableFilter<"LaboratoryResult"> | string | null
  }

  export type MedicalImageUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalImageWhereUniqueInput
    update: XOR<MedicalImageUpdateWithoutPatientInput, MedicalImageUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalImageCreateWithoutPatientInput, MedicalImageUncheckedCreateWithoutPatientInput>
  }

  export type MedicalImageUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalImageWhereUniqueInput
    data: XOR<MedicalImageUpdateWithoutPatientInput, MedicalImageUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalImageUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalImageScalarWhereInput
    data: XOR<MedicalImageUpdateManyMutationInput, MedicalImageUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalImageScalarWhereInput = {
    AND?: MedicalImageScalarWhereInput | MedicalImageScalarWhereInput[]
    OR?: MedicalImageScalarWhereInput[]
    NOT?: MedicalImageScalarWhereInput | MedicalImageScalarWhereInput[]
    id?: StringFilter<"MedicalImage"> | string
    patientId?: StringFilter<"MedicalImage"> | string
    studyInstanceUid?: StringFilter<"MedicalImage"> | string
    seriesInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    sopInstanceUid?: StringNullableFilter<"MedicalImage"> | string | null
    modality?: StringFilter<"MedicalImage"> | string
    bodyPart?: StringNullableFilter<"MedicalImage"> | string | null
    studyDescription?: StringNullableFilter<"MedicalImage"> | string | null
    seriesDescription?: StringNullableFilter<"MedicalImage"> | string | null
    filePath?: StringFilter<"MedicalImage"> | string
    fileSize?: IntFilter<"MedicalImage"> | number
    documentId?: StringNullableFilter<"MedicalImage"> | string | null
    acquisitionDate?: DateTimeFilter<"MedicalImage"> | Date | string
    createdAt?: DateTimeFilter<"MedicalImage"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringNullableFilter<"Appointment"> | string | null
    doctorName?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    title?: StringNullableFilter<"Appointment"> | string | null
    description?: StringNullableFilter<"Appointment"> | string | null
    status?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    consultationId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    createdBy?: StringFilter<"Appointment"> | string
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
  }

  export type AllergyUpsertWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    update: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
    create: XOR<AllergyCreateWithoutPatientInput, AllergyUncheckedCreateWithoutPatientInput>
  }

  export type AllergyUpdateWithWhereUniqueWithoutPatientInput = {
    where: AllergyWhereUniqueInput
    data: XOR<AllergyUpdateWithoutPatientInput, AllergyUncheckedUpdateWithoutPatientInput>
  }

  export type AllergyUpdateManyWithWhereWithoutPatientInput = {
    where: AllergyScalarWhereInput
    data: XOR<AllergyUpdateManyMutationInput, AllergyUncheckedUpdateManyWithoutPatientInput>
  }

  export type AllergyScalarWhereInput = {
    AND?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    OR?: AllergyScalarWhereInput[]
    NOT?: AllergyScalarWhereInput | AllergyScalarWhereInput[]
    id?: StringFilter<"Allergy"> | string
    patientId?: StringFilter<"Allergy"> | string
    substance?: StringFilter<"Allergy"> | string
    snomedCtCode?: StringNullableFilter<"Allergy"> | string | null
    severity?: StringFilter<"Allergy"> | string
    createdAt?: DateTimeFilter<"Allergy"> | Date | string
    source?: StringNullableFilter<"Allergy"> | string | null
  }

  export type PatientCreateWithoutSemanticNodesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutSemanticNodesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutSemanticNodesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutSemanticNodesInput, PatientUncheckedCreateWithoutSemanticNodesInput>
  }

  export type SemanticRelationCreateWithoutSourceNodeInput = {
    id?: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
    targetNode: SemanticNodeCreateNestedOneWithoutTargetRelationsInput
  }

  export type SemanticRelationUncheckedCreateWithoutSourceNodeInput = {
    id?: string
    targetNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationCreateOrConnectWithoutSourceNodeInput = {
    where: SemanticRelationWhereUniqueInput
    create: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput>
  }

  export type SemanticRelationCreateManySourceNodeInputEnvelope = {
    data: SemanticRelationCreateManySourceNodeInput | SemanticRelationCreateManySourceNodeInput[]
    skipDuplicates?: boolean
  }

  export type SemanticRelationCreateWithoutTargetNodeInput = {
    id?: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
    sourceNode: SemanticNodeCreateNestedOneWithoutSourceRelationsInput
  }

  export type SemanticRelationUncheckedCreateWithoutTargetNodeInput = {
    id?: string
    sourceNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationCreateOrConnectWithoutTargetNodeInput = {
    where: SemanticRelationWhereUniqueInput
    create: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput>
  }

  export type SemanticRelationCreateManyTargetNodeInputEnvelope = {
    data: SemanticRelationCreateManyTargetNodeInput | SemanticRelationCreateManyTargetNodeInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationCreateWithoutSemanticNodesInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutSemanticNodesInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutSemanticNodesInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutSemanticNodesInput, ConsultationUncheckedCreateWithoutSemanticNodesInput>
  }

  export type PatientUpsertWithoutSemanticNodesInput = {
    update: XOR<PatientUpdateWithoutSemanticNodesInput, PatientUncheckedUpdateWithoutSemanticNodesInput>
    create: XOR<PatientCreateWithoutSemanticNodesInput, PatientUncheckedCreateWithoutSemanticNodesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutSemanticNodesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutSemanticNodesInput, PatientUncheckedUpdateWithoutSemanticNodesInput>
  }

  export type PatientUpdateWithoutSemanticNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutSemanticNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type SemanticRelationUpsertWithWhereUniqueWithoutSourceNodeInput = {
    where: SemanticRelationWhereUniqueInput
    update: XOR<SemanticRelationUpdateWithoutSourceNodeInput, SemanticRelationUncheckedUpdateWithoutSourceNodeInput>
    create: XOR<SemanticRelationCreateWithoutSourceNodeInput, SemanticRelationUncheckedCreateWithoutSourceNodeInput>
  }

  export type SemanticRelationUpdateWithWhereUniqueWithoutSourceNodeInput = {
    where: SemanticRelationWhereUniqueInput
    data: XOR<SemanticRelationUpdateWithoutSourceNodeInput, SemanticRelationUncheckedUpdateWithoutSourceNodeInput>
  }

  export type SemanticRelationUpdateManyWithWhereWithoutSourceNodeInput = {
    where: SemanticRelationScalarWhereInput
    data: XOR<SemanticRelationUpdateManyMutationInput, SemanticRelationUncheckedUpdateManyWithoutSourceNodeInput>
  }

  export type SemanticRelationScalarWhereInput = {
    AND?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
    OR?: SemanticRelationScalarWhereInput[]
    NOT?: SemanticRelationScalarWhereInput | SemanticRelationScalarWhereInput[]
    id?: StringFilter<"SemanticRelation"> | string
    sourceNodeId?: StringFilter<"SemanticRelation"> | string
    targetNodeId?: StringFilter<"SemanticRelation"> | string
    relationType?: StringFilter<"SemanticRelation"> | string
    strength?: FloatNullableFilter<"SemanticRelation"> | number | null
    evidence?: StringNullableFilter<"SemanticRelation"> | string | null
    createdAt?: DateTimeFilter<"SemanticRelation"> | Date | string
    confidence?: FloatNullableFilter<"SemanticRelation"> | number | null
  }

  export type SemanticRelationUpsertWithWhereUniqueWithoutTargetNodeInput = {
    where: SemanticRelationWhereUniqueInput
    update: XOR<SemanticRelationUpdateWithoutTargetNodeInput, SemanticRelationUncheckedUpdateWithoutTargetNodeInput>
    create: XOR<SemanticRelationCreateWithoutTargetNodeInput, SemanticRelationUncheckedCreateWithoutTargetNodeInput>
  }

  export type SemanticRelationUpdateWithWhereUniqueWithoutTargetNodeInput = {
    where: SemanticRelationWhereUniqueInput
    data: XOR<SemanticRelationUpdateWithoutTargetNodeInput, SemanticRelationUncheckedUpdateWithoutTargetNodeInput>
  }

  export type SemanticRelationUpdateManyWithWhereWithoutTargetNodeInput = {
    where: SemanticRelationScalarWhereInput
    data: XOR<SemanticRelationUpdateManyMutationInput, SemanticRelationUncheckedUpdateManyWithoutTargetNodeInput>
  }

  export type ConsultationUpsertWithoutSemanticNodesInput = {
    update: XOR<ConsultationUpdateWithoutSemanticNodesInput, ConsultationUncheckedUpdateWithoutSemanticNodesInput>
    create: XOR<ConsultationCreateWithoutSemanticNodesInput, ConsultationUncheckedCreateWithoutSemanticNodesInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutSemanticNodesInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutSemanticNodesInput, ConsultationUncheckedUpdateWithoutSemanticNodesInput>
  }

  export type ConsultationUpdateWithoutSemanticNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutSemanticNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type SemanticNodeCreateWithoutSourceRelationsInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patient?: PatientCreateNestedOneWithoutSemanticNodesInput
    targetRelations?: SemanticRelationCreateNestedManyWithoutTargetNodeInput
    consultation?: ConsultationCreateNestedOneWithoutSemanticNodesInput
  }

  export type SemanticNodeUncheckedCreateWithoutSourceRelationsInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
    consultationId?: string | null
    targetRelations?: SemanticRelationUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type SemanticNodeCreateOrConnectWithoutSourceRelationsInput = {
    where: SemanticNodeWhereUniqueInput
    create: XOR<SemanticNodeCreateWithoutSourceRelationsInput, SemanticNodeUncheckedCreateWithoutSourceRelationsInput>
  }

  export type SemanticNodeCreateWithoutTargetRelationsInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patient?: PatientCreateNestedOneWithoutSemanticNodesInput
    sourceRelations?: SemanticRelationCreateNestedManyWithoutSourceNodeInput
    consultation?: ConsultationCreateNestedOneWithoutSemanticNodesInput
  }

  export type SemanticNodeUncheckedCreateWithoutTargetRelationsInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
    consultationId?: string | null
    sourceRelations?: SemanticRelationUncheckedCreateNestedManyWithoutSourceNodeInput
  }

  export type SemanticNodeCreateOrConnectWithoutTargetRelationsInput = {
    where: SemanticNodeWhereUniqueInput
    create: XOR<SemanticNodeCreateWithoutTargetRelationsInput, SemanticNodeUncheckedCreateWithoutTargetRelationsInput>
  }

  export type SemanticNodeUpsertWithoutSourceRelationsInput = {
    update: XOR<SemanticNodeUpdateWithoutSourceRelationsInput, SemanticNodeUncheckedUpdateWithoutSourceRelationsInput>
    create: XOR<SemanticNodeCreateWithoutSourceRelationsInput, SemanticNodeUncheckedCreateWithoutSourceRelationsInput>
    where?: SemanticNodeWhereInput
  }

  export type SemanticNodeUpdateToOneWithWhereWithoutSourceRelationsInput = {
    where?: SemanticNodeWhereInput
    data: XOR<SemanticNodeUpdateWithoutSourceRelationsInput, SemanticNodeUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type SemanticNodeUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patient?: PatientUpdateOneWithoutSemanticNodesNestedInput
    targetRelations?: SemanticRelationUpdateManyWithoutTargetNodeNestedInput
    consultation?: ConsultationUpdateOneWithoutSemanticNodesNestedInput
  }

  export type SemanticNodeUncheckedUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    targetRelations?: SemanticRelationUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type SemanticNodeUpsertWithoutTargetRelationsInput = {
    update: XOR<SemanticNodeUpdateWithoutTargetRelationsInput, SemanticNodeUncheckedUpdateWithoutTargetRelationsInput>
    create: XOR<SemanticNodeCreateWithoutTargetRelationsInput, SemanticNodeUncheckedCreateWithoutTargetRelationsInput>
    where?: SemanticNodeWhereInput
  }

  export type SemanticNodeUpdateToOneWithWhereWithoutTargetRelationsInput = {
    where?: SemanticNodeWhereInput
    data: XOR<SemanticNodeUpdateWithoutTargetRelationsInput, SemanticNodeUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type SemanticNodeUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patient?: PatientUpdateOneWithoutSemanticNodesNestedInput
    sourceRelations?: SemanticRelationUpdateManyWithoutSourceNodeNestedInput
    consultation?: ConsultationUpdateOneWithoutSemanticNodesNestedInput
  }

  export type SemanticNodeUncheckedUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceRelations?: SemanticRelationUncheckedUpdateManyWithoutSourceNodeNestedInput
  }

  export type PatientCreateWithoutConsultationsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsultationsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsultationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
  }

  export type SemanticNodeCreateWithoutConsultationInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patient?: PatientCreateNestedOneWithoutSemanticNodesInput
    sourceRelations?: SemanticRelationCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationCreateNestedManyWithoutTargetNodeInput
  }

  export type SemanticNodeUncheckedCreateWithoutConsultationInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
    sourceRelations?: SemanticRelationUncheckedCreateNestedManyWithoutSourceNodeInput
    targetRelations?: SemanticRelationUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type SemanticNodeCreateOrConnectWithoutConsultationInput = {
    where: SemanticNodeWhereUniqueInput
    create: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput>
  }

  export type SemanticNodeCreateManyConsultationInputEnvelope = {
    data: SemanticNodeCreateManyConsultationInput | SemanticNodeCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type MedicalDocumentCreateWithoutConsultationInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutConsultationInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutConsultationInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput>
  }

  export type MedicalDocumentCreateManyConsultationInputEnvelope = {
    data: MedicalDocumentCreateManyConsultationInput | MedicalDocumentCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type MedicalReportCreateWithoutConsultationInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalReportsInput
    document?: MedicalDocumentCreateNestedOneWithoutMedicalReportInput
  }

  export type MedicalReportUncheckedCreateWithoutConsultationInput = {
    id?: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type MedicalReportCreateOrConnectWithoutConsultationInput = {
    where: MedicalReportWhereUniqueInput
    create: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput>
  }

  export type MedicalReportCreateManyConsultationInputEnvelope = {
    data: MedicalReportCreateManyConsultationInput | MedicalReportCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutConsultationInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    reminders?: AppointmentReminderCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutConsultationInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    reminders?: AppointmentReminderUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutConsultationInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
  }

  export type BillingEventCreateWithoutConsultationInput = {
    id?: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
  }

  export type BillingEventUncheckedCreateWithoutConsultationInput = {
    id?: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
  }

  export type BillingEventCreateOrConnectWithoutConsultationInput = {
    where: BillingEventWhereUniqueInput
    create: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput>
  }

  export type BillingEventCreateManyConsultationInputEnvelope = {
    data: BillingEventCreateManyConsultationInput | BillingEventCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutConsultationsInput = {
    update: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type PatientUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type SemanticNodeUpsertWithWhereUniqueWithoutConsultationInput = {
    where: SemanticNodeWhereUniqueInput
    update: XOR<SemanticNodeUpdateWithoutConsultationInput, SemanticNodeUncheckedUpdateWithoutConsultationInput>
    create: XOR<SemanticNodeCreateWithoutConsultationInput, SemanticNodeUncheckedCreateWithoutConsultationInput>
  }

  export type SemanticNodeUpdateWithWhereUniqueWithoutConsultationInput = {
    where: SemanticNodeWhereUniqueInput
    data: XOR<SemanticNodeUpdateWithoutConsultationInput, SemanticNodeUncheckedUpdateWithoutConsultationInput>
  }

  export type SemanticNodeUpdateManyWithWhereWithoutConsultationInput = {
    where: SemanticNodeScalarWhereInput
    data: XOR<SemanticNodeUpdateManyMutationInput, SemanticNodeUncheckedUpdateManyWithoutConsultationInput>
  }

  export type MedicalDocumentUpsertWithWhereUniqueWithoutConsultationInput = {
    where: MedicalDocumentWhereUniqueInput
    update: XOR<MedicalDocumentUpdateWithoutConsultationInput, MedicalDocumentUncheckedUpdateWithoutConsultationInput>
    create: XOR<MedicalDocumentCreateWithoutConsultationInput, MedicalDocumentUncheckedCreateWithoutConsultationInput>
  }

  export type MedicalDocumentUpdateWithWhereUniqueWithoutConsultationInput = {
    where: MedicalDocumentWhereUniqueInput
    data: XOR<MedicalDocumentUpdateWithoutConsultationInput, MedicalDocumentUncheckedUpdateWithoutConsultationInput>
  }

  export type MedicalDocumentUpdateManyWithWhereWithoutConsultationInput = {
    where: MedicalDocumentScalarWhereInput
    data: XOR<MedicalDocumentUpdateManyMutationInput, MedicalDocumentUncheckedUpdateManyWithoutConsultationInput>
  }

  export type MedicalReportUpsertWithWhereUniqueWithoutConsultationInput = {
    where: MedicalReportWhereUniqueInput
    update: XOR<MedicalReportUpdateWithoutConsultationInput, MedicalReportUncheckedUpdateWithoutConsultationInput>
    create: XOR<MedicalReportCreateWithoutConsultationInput, MedicalReportUncheckedCreateWithoutConsultationInput>
  }

  export type MedicalReportUpdateWithWhereUniqueWithoutConsultationInput = {
    where: MedicalReportWhereUniqueInput
    data: XOR<MedicalReportUpdateWithoutConsultationInput, MedicalReportUncheckedUpdateWithoutConsultationInput>
  }

  export type MedicalReportUpdateManyWithWhereWithoutConsultationInput = {
    where: MedicalReportScalarWhereInput
    data: XOR<MedicalReportUpdateManyMutationInput, MedicalReportUncheckedUpdateManyWithoutConsultationInput>
  }

  export type AppointmentUpsertWithoutConsultationInput = {
    update: XOR<AppointmentUpdateWithoutConsultationInput, AppointmentUncheckedUpdateWithoutConsultationInput>
    create: XOR<AppointmentCreateWithoutConsultationInput, AppointmentUncheckedCreateWithoutConsultationInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutConsultationInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutConsultationInput, AppointmentUncheckedUpdateWithoutConsultationInput>
  }

  export type AppointmentUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    reminders?: AppointmentReminderUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: AppointmentReminderUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type BillingEventUpsertWithWhereUniqueWithoutConsultationInput = {
    where: BillingEventWhereUniqueInput
    update: XOR<BillingEventUpdateWithoutConsultationInput, BillingEventUncheckedUpdateWithoutConsultationInput>
    create: XOR<BillingEventCreateWithoutConsultationInput, BillingEventUncheckedCreateWithoutConsultationInput>
  }

  export type BillingEventUpdateWithWhereUniqueWithoutConsultationInput = {
    where: BillingEventWhereUniqueInput
    data: XOR<BillingEventUpdateWithoutConsultationInput, BillingEventUncheckedUpdateWithoutConsultationInput>
  }

  export type BillingEventUpdateManyWithWhereWithoutConsultationInput = {
    where: BillingEventScalarWhereInput
    data: XOR<BillingEventUpdateManyMutationInput, BillingEventUncheckedUpdateManyWithoutConsultationInput>
  }

  export type BillingEventScalarWhereInput = {
    AND?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[]
    OR?: BillingEventScalarWhereInput[]
    NOT?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[]
    id?: StringFilter<"BillingEvent"> | string
    consultationId?: StringFilter<"BillingEvent"> | string
    ghmCode?: StringNullableFilter<"BillingEvent"> | string | null
    actCode?: StringNullableFilter<"BillingEvent"> | string | null
    actType?: StringFilter<"BillingEvent"> | string
    status?: StringFilter<"BillingEvent"> | string
    evidenceNodeIds?: StringNullableListFilter<"BillingEvent">
    createdAt?: DateTimeFilter<"BillingEvent"> | Date | string
    transmittedAt?: DateTimeNullableFilter<"BillingEvent"> | Date | string | null
  }

  export type ConsultationCreateWithoutBillingEventsInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutBillingEventsInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutBillingEventsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutBillingEventsInput, ConsultationUncheckedCreateWithoutBillingEventsInput>
  }

  export type ConsultationUpsertWithoutBillingEventsInput = {
    update: XOR<ConsultationUpdateWithoutBillingEventsInput, ConsultationUncheckedUpdateWithoutBillingEventsInput>
    create: XOR<ConsultationCreateWithoutBillingEventsInput, ConsultationUncheckedCreateWithoutBillingEventsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutBillingEventsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutBillingEventsInput, ConsultationUncheckedUpdateWithoutBillingEventsInput>
  }

  export type ConsultationUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type PatientCreateWithoutAllergiesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAllergiesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAllergiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
  }

  export type PatientUpsertWithoutAllergiesInput = {
    update: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutMedicalDocumentsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalDocumentsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalDocumentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalDocumentsInput, PatientUncheckedCreateWithoutMedicalDocumentsInput>
  }

  export type ConsultationCreateWithoutMedicalDocumentsInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutMedicalDocumentsInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutMedicalDocumentsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutMedicalDocumentsInput, ConsultationUncheckedCreateWithoutMedicalDocumentsInput>
  }

  export type PrescriptionCreateWithoutDocumentInput = {
    id?: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    createdAt?: Date | string
    prescribedBy: string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutDocumentInput = {
    id?: string
    patientId: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    createdAt?: Date | string
    prescribedBy: string
  }

  export type PrescriptionCreateOrConnectWithoutDocumentInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
  }

  export type MedicalReportCreateWithoutDocumentInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalReportsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalReportsInput
  }

  export type MedicalReportUncheckedCreateWithoutDocumentInput = {
    id?: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    consultationId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type MedicalReportCreateOrConnectWithoutDocumentInput = {
    where: MedicalReportWhereUniqueInput
    create: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
  }

  export type LaboratoryResultCreateWithoutDocumentInput = {
    id?: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    patient: PatientCreateNestedOneWithoutLaboratoryResultsInput
  }

  export type LaboratoryResultUncheckedCreateWithoutDocumentInput = {
    id?: string
    patientId: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
  }

  export type LaboratoryResultCreateOrConnectWithoutDocumentInput = {
    where: LaboratoryResultWhereUniqueInput
    create: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
  }

  export type MedicalImageCreateWithoutDocumentInput = {
    id?: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    acquisitionDate: Date | string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutMedicalImagesInput
  }

  export type MedicalImageUncheckedCreateWithoutDocumentInput = {
    id?: string
    patientId: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    acquisitionDate: Date | string
    createdAt?: Date | string
  }

  export type MedicalImageCreateOrConnectWithoutDocumentInput = {
    where: MedicalImageWhereUniqueInput
    create: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAttachmentCreateWithoutDocumentInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentAttachmentUncheckedCreateWithoutDocumentInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentAttachmentCreateOrConnectWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    create: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAttachmentCreateManyDocumentInputEnvelope = {
    data: DocumentAttachmentCreateManyDocumentInput | DocumentAttachmentCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutMedicalDocumentsInput = {
    update: XOR<PatientUpdateWithoutMedicalDocumentsInput, PatientUncheckedUpdateWithoutMedicalDocumentsInput>
    create: XOR<PatientCreateWithoutMedicalDocumentsInput, PatientUncheckedCreateWithoutMedicalDocumentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalDocumentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalDocumentsInput, PatientUncheckedUpdateWithoutMedicalDocumentsInput>
  }

  export type PatientUpdateWithoutMedicalDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsultationUpsertWithoutMedicalDocumentsInput = {
    update: XOR<ConsultationUpdateWithoutMedicalDocumentsInput, ConsultationUncheckedUpdateWithoutMedicalDocumentsInput>
    create: XOR<ConsultationCreateWithoutMedicalDocumentsInput, ConsultationUncheckedCreateWithoutMedicalDocumentsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutMedicalDocumentsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutMedicalDocumentsInput, ConsultationUncheckedUpdateWithoutMedicalDocumentsInput>
  }

  export type ConsultationUpdateWithoutMedicalDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutMedicalDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type PrescriptionUpsertWithoutDocumentInput = {
    update: XOR<PrescriptionUpdateWithoutDocumentInput, PrescriptionUncheckedUpdateWithoutDocumentInput>
    create: XOR<PrescriptionCreateWithoutDocumentInput, PrescriptionUncheckedCreateWithoutDocumentInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutDocumentInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutDocumentInput, PrescriptionUncheckedUpdateWithoutDocumentInput>
  }

  export type PrescriptionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUpsertWithoutDocumentInput = {
    update: XOR<MedicalReportUpdateWithoutDocumentInput, MedicalReportUncheckedUpdateWithoutDocumentInput>
    create: XOR<MedicalReportCreateWithoutDocumentInput, MedicalReportUncheckedCreateWithoutDocumentInput>
    where?: MedicalReportWhereInput
  }

  export type MedicalReportUpdateToOneWithWhereWithoutDocumentInput = {
    where?: MedicalReportWhereInput
    data: XOR<MedicalReportUpdateWithoutDocumentInput, MedicalReportUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalReportUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalReportsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalReportsNestedInput
  }

  export type MedicalReportUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryResultUpsertWithoutDocumentInput = {
    update: XOR<LaboratoryResultUpdateWithoutDocumentInput, LaboratoryResultUncheckedUpdateWithoutDocumentInput>
    create: XOR<LaboratoryResultCreateWithoutDocumentInput, LaboratoryResultUncheckedCreateWithoutDocumentInput>
    where?: LaboratoryResultWhereInput
  }

  export type LaboratoryResultUpdateToOneWithWhereWithoutDocumentInput = {
    where?: LaboratoryResultWhereInput
    data: XOR<LaboratoryResultUpdateWithoutDocumentInput, LaboratoryResultUncheckedUpdateWithoutDocumentInput>
  }

  export type LaboratoryResultUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutLaboratoryResultsNestedInput
  }

  export type LaboratoryResultUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalImageUpsertWithoutDocumentInput = {
    update: XOR<MedicalImageUpdateWithoutDocumentInput, MedicalImageUncheckedUpdateWithoutDocumentInput>
    create: XOR<MedicalImageCreateWithoutDocumentInput, MedicalImageUncheckedCreateWithoutDocumentInput>
    where?: MedicalImageWhereInput
  }

  export type MedicalImageUpdateToOneWithWhereWithoutDocumentInput = {
    where?: MedicalImageWhereInput
    data: XOR<MedicalImageUpdateWithoutDocumentInput, MedicalImageUncheckedUpdateWithoutDocumentInput>
  }

  export type MedicalImageUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicalImagesNestedInput
  }

  export type MedicalImageUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    update: XOR<DocumentAttachmentUpdateWithoutDocumentInput, DocumentAttachmentUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    data: XOR<DocumentAttachmentUpdateWithoutDocumentInput, DocumentAttachmentUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentAttachmentScalarWhereInput
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentAttachmentScalarWhereInput = {
    AND?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    OR?: DocumentAttachmentScalarWhereInput[]
    NOT?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    id?: StringFilter<"DocumentAttachment"> | string
    documentId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    mimeType?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    uploadedBy?: StringFilter<"DocumentAttachment"> | string
  }

  export type MedicalDocumentCreateWithoutAttachmentsInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutAttachmentsInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutAttachmentsInput, MedicalDocumentUncheckedCreateWithoutAttachmentsInput>
  }

  export type MedicalDocumentUpsertWithoutAttachmentsInput = {
    update: XOR<MedicalDocumentUpdateWithoutAttachmentsInput, MedicalDocumentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MedicalDocumentCreateWithoutAttachmentsInput, MedicalDocumentUncheckedCreateWithoutAttachmentsInput>
    where?: MedicalDocumentWhereInput
  }

  export type MedicalDocumentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MedicalDocumentWhereInput
    data: XOR<MedicalDocumentUpdateWithoutAttachmentsInput, MedicalDocumentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MedicalDocumentUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type MedicalDocumentCreateWithoutPrescriptionInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutPrescriptionInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutPrescriptionInput, MedicalDocumentUncheckedCreateWithoutPrescriptionInput>
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicalDocumentUpsertWithoutPrescriptionInput = {
    update: XOR<MedicalDocumentUpdateWithoutPrescriptionInput, MedicalDocumentUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<MedicalDocumentCreateWithoutPrescriptionInput, MedicalDocumentUncheckedCreateWithoutPrescriptionInput>
    where?: MedicalDocumentWhereInput
  }

  export type MedicalDocumentUpdateToOneWithWhereWithoutPrescriptionInput = {
    where?: MedicalDocumentWhereInput
    data: XOR<MedicalDocumentUpdateWithoutPrescriptionInput, MedicalDocumentUncheckedUpdateWithoutPrescriptionInput>
  }

  export type MedicalDocumentUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type PatientCreateWithoutMedicalReportsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalReportsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalReportsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalReportsInput, PatientUncheckedCreateWithoutMedicalReportsInput>
  }

  export type MedicalDocumentCreateWithoutMedicalReportInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutMedicalReportInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutMedicalReportInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutMedicalReportInput, MedicalDocumentUncheckedCreateWithoutMedicalReportInput>
  }

  export type ConsultationCreateWithoutMedicalReportsInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutMedicalReportsInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    appointment?: AppointmentUncheckedCreateNestedOneWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutMedicalReportsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutMedicalReportsInput, ConsultationUncheckedCreateWithoutMedicalReportsInput>
  }

  export type PatientUpsertWithoutMedicalReportsInput = {
    update: XOR<PatientUpdateWithoutMedicalReportsInput, PatientUncheckedUpdateWithoutMedicalReportsInput>
    create: XOR<PatientCreateWithoutMedicalReportsInput, PatientUncheckedCreateWithoutMedicalReportsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalReportsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalReportsInput, PatientUncheckedUpdateWithoutMedicalReportsInput>
  }

  export type PatientUpdateWithoutMedicalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicalDocumentUpsertWithoutMedicalReportInput = {
    update: XOR<MedicalDocumentUpdateWithoutMedicalReportInput, MedicalDocumentUncheckedUpdateWithoutMedicalReportInput>
    create: XOR<MedicalDocumentCreateWithoutMedicalReportInput, MedicalDocumentUncheckedCreateWithoutMedicalReportInput>
    where?: MedicalDocumentWhereInput
  }

  export type MedicalDocumentUpdateToOneWithWhereWithoutMedicalReportInput = {
    where?: MedicalDocumentWhereInput
    data: XOR<MedicalDocumentUpdateWithoutMedicalReportInput, MedicalDocumentUncheckedUpdateWithoutMedicalReportInput>
  }

  export type MedicalDocumentUpdateWithoutMedicalReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutMedicalReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type ConsultationUpsertWithoutMedicalReportsInput = {
    update: XOR<ConsultationUpdateWithoutMedicalReportsInput, ConsultationUncheckedUpdateWithoutMedicalReportsInput>
    create: XOR<ConsultationCreateWithoutMedicalReportsInput, ConsultationUncheckedCreateWithoutMedicalReportsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutMedicalReportsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutMedicalReportsInput, ConsultationUncheckedUpdateWithoutMedicalReportsInput>
  }

  export type ConsultationUpdateWithoutMedicalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutMedicalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type PatientCreateWithoutLaboratoryResultsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLaboratoryResultsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLaboratoryResultsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLaboratoryResultsInput, PatientUncheckedCreateWithoutLaboratoryResultsInput>
  }

  export type MedicalDocumentCreateWithoutLaboratoryResultInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutLaboratoryResultInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    medicalImage?: MedicalImageUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutLaboratoryResultInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutLaboratoryResultInput, MedicalDocumentUncheckedCreateWithoutLaboratoryResultInput>
  }

  export type PatientUpsertWithoutLaboratoryResultsInput = {
    update: XOR<PatientUpdateWithoutLaboratoryResultsInput, PatientUncheckedUpdateWithoutLaboratoryResultsInput>
    create: XOR<PatientCreateWithoutLaboratoryResultsInput, PatientUncheckedCreateWithoutLaboratoryResultsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLaboratoryResultsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLaboratoryResultsInput, PatientUncheckedUpdateWithoutLaboratoryResultsInput>
  }

  export type PatientUpdateWithoutLaboratoryResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLaboratoryResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicalDocumentUpsertWithoutLaboratoryResultInput = {
    update: XOR<MedicalDocumentUpdateWithoutLaboratoryResultInput, MedicalDocumentUncheckedUpdateWithoutLaboratoryResultInput>
    create: XOR<MedicalDocumentCreateWithoutLaboratoryResultInput, MedicalDocumentUncheckedCreateWithoutLaboratoryResultInput>
    where?: MedicalDocumentWhereInput
  }

  export type MedicalDocumentUpdateToOneWithWhereWithoutLaboratoryResultInput = {
    where?: MedicalDocumentWhereInput
    data: XOR<MedicalDocumentUpdateWithoutLaboratoryResultInput, MedicalDocumentUncheckedUpdateWithoutLaboratoryResultInput>
  }

  export type MedicalDocumentUpdateWithoutLaboratoryResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutLaboratoryResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type PatientCreateWithoutMedicalImagesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalImagesInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalImagesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalImagesInput, PatientUncheckedCreateWithoutMedicalImagesInput>
  }

  export type MedicalDocumentCreateWithoutMedicalImageInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    patient: PatientCreateNestedOneWithoutMedicalDocumentsInput
    consultation?: ConsultationCreateNestedOneWithoutMedicalDocumentsInput
    prescription?: PrescriptionCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentUncheckedCreateWithoutMedicalImageInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutDocumentInput
    medicalReport?: MedicalReportUncheckedCreateNestedOneWithoutDocumentInput
    laboratoryResult?: LaboratoryResultUncheckedCreateNestedOneWithoutDocumentInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type MedicalDocumentCreateOrConnectWithoutMedicalImageInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutMedicalImageInput, MedicalDocumentUncheckedCreateWithoutMedicalImageInput>
  }

  export type PatientUpsertWithoutMedicalImagesInput = {
    update: XOR<PatientUpdateWithoutMedicalImagesInput, PatientUncheckedUpdateWithoutMedicalImagesInput>
    create: XOR<PatientCreateWithoutMedicalImagesInput, PatientUncheckedCreateWithoutMedicalImagesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalImagesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalImagesInput, PatientUncheckedUpdateWithoutMedicalImagesInput>
  }

  export type PatientUpdateWithoutMedicalImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicalDocumentUpsertWithoutMedicalImageInput = {
    update: XOR<MedicalDocumentUpdateWithoutMedicalImageInput, MedicalDocumentUncheckedUpdateWithoutMedicalImageInput>
    create: XOR<MedicalDocumentCreateWithoutMedicalImageInput, MedicalDocumentUncheckedCreateWithoutMedicalImageInput>
    where?: MedicalDocumentWhereInput
  }

  export type MedicalDocumentUpdateToOneWithWhereWithoutMedicalImageInput = {
    where?: MedicalDocumentWhereInput
    data: XOR<MedicalDocumentUpdateWithoutMedicalImageInput, MedicalDocumentUncheckedUpdateWithoutMedicalImageInput>
  }

  export type MedicalDocumentUpdateWithoutMedicalImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutMedicalImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageCreateNestedManyWithoutPatientInput
    allergies?: AllergyCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    insToken: string
    insHash: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutPatientInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutPatientInput
    laboratoryResults?: LaboratoryResultUncheckedCreateNestedManyWithoutPatientInput
    medicalImages?: MedicalImageUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type ConsultationCreateWithoutAppointmentInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    semanticNodes?: SemanticNodeCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportCreateNestedManyWithoutConsultationInput
    billingEvents?: BillingEventCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutAppointmentInput = {
    id?: string
    patientId: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
    semanticNodes?: SemanticNodeUncheckedCreateNestedManyWithoutConsultationInput
    medicalDocuments?: MedicalDocumentUncheckedCreateNestedManyWithoutConsultationInput
    medicalReports?: MedicalReportUncheckedCreateNestedManyWithoutConsultationInput
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutAppointmentInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutAppointmentInput, ConsultationUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentReminderCreateWithoutAppointmentInput = {
    id?: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentReminderUncheckedCreateWithoutAppointmentInput = {
    id?: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentReminderCreateOrConnectWithoutAppointmentInput = {
    where: AppointmentReminderWhereUniqueInput
    create: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentReminderCreateManyAppointmentInputEnvelope = {
    data: AppointmentReminderCreateManyAppointmentInput | AppointmentReminderCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insToken?: StringFieldUpdateOperationsInput | string
    insHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutPatientNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutPatientNestedInput
    laboratoryResults?: LaboratoryResultUncheckedUpdateManyWithoutPatientNestedInput
    medicalImages?: MedicalImageUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsultationUpsertWithoutAppointmentInput = {
    update: XOR<ConsultationUpdateWithoutAppointmentInput, ConsultationUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ConsultationCreateWithoutAppointmentInput, ConsultationUncheckedCreateWithoutAppointmentInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutAppointmentInput, ConsultationUncheckedUpdateWithoutAppointmentInput>
  }

  export type ConsultationUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type AppointmentReminderUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentReminderWhereUniqueInput
    update: XOR<AppointmentReminderUpdateWithoutAppointmentInput, AppointmentReminderUncheckedUpdateWithoutAppointmentInput>
    create: XOR<AppointmentReminderCreateWithoutAppointmentInput, AppointmentReminderUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentReminderUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentReminderWhereUniqueInput
    data: XOR<AppointmentReminderUpdateWithoutAppointmentInput, AppointmentReminderUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentReminderUpdateManyWithWhereWithoutAppointmentInput = {
    where: AppointmentReminderScalarWhereInput
    data: XOR<AppointmentReminderUpdateManyMutationInput, AppointmentReminderUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentReminderScalarWhereInput = {
    AND?: AppointmentReminderScalarWhereInput | AppointmentReminderScalarWhereInput[]
    OR?: AppointmentReminderScalarWhereInput[]
    NOT?: AppointmentReminderScalarWhereInput | AppointmentReminderScalarWhereInput[]
    id?: StringFilter<"AppointmentReminder"> | string
    appointmentId?: StringFilter<"AppointmentReminder"> | string
    reminderType?: StringFilter<"AppointmentReminder"> | string
    reminderTime?: DateTimeFilter<"AppointmentReminder"> | Date | string
    status?: StringFilter<"AppointmentReminder"> | string
    sentAt?: DateTimeNullableFilter<"AppointmentReminder"> | Date | string | null
    createdAt?: DateTimeFilter<"AppointmentReminder"> | Date | string
  }

  export type AppointmentCreateWithoutRemindersInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    consultation?: ConsultationCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutRemindersInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    consultationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
  }

  export type AppointmentCreateOrConnectWithoutRemindersInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutRemindersInput, AppointmentUncheckedCreateWithoutRemindersInput>
  }

  export type AppointmentUpsertWithoutRemindersInput = {
    update: XOR<AppointmentUpdateWithoutRemindersInput, AppointmentUncheckedUpdateWithoutRemindersInput>
    create: XOR<AppointmentCreateWithoutRemindersInput, AppointmentUncheckedCreateWithoutRemindersInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutRemindersInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutRemindersInput, AppointmentUncheckedUpdateWithoutRemindersInput>
  }

  export type AppointmentUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    consultation?: ConsultationUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageThreadCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    threadType?: string
    description?: string | null
    participantIds?: MessageThreadCreateparticipantIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    createdBy: string
  }

  export type MessageThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    threadType?: string
    description?: string | null
    participantIds?: MessageThreadCreateparticipantIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string | null
    createdBy: string
  }

  export type MessageThreadCreateOrConnectWithoutMessagesInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadUpsertWithoutMessagesInput = {
    update: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MessageThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threadType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participantIds?: MessageThreadUpdateparticipantIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    fileName?: StringFilter<"MessageAttachment"> | string
    filePath?: StringFilter<"MessageAttachment"> | string
    mimeType?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    uploadedAt?: DateTimeFilter<"MessageAttachment"> | Date | string
  }

  export type InternalMessageCreateWithoutThreadInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type InternalMessageUncheckedCreateWithoutThreadInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InternalMessageCreateOrConnectWithoutThreadInput = {
    where: InternalMessageWhereUniqueInput
    create: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput>
  }

  export type InternalMessageCreateManyThreadInputEnvelope = {
    data: InternalMessageCreateManyThreadInput | InternalMessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type InternalMessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: InternalMessageWhereUniqueInput
    update: XOR<InternalMessageUpdateWithoutThreadInput, InternalMessageUncheckedUpdateWithoutThreadInput>
    create: XOR<InternalMessageCreateWithoutThreadInput, InternalMessageUncheckedCreateWithoutThreadInput>
  }

  export type InternalMessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: InternalMessageWhereUniqueInput
    data: XOR<InternalMessageUpdateWithoutThreadInput, InternalMessageUncheckedUpdateWithoutThreadInput>
  }

  export type InternalMessageUpdateManyWithWhereWithoutThreadInput = {
    where: InternalMessageScalarWhereInput
    data: XOR<InternalMessageUpdateManyMutationInput, InternalMessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type InternalMessageScalarWhereInput = {
    AND?: InternalMessageScalarWhereInput | InternalMessageScalarWhereInput[]
    OR?: InternalMessageScalarWhereInput[]
    NOT?: InternalMessageScalarWhereInput | InternalMessageScalarWhereInput[]
    id?: StringFilter<"InternalMessage"> | string
    senderId?: StringFilter<"InternalMessage"> | string
    recipientId?: StringNullableFilter<"InternalMessage"> | string | null
    threadId?: StringNullableFilter<"InternalMessage"> | string | null
    subject?: StringNullableFilter<"InternalMessage"> | string | null
    content?: StringFilter<"InternalMessage"> | string
    messageType?: StringFilter<"InternalMessage"> | string
    status?: StringFilter<"InternalMessage"> | string
    createdAt?: DateTimeFilter<"InternalMessage"> | Date | string
    readAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
    archivedAt?: DateTimeNullableFilter<"InternalMessage"> | Date | string | null
  }

  export type InternalMessageCreateWithoutAttachmentsInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
    thread?: MessageThreadCreateNestedOneWithoutMessagesInput
  }

  export type InternalMessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    threadId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type InternalMessageCreateOrConnectWithoutAttachmentsInput = {
    where: InternalMessageWhereUniqueInput
    create: XOR<InternalMessageCreateWithoutAttachmentsInput, InternalMessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type InternalMessageUpsertWithoutAttachmentsInput = {
    update: XOR<InternalMessageUpdateWithoutAttachmentsInput, InternalMessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<InternalMessageCreateWithoutAttachmentsInput, InternalMessageUncheckedCreateWithoutAttachmentsInput>
    where?: InternalMessageWhereInput
  }

  export type InternalMessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: InternalMessageWhereInput
    data: XOR<InternalMessageUpdateWithoutAttachmentsInput, InternalMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InternalMessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: MessageThreadUpdateOneWithoutMessagesNestedInput
  }

  export type InternalMessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
  }

  export type ShiftUncheckedCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
  }

  export type ShiftCreateOrConnectWithoutStaffMemberInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput>
  }

  export type ShiftCreateManyStaffMemberInputEnvelope = {
    data: ShiftCreateManyStaffMemberInput | ShiftCreateManyStaffMemberInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type LeaveUncheckedCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type LeaveCreateOrConnectWithoutStaffMemberInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput>
  }

  export type LeaveCreateManyStaffMemberInputEnvelope = {
    data: LeaveCreateManyStaffMemberInput | LeaveCreateManyStaffMemberInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ScheduleUncheckedCreateWithoutStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ScheduleCreateOrConnectWithoutStaffMemberInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput>
  }

  export type ScheduleCreateManyStaffMemberInputEnvelope = {
    data: ScheduleCreateManyStaffMemberInput | ScheduleCreateManyStaffMemberInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUpsertWithWhereUniqueWithoutStaffMemberInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutStaffMemberInput, ShiftUncheckedUpdateWithoutStaffMemberInput>
    create: XOR<ShiftCreateWithoutStaffMemberInput, ShiftUncheckedCreateWithoutStaffMemberInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutStaffMemberInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutStaffMemberInput, ShiftUncheckedUpdateWithoutStaffMemberInput>
  }

  export type ShiftUpdateManyWithWhereWithoutStaffMemberInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutStaffMemberInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    staffMemberId?: StringFilter<"Shift"> | string
    startDate?: DateTimeFilter<"Shift"> | Date | string
    endDate?: DateTimeFilter<"Shift"> | Date | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    shiftType?: StringFilter<"Shift"> | string
    location?: StringNullableFilter<"Shift"> | string | null
    status?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    createdBy?: StringFilter<"Shift"> | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutStaffMemberInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutStaffMemberInput, LeaveUncheckedUpdateWithoutStaffMemberInput>
    create: XOR<LeaveCreateWithoutStaffMemberInput, LeaveUncheckedCreateWithoutStaffMemberInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutStaffMemberInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutStaffMemberInput, LeaveUncheckedUpdateWithoutStaffMemberInput>
  }

  export type LeaveUpdateManyWithWhereWithoutStaffMemberInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutStaffMemberInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: StringFilter<"Leave"> | string
    staffMemberId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: StringFilter<"Leave"> | string
    reason?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    requestedBy?: StringFilter<"Leave"> | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
  }

  export type ScheduleUpsertWithWhereUniqueWithoutStaffMemberInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutStaffMemberInput, ScheduleUncheckedUpdateWithoutStaffMemberInput>
    create: XOR<ScheduleCreateWithoutStaffMemberInput, ScheduleUncheckedCreateWithoutStaffMemberInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutStaffMemberInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutStaffMemberInput, ScheduleUncheckedUpdateWithoutStaffMemberInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutStaffMemberInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutStaffMemberInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    staffMemberId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    scheduleData?: JsonFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
  }

  export type StaffMemberCreateWithoutShiftsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberUncheckedCreateWithoutShiftsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberCreateOrConnectWithoutShiftsInput = {
    where: StaffMemberWhereUniqueInput
    create: XOR<StaffMemberCreateWithoutShiftsInput, StaffMemberUncheckedCreateWithoutShiftsInput>
  }

  export type StaffMemberUpsertWithoutShiftsInput = {
    update: XOR<StaffMemberUpdateWithoutShiftsInput, StaffMemberUncheckedUpdateWithoutShiftsInput>
    create: XOR<StaffMemberCreateWithoutShiftsInput, StaffMemberUncheckedCreateWithoutShiftsInput>
    where?: StaffMemberWhereInput
  }

  export type StaffMemberUpdateToOneWithWhereWithoutShiftsInput = {
    where?: StaffMemberWhereInput
    data: XOR<StaffMemberUpdateWithoutShiftsInput, StaffMemberUncheckedUpdateWithoutShiftsInput>
  }

  export type StaffMemberUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberCreateWithoutLeavesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberUncheckedCreateWithoutLeavesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutStaffMemberInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberCreateOrConnectWithoutLeavesInput = {
    where: StaffMemberWhereUniqueInput
    create: XOR<StaffMemberCreateWithoutLeavesInput, StaffMemberUncheckedCreateWithoutLeavesInput>
  }

  export type StaffMemberUpsertWithoutLeavesInput = {
    update: XOR<StaffMemberUpdateWithoutLeavesInput, StaffMemberUncheckedUpdateWithoutLeavesInput>
    create: XOR<StaffMemberCreateWithoutLeavesInput, StaffMemberUncheckedCreateWithoutLeavesInput>
    where?: StaffMemberWhereInput
  }

  export type StaffMemberUpdateToOneWithWhereWithoutLeavesInput = {
    where?: StaffMemberWhereInput
    data: XOR<StaffMemberUpdateWithoutLeavesInput, StaffMemberUncheckedUpdateWithoutLeavesInput>
  }

  export type StaffMemberUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutStaffMemberNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberCreateWithoutSchedulesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutStaffMemberInput
    leaves?: LeaveCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberUncheckedCreateWithoutSchedulesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    speciality?: string | null
    qualifications?: StaffMemberCreatequalificationsInput | string[]
    status?: string
    hiredDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutStaffMemberInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutStaffMemberInput
  }

  export type StaffMemberCreateOrConnectWithoutSchedulesInput = {
    where: StaffMemberWhereUniqueInput
    create: XOR<StaffMemberCreateWithoutSchedulesInput, StaffMemberUncheckedCreateWithoutSchedulesInput>
  }

  export type StaffMemberUpsertWithoutSchedulesInput = {
    update: XOR<StaffMemberUpdateWithoutSchedulesInput, StaffMemberUncheckedUpdateWithoutSchedulesInput>
    create: XOR<StaffMemberCreateWithoutSchedulesInput, StaffMemberUncheckedCreateWithoutSchedulesInput>
    where?: StaffMemberWhereInput
  }

  export type StaffMemberUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: StaffMemberWhereInput
    data: XOR<StaffMemberUpdateWithoutSchedulesInput, StaffMemberUncheckedUpdateWithoutSchedulesInput>
  }

  export type StaffMemberUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutStaffMemberNestedInput
    leaves?: LeaveUpdateManyWithoutStaffMemberNestedInput
  }

  export type StaffMemberUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: StaffMemberUpdatequalificationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    hiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutStaffMemberNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutStaffMemberNestedInput
  }

  export type StockMovementCreateWithoutStockItemInput = {
    id?: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type StockMovementUncheckedCreateWithoutStockItemInput = {
    id?: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type StockMovementCreateOrConnectWithoutStockItemInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput>
  }

  export type StockMovementCreateManyStockItemInputEnvelope = {
    data: StockMovementCreateManyStockItemInput | StockMovementCreateManyStockItemInput[]
    skipDuplicates?: boolean
  }

  export type StockAlertCreateWithoutStockItemInput = {
    id?: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
  }

  export type StockAlertUncheckedCreateWithoutStockItemInput = {
    id?: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
  }

  export type StockAlertCreateOrConnectWithoutStockItemInput = {
    where: StockAlertWhereUniqueInput
    create: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput>
  }

  export type StockAlertCreateManyStockItemInputEnvelope = {
    data: StockAlertCreateManyStockItemInput | StockAlertCreateManyStockItemInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementUpsertWithWhereUniqueWithoutStockItemInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutStockItemInput, StockMovementUncheckedUpdateWithoutStockItemInput>
    create: XOR<StockMovementCreateWithoutStockItemInput, StockMovementUncheckedCreateWithoutStockItemInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutStockItemInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutStockItemInput, StockMovementUncheckedUpdateWithoutStockItemInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutStockItemInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutStockItemInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    stockItemId?: StringFilter<"StockMovement"> | string
    movementType?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reference?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    createdBy?: StringFilter<"StockMovement"> | string
  }

  export type StockAlertUpsertWithWhereUniqueWithoutStockItemInput = {
    where: StockAlertWhereUniqueInput
    update: XOR<StockAlertUpdateWithoutStockItemInput, StockAlertUncheckedUpdateWithoutStockItemInput>
    create: XOR<StockAlertCreateWithoutStockItemInput, StockAlertUncheckedCreateWithoutStockItemInput>
  }

  export type StockAlertUpdateWithWhereUniqueWithoutStockItemInput = {
    where: StockAlertWhereUniqueInput
    data: XOR<StockAlertUpdateWithoutStockItemInput, StockAlertUncheckedUpdateWithoutStockItemInput>
  }

  export type StockAlertUpdateManyWithWhereWithoutStockItemInput = {
    where: StockAlertScalarWhereInput
    data: XOR<StockAlertUpdateManyMutationInput, StockAlertUncheckedUpdateManyWithoutStockItemInput>
  }

  export type StockAlertScalarWhereInput = {
    AND?: StockAlertScalarWhereInput | StockAlertScalarWhereInput[]
    OR?: StockAlertScalarWhereInput[]
    NOT?: StockAlertScalarWhereInput | StockAlertScalarWhereInput[]
    id?: StringFilter<"StockAlert"> | string
    stockItemId?: StringFilter<"StockAlert"> | string
    alertType?: StringFilter<"StockAlert"> | string
    severity?: StringFilter<"StockAlert"> | string
    message?: StringFilter<"StockAlert"> | string
    status?: StringFilter<"StockAlert"> | string
    createdAt?: DateTimeFilter<"StockAlert"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"StockAlert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"StockAlert"> | string | null
  }

  export type StockItemCreateWithoutMovementsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: StockAlertCreateNestedManyWithoutStockItemInput
  }

  export type StockItemUncheckedCreateWithoutMovementsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: StockAlertUncheckedCreateNestedManyWithoutStockItemInput
  }

  export type StockItemCreateOrConnectWithoutMovementsInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutMovementsInput, StockItemUncheckedCreateWithoutMovementsInput>
  }

  export type StockItemUpsertWithoutMovementsInput = {
    update: XOR<StockItemUpdateWithoutMovementsInput, StockItemUncheckedUpdateWithoutMovementsInput>
    create: XOR<StockItemCreateWithoutMovementsInput, StockItemUncheckedCreateWithoutMovementsInput>
    where?: StockItemWhereInput
  }

  export type StockItemUpdateToOneWithWhereWithoutMovementsInput = {
    where?: StockItemWhereInput
    data: XOR<StockItemUpdateWithoutMovementsInput, StockItemUncheckedUpdateWithoutMovementsInput>
  }

  export type StockItemUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: StockAlertUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: StockAlertUncheckedUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemCreateWithoutAlertsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: StockMovementCreateNestedManyWithoutStockItemInput
  }

  export type StockItemUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category: string
    subCategory?: string | null
    currentQuantity?: number
    minQuantity?: number
    maxQuantity?: number | null
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: StockMovementUncheckedCreateNestedManyWithoutStockItemInput
  }

  export type StockItemCreateOrConnectWithoutAlertsInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutAlertsInput, StockItemUncheckedCreateWithoutAlertsInput>
  }

  export type StockItemUpsertWithoutAlertsInput = {
    update: XOR<StockItemUpdateWithoutAlertsInput, StockItemUncheckedUpdateWithoutAlertsInput>
    create: XOR<StockItemCreateWithoutAlertsInput, StockItemUncheckedCreateWithoutAlertsInput>
    where?: StockItemWhereInput
  }

  export type StockItemUpdateToOneWithWhereWithoutAlertsInput = {
    where?: StockItemWhereInput
    data: XOR<StockItemUpdateWithoutAlertsInput, StockItemUncheckedUpdateWithoutAlertsInput>
  }

  export type StockItemUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: StockMovementUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: StockMovementUncheckedUpdateManyWithoutStockItemNestedInput
  }

  export type ConsultationCreateManyPatientInput = {
    id?: string
    consultationDate?: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    status?: string
    rawTranscript?: string | null
    rawText?: string | null
    draftData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    validatedAt?: Date | string | null
    createdBy: string
  }

  export type SemanticNodeCreateManyPatientInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    consultationId?: string | null
  }

  export type MedicalDocumentCreateManyPatientInput = {
    id?: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    consultationId?: string | null
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    medicationName: string
    atcCode?: string | null
    dosage: string
    frequency: string
    duration?: string | null
    status?: string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: string | null
    documentId?: string | null
    createdAt?: Date | string
    prescribedBy: string
  }

  export type MedicalReportCreateManyPatientInput = {
    id?: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    consultationId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type LaboratoryResultCreateManyPatientInput = {
    id?: string
    testName: string
    testCode?: string | null
    resultValue: string
    unit?: string | null
    referenceRange?: string | null
    status: string
    testDate: Date | string
    receivedAt?: Date | string
    laboratoryName?: string | null
    documentId?: string | null
  }

  export type MedicalImageCreateManyPatientInput = {
    id?: string
    studyInstanceUid: string
    seriesInstanceUid?: string | null
    sopInstanceUid?: string | null
    modality: string
    bodyPart?: string | null
    studyDescription?: string | null
    seriesDescription?: string | null
    filePath: string
    fileSize: number
    documentId?: string | null
    acquisitionDate: Date | string
    createdAt?: Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    doctorId?: string | null
    doctorName?: string | null
    appointmentDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    appointmentType: string
    title?: string | null
    description?: string | null
    status?: string
    location?: string | null
    consultationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    cancellationReason?: string | null
  }

  export type AllergyCreateManyPatientInput = {
    id?: string
    substance: string
    snomedCtCode?: string | null
    severity: string
    createdAt?: Date | string
    source?: string | null
  }

  export type ConsultationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    semanticNodes?: SemanticNodeUncheckedUpdateManyWithoutConsultationNestedInput
    medicalDocuments?: MedicalDocumentUncheckedUpdateManyWithoutConsultationNestedInput
    medicalReports?: MedicalReportUncheckedUpdateManyWithoutConsultationNestedInput
    appointment?: AppointmentUncheckedUpdateOneWithoutConsultationNestedInput
    billingEvents?: BillingEventUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    rawTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    draftData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SemanticNodeUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceRelations?: SemanticRelationUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUpdateManyWithoutTargetNodeNestedInput
    consultation?: ConsultationUpdateOneWithoutSemanticNodesNestedInput
  }

  export type SemanticNodeUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceRelations?: SemanticRelationUncheckedUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type SemanticNodeUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalDocumentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultation?: ConsultationUpdateOneWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
    document?: MedicalDocumentUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    atcCode?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    safetyChecks?: NullableJsonNullValueInput | InputJsonValue
    outpassReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescribedBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    document?: MedicalDocumentUpdateOneWithoutMedicalReportNestedInput
    consultation?: ConsultationUpdateOneWithoutMedicalReportsNestedInput
  }

  export type MedicalReportUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryResultUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    document?: MedicalDocumentUpdateOneWithoutLaboratoryResultNestedInput
  }

  export type LaboratoryResultUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaboratoryResultUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    testCode?: NullableStringFieldUpdateOperationsInput | string | null
    resultValue?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laboratoryName?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalImageUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: MedicalDocumentUpdateOneWithoutMedicalImageNestedInput
  }

  export type MedicalImageUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalImageUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    sopInstanceUid?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    studyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    seriesDescription?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    consultation?: ConsultationUpdateOneWithoutAppointmentNestedInput
    reminders?: AppointmentReminderUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    reminders?: AppointmentReminderUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    substance?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SemanticRelationCreateManySourceNodeInput = {
    id?: string
    targetNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationCreateManyTargetNodeInput = {
    id?: string
    sourceNodeId: string
    relationType: string
    strength?: number | null
    evidence?: string | null
    createdAt?: Date | string
    confidence?: number | null
  }

  export type SemanticRelationUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    targetNode?: SemanticNodeUpdateOneRequiredWithoutTargetRelationsNestedInput
  }

  export type SemanticRelationUncheckedUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticRelationUncheckedUpdateManyWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticRelationUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceNode?: SemanticNodeUpdateOneRequiredWithoutSourceRelationsNestedInput
  }

  export type SemanticRelationUncheckedUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticRelationUncheckedUpdateManyWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    relationType?: StringFieldUpdateOperationsInput | string
    strength?: NullableFloatFieldUpdateOperationsInput | number | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SemanticNodeCreateManyConsultationInput = {
    id?: string
    nodeType: string
    snomedCtCode?: string | null
    cim10Code?: string | null
    cim11Code?: string | null
    label: string
    description?: string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confidence?: number | null
    patientId?: string | null
  }

  export type MedicalDocumentCreateManyConsultationInput = {
    id?: string
    patientId: string
    documentType: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    rawContent?: string | null
    documentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type MedicalReportCreateManyConsultationInput = {
    id?: string
    patientId: string
    reportType: string
    title: string
    chiefComplaint?: string | null
    history?: string | null
    examination?: string | null
    assessment?: string | null
    plan?: string | null
    documentId?: string | null
    reportDate: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type BillingEventCreateManyConsultationInput = {
    id?: string
    ghmCode?: string | null
    actCode?: string | null
    actType: string
    status?: string
    evidenceNodeIds?: BillingEventCreateevidenceNodeIdsInput | string[]
    createdAt?: Date | string
    transmittedAt?: Date | string | null
  }

  export type SemanticNodeUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patient?: PatientUpdateOneWithoutSemanticNodesNestedInput
    sourceRelations?: SemanticRelationUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUpdateManyWithoutTargetNodeNestedInput
  }

  export type SemanticNodeUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceRelations?: SemanticRelationUncheckedUpdateManyWithoutSourceNodeNestedInput
    targetRelations?: SemanticRelationUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type SemanticNodeUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    snomedCtCode?: NullableStringFieldUpdateOperationsInput | string | null
    cim10Code?: NullableStringFieldUpdateOperationsInput | string | null
    cim11Code?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalDocumentUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalDocumentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUncheckedUpdateOneWithoutDocumentNestedInput
    medicalReport?: MedicalReportUncheckedUpdateOneWithoutDocumentNestedInput
    laboratoryResult?: LaboratoryResultUncheckedUpdateOneWithoutDocumentNestedInput
    medicalImage?: MedicalImageUncheckedUpdateOneWithoutDocumentNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    rawContent?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicalReportsNestedInput
    document?: MedicalDocumentUpdateOneWithoutMedicalReportNestedInput
  }

  export type MedicalReportUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalReportUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    examination?: NullableStringFieldUpdateOperationsInput | string | null
    assessment?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type BillingEventUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BillingEventUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BillingEventUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ghmCode?: NullableStringFieldUpdateOperationsInput | string | null
    actCode?: NullableStringFieldUpdateOperationsInput | string | null
    actType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    evidenceNodeIds?: BillingEventUpdateevidenceNodeIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentAttachmentCreateManyDocumentInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentAttachmentUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAttachmentUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentReminderCreateManyAppointmentInput = {
    id?: string
    reminderType: string
    reminderTime: Date | string
    status?: string
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentReminderUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentReminderUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentReminderUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: StringFieldUpdateOperationsInput | string
    reminderTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    fileName: string
    filePath: string
    mimeType: string
    fileSize: number
    uploadedAt?: Date | string
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalMessageCreateManyThreadInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: string
    status?: string
    createdAt?: Date | string
    readAt?: Date | string | null
    archivedAt?: Date | string | null
  }

  export type InternalMessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type InternalMessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InternalMessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftCreateManyStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    startTime: Date | string
    endTime: Date | string
    shiftType: string
    location?: string | null
    status?: string
    createdAt?: Date | string
    createdBy: string
  }

  export type LeaveCreateManyStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
  }

  export type ScheduleCreateManyStaffMemberInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    scheduleData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ShiftUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftUncheckedUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftUncheckedUpdateManyWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveUncheckedUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveUncheckedUpdateManyWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleUncheckedUpdateWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleUncheckedUpdateManyWithoutStaffMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockMovementCreateManyStockItemInput = {
    id?: string
    movementType: string
    quantity: number
    reference?: string | null
    referenceType?: string | null
    movementDate?: Date | string
    createdAt?: Date | string
    createdBy: string
  }

  export type StockAlertCreateManyStockItemInput = {
    id?: string
    alertType: string
    severity: string
    message: string
    status?: string
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
  }

  export type StockMovementUpdateWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockMovementUncheckedUpdateWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockMovementUncheckedUpdateManyWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type StockAlertUpdateWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockAlertUncheckedUpdateWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockAlertUncheckedUpdateManyWithoutStockItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemanticNodeCountOutputTypeDefaultArgs instead
     */
    export type SemanticNodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SemanticNodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationCountOutputTypeDefaultArgs instead
     */
    export type ConsultationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalDocumentCountOutputTypeDefaultArgs instead
     */
    export type MedicalDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalDocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentCountOutputTypeDefaultArgs instead
     */
    export type AppointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternalMessageCountOutputTypeDefaultArgs instead
     */
    export type InternalMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternalMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageThreadCountOutputTypeDefaultArgs instead
     */
    export type MessageThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffMemberCountOutputTypeDefaultArgs instead
     */
    export type StaffMemberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffMemberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockItemCountOutputTypeDefaultArgs instead
     */
    export type StockItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemanticNodeDefaultArgs instead
     */
    export type SemanticNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SemanticNodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemanticRelationDefaultArgs instead
     */
    export type SemanticRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SemanticRelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationDraftDefaultArgs instead
     */
    export type ConsultationDraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationDraftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationDefaultArgs instead
     */
    export type ConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingEventDefaultArgs instead
     */
    export type BillingEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AllergyDefaultArgs instead
     */
    export type AllergyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AllergyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalDocumentDefaultArgs instead
     */
    export type MedicalDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentAttachmentDefaultArgs instead
     */
    export type DocumentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionDefaultArgs instead
     */
    export type PrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalReportDefaultArgs instead
     */
    export type MedicalReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LaboratoryResultDefaultArgs instead
     */
    export type LaboratoryResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LaboratoryResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalImageDefaultArgs instead
     */
    export type MedicalImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackEventDefaultArgs instead
     */
    export type FeedbackEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentReminderDefaultArgs instead
     */
    export type AppointmentReminderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentReminderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternalMessageDefaultArgs instead
     */
    export type InternalMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternalMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageThreadDefaultArgs instead
     */
    export type MessageThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageAttachmentDefaultArgs instead
     */
    export type MessageAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffMemberDefaultArgs instead
     */
    export type StaffMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftDefaultArgs instead
     */
    export type ShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveDefaultArgs instead
     */
    export type LeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleDefaultArgs instead
     */
    export type ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockItemDefaultArgs instead
     */
    export type StockItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockAlertDefaultArgs instead
     */
    export type StockAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockAlertDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}